var Q0 = Object.defineProperty;
var J0 = (e, t, n) => t in e ? Q0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var rl = (e, t, n) => (J0(e, typeof t != "symbol" ? t + "" : t, n), n);
import Da from "react";
var Tp = /* @__PURE__ */ ((e) => (e.RENDER_FINISHED = "render-finished", e.RESIZE = "chart-resize", e.MOUSEOVER = "chart-mouseover", e.MOUSEOUT = "chart-mouseout", e))(Tp || {}), Mp = /* @__PURE__ */ ((e) => (e.SHOW = "show-modal", e.HIDE = "hide-modal", e))(Mp || {}), Cp = /* @__PURE__ */ ((e) => (e.UPDATE = "model-update", e))(Cp || {}), Ap = /* @__PURE__ */ ((e) => (e.SHOW_OVERFLOW_MENU = "show-toolbar-overflow-menu", e.HIDE_OVERFLOW_MENU = "hide-toolbar-overflow-menu", e.BUTTON_CLICK = "toolbar-button-click", e.SHOW_TOOLTIP = "toolbar-show-tooltip", e.HIDE_TOOLTIP = "toolbar-hide-tooltip", e))(Ap || {}), $p = /* @__PURE__ */ ((e) => (e.UPDATE = "zoom-bar-update", e.SELECTION_START = "zoom-bar-selection-start", e.SELECTION_IN_PROGRESS = "zoom-bar-selection-in-progress", e.SELECTION_END = "zoom-bar-selection-end", e))($p || {}), Lp = /* @__PURE__ */ ((e) => (e.CHANGE = "zoom-domain-change", e))(Lp || {}), Rp = /* @__PURE__ */ ((e) => (e.CANVAS_ZOOM_IN = "canvas-zoom-in", e.CANVAS_ZOOM_OUT = "canvas-zoom-out", e))(Rp || {}), kp = /* @__PURE__ */ ((e) => (e.LABEL_MOUSEOVER = "axis-label-mouseover", e.LABEL_MOUSEMOVE = "axis-label-mousemove", e.LABEL_CLICK = "axis-label-click", e.LABEL_MOUSEOUT = "axis-label-mouseout", e.LABEL_FOCUS = "axis-label-focus", e.LABEL_BLUR = "axis-label-blur", e.RENDER_COMPLETE = "axis-render-complete", e))(kp || {}), Dp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Dp || {}), Ip = /* @__PURE__ */ ((e) => (e.WORD_MOUSEOVER = "wordcloud-word-mouseover", e.WORD_MOUSEMOVE = "wordcloud-word-mousemove", e.WORD_CLICK = "wordcloud-word-click", e.WORD_MOUSEOUT = "wordcloud-word-mouseout", e))(Ip || {}), Np = /* @__PURE__ */ ((e) => (e.SLICE_MOUSEOVER = "pie-slice-mouseover", e.SLICE_MOUSEMOVE = "pie-slice-mousemove", e.SLICE_CLICK = "pie-slice-click", e.SLICE_MOUSEOUT = "pie-slice-mouseout", e))(Np || {}), Pp = /* @__PURE__ */ ((e) => (e.ARC_MOUSEOVER = "gauge-arc-mouseover", e.ARC_MOUSEMOVE = "gauge-arc-mousemove", e.ARC_CLICK = "gauge-arc-click", e.ARC_MOUSEOUT = "gauge-arc-mouseout", e))(Pp || {}), Up = /* @__PURE__ */ ((e) => (e.BAR_MOUSEOVER = "bar-mouseover", e.BAR_MOUSEMOVE = "bar-mousemove", e.BAR_CLICK = "bar-click", e.BAR_MOUSEOUT = "bar-mouseout", e))(Up || {}), Bp = /* @__PURE__ */ ((e) => (e.BOX_MOUSEOVER = "box-mouseover", e.BOX_MOUSEMOVE = "box-mousemove", e.BOX_CLICK = "box-click", e.BOX_MOUSEOUT = "box-mouseout", e.OUTLIER_MOUSEOVER = "outlier-mouseover", e.OUTLIER_MOUSEMOVE = "outlier-mousemove", e.OUTLIER_CLICK = "outlier-click", e.OUTLIER_MOUSEOUT = "outlier-mouseout", e))(Bp || {}), Hp = /* @__PURE__ */ ((e) => (e.SCATTER_MOUSEOVER = "scatter-mouseover", e.SCATTER_MOUSEMOVE = "scatter-mousemove", e.SCATTER_CLICK = "scatter-click", e.SCATTER_MOUSEOUT = "scatter-mouseout", e))(Hp || {}), Vp = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Vp || {}), Fp = /* @__PURE__ */ ((e) => (e.X_AXIS_MOUSEOVER = "radar-x-axis-mouseover", e.X_AXIS_MOUSEMOVE = "radar-x-axis-mousemove", e.X_AXIS_CLICK = "radar-x-axis-click", e.X_AXIS_MOUSEOUT = "radar-x-axis-mouseout", e))(Fp || {}), zp = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "tree-node-mouseover", e.NODE_CLICK = "tree-node-click", e.NODE_MOUSEOUT = "tree-node-mouseout", e))(zp || {}), Gp = /* @__PURE__ */ ((e) => (e.LEAF_MOUSEOVER = "leaf-mouseover", e.LEAF_MOUSEMOVE = "leaf-mousemove", e.LEAF_CLICK = "leaf-click", e.LEAF_MOUSEOUT = "leaf-mouseout", e))(Gp || {}), is = /* @__PURE__ */ ((e) => (e.SHOW = "show-tooltip", e.MOVE = "move-tooltip", e.HIDE = "hide-tooltip", e))(is || {}), jp = /* @__PURE__ */ ((e) => (e.SHOW = "show-threshold", e.HIDE = "hide-threshold", e))(jp || {}), Wp = /* @__PURE__ */ ((e) => (e.ITEM_HOVER = "legend-item-onhover", e.ITEM_CLICK = "legend-item-onclick", e.ITEM_MOUSEOUT = "legend-item-onmouseout", e.ITEMS_UPDATE = "legend-items-update", e))(Wp || {}), qp = /* @__PURE__ */ ((e) => (e.CIRCLE_MOUSEOVER = "circle-leaf-mouseover", e.CIRCLE_CLICK = "circle-leaf-click", e.CIRCLE_MOUSEOUT = "circle-leaf-mouseout", e.CIRCLE_MOUSEMOVE = "circle-leaf-mousemove", e))(qp || {}), Yp = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "alluvial-node-mouseover", e.NODE_CLICK = "alluvial-node-click", e.NODE_MOUSEOUT = "alluvial-node-mouseout", e.NODE_MOUSEMOVE = "alluvial-node-mousemove", e.LINE_MOUSEOVER = "alluvial-line-mouseover", e.LINE_CLICK = "alluvial-line-click", e.LINE_MOUSEOUT = "alluvial-line-mouseout", e.LINE_MOUSEMOVE = "alluvial-line-mousemove", e))(Yp || {}), Xp = /* @__PURE__ */ ((e) => (e.METER_MOUSEOVER = "meter-mouseover", e.METER_CLICK = "meter-click", e.METER_MOUSEOUT = "meter-mouseout", e.METER_MOUSEMOVE = "meter-mousemove", e))(Xp || {}), Zp = /* @__PURE__ */ ((e) => (e.HEATMAP_MOUSEOVER = "heatmap-mouseover", e.HEATMAP_CLICK = "heatmap-click", e.HEATMAP_MOUSEOUT = "heatmap-mouseout", e.HEATMAP_MOUSEMOVE = "hetmap-mousemove", e))(Zp || {}), Gr = /* @__PURE__ */ ((e) => (e.CHOROPLETH_MOUSEOVER = "choropleth-mouseover", e.CHOROPLETH_CLICK = "choropleth-click", e.CHOROPLETH_MOUSEOUT = "choropleth-mouseout", e.CHOROPLETH_MOUSEMOVE = "choropleth-mousemove", e))(Gr || {});
const ty = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alluvial: Yp,
  Area: Dp,
  Axis: kp,
  Bar: Up,
  Boxplot: Bp,
  CanvasZoom: Rp,
  Chart: Tp,
  Choropleth: Gr,
  CirclePack: qp,
  Gauge: Pp,
  Heatmap: Zp,
  Legend: Wp,
  Line: Vp,
  Meter: Xp,
  Modal: Mp,
  Model: Cp,
  Pie: Np,
  Radar: Fp,
  Scatter: Hp,
  Threshold: jp,
  Toolbar: Ap,
  Tooltip: is,
  Tree: zp,
  Treemap: Gp,
  WordCloud: Ip,
  ZoomBar: $p,
  ZoomDomain: Lp
}, Symbol.toStringTag, { value: "Module" })), O = ty;
var rt = /* @__PURE__ */ ((e) => (e.HTML = "html", e.SVG = "svg", e))(rt || {}), Kp = /* @__PURE__ */ ((e) => (e.WHITE = "white", e.G100 = "g100", e.G90 = "g90", e.G10 = "g10", e))(Kp || {}), st = /* @__PURE__ */ ((e) => (e.BACKGROUND = "background", e.FILL = "fill", e.STROKE = "stroke", e.TOOLTIP = "tooltip", e))(st || {}), F = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom", e))(F || {}), an = /* @__PURE__ */ ((e) => (e.GRAPH_VIEW = "graph_view", e.SLIDER_VIEW = "slider_view", e))(an || {}), qe = /* @__PURE__ */ ((e) => (e.END_LINE = "end_line", e.MID_LINE = "mid_line", e.FRONT_LINE = "front_line", e.NONE = "none", e))(qe || {}), te = /* @__PURE__ */ ((e) => (e.VERTICAL = "vertical", e.HORIZONTAL = "horizontal", e))(te || {}), et = /* @__PURE__ */ ((e) => (e.TIME = "time", e.LINEAR = "linear", e.LOG = "log", e.LABELS = "labels", e.LABELS_RATIO = "labels-ratio", e))(et || {}), ss = /* @__PURE__ */ ((e) => (e.RIGHT = "right", e.LEFT = "left", e.TOP = "top", e.BOTTOM = "bottom", e))(ss || {}), ee = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(ee || {}), ps = /* @__PURE__ */ ((e) => (e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e))(ps || {}), lu = /* @__PURE__ */ ((e) => (e.TREE = "tree", e.DENDROGRAM = "dendrogram", e))(lu || {}), Ht = /* @__PURE__ */ ((e) => (e.ROW = "row", e.COLUMN = "column", e.ROW_REVERSE = "row-reverse", e.COLUMN_REVERSE = "column-reverse", e))(Ht || {}), ut = /* @__PURE__ */ ((e) => (e.FIXED = "fixed", e.PREFERRED = "preferred", e.STRETCH = "stretch", e))(ut || {}), mi = /* @__PURE__ */ ((e) => (e.CENTER = "center", e))(mi || {}), ga = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(ga || {}), Jt = /* @__PURE__ */ ((e) => (e.GRID = "grid", e.VERT_OR_HORIZ = "vertOrHoriz", e.PIE = "pie", e.DONUT = "donut", e))(Jt || {}), xn = /* @__PURE__ */ ((e) => (e.START = "start", e.MIDDLE = "middle", e.END = "end", e))(xn || {}), bn = /* @__PURE__ */ ((e) => (e.BASELINE = "baseline", e.MIDDLE = "middle", e.HANGING = "hanging", e))(bn || {}), jr = /* @__PURE__ */ ((e) => (e.SEMI = "semi", e.FULL = "full", e))(jr || {}), Wl = /* @__PURE__ */ ((e) => (e.UP = "up", e.DOWN = "down", e))(Wl || {}), va = /* @__PURE__ */ ((e) => (e.SUCCESS = "success", e.WARNING = "warning", e.DANGER = "danger", e))(va || {}), ya = /* @__PURE__ */ ((e) => (e.ALWAYS = "always", e.AUTO = "auto", e.NEVER = "never", e))(ya || {}), Ie = /* @__PURE__ */ ((e) => (e.SCATTER = "scatter", e.LINE = "line", e.SIMPLE_BAR = "simple-bar", e.STACKED_BAR = "stacked-bar", e.GROUPED_BAR = "grouped-bar", e.AREA = "area", e.STACKED_AREA = "stacked-area", e))(Ie || {}), $t = /* @__PURE__ */ ((e) => (e.EXPORT_CSV = "Export as CSV", e.EXPORT_PNG = "Export as PNG", e.EXPORT_JPG = "Export as JPG", e.ZOOM_IN = "Zoom in", e.ZOOM_OUT = "Zoom out", e.RESET_ZOOM = "Reset zoom", e.MAKE_FULLSCREEN = "Make fullscreen", e.EXIT_FULLSCREEN = "Exit fullscreen", e.SHOW_AS_DATATABLE = "Show as data-table", e.CUSTOM = "Custom", e))($t || {}), ql = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(ql || {}), Qt = /* @__PURE__ */ ((e) => (e.CHECKBOX = "checkbox", e.RADIUS = "radius", e.AREA = "area", e.SIZE = "size", e.LINE = "line", e.QUARTILE = "quartile", e.ZOOM = "zoom", e))(Qt || {}), xa = /* @__PURE__ */ ((e) => (e.LINEAR = "linear", e.QUANTIZE = "quantize", e))(xa || {}), as = /* @__PURE__ */ ((e) => (e.ON = "on", e.AUTO = "auto", e.OFF = "off", e))(as || {}), So = /* @__PURE__ */ ((e) => (e.DEFAULT = "default", e.HOVERABLE = "hoverable", e))(So || {}), _n = /* @__PURE__ */ ((e) => (e.geoEqualEarth = "geoEqualEarth", e.geoAlbers = "geoAlbers", e.geoConicEqualArea = "geoConicEqualArea", e.geoConicEquidistant = "geoConicEquidistant", e.geoEquirectangular = "geoEquirectangular", e.geoMercator = "geoMercator", e.geoNaturalEarth1 = "geoNaturalEarth1", e))(_n || {});
function fr(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function ey(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function cu(e) {
  let t, n, r;
  e.length !== 2 ? (t = fr, n = (o, l) => fr(e(o), l), r = (o, l) => e(o) - l) : (t = e === fr || e === ey ? e : ny, n = e, r = e);
  function i(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const d = c + u >>> 1;
        n(o[d], l) < 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function s(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const d = c + u >>> 1;
        n(o[d], l) <= 0 ? c = d + 1 : u = d;
      } while (c < u);
    }
    return c;
  }
  function a(o, l, c = 0, u = o.length) {
    const d = i(o, l, c, u - 1);
    return d > c && r(o[d - 1], l) > -r(o[d], l) ? d - 1 : d;
  }
  return { left: i, center: a, right: s };
}
function ny() {
  return 0;
}
function ry(e) {
  return e === null ? NaN : +e;
}
function* iy(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
  }
}
const sy = cu(fr), uu = sy.right;
cu(ry).center;
function ay(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && ++n;
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (i = +i) >= i && ++n;
  }
  return n;
}
function Ye(e, t) {
  let n, r;
  if (t === void 0)
    for (const i of e)
      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
  else {
    let i = -1;
    for (let s of e)
      (s = t(s, ++i, e)) != null && (n === void 0 ? s >= s && (n = r = s) : (n > s && (n = s), r < s && (r = s)));
  }
  return [n, r];
}
class mr {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let r = 0;
    for (let i = 0; i < this._n && i < 32; i++) {
      const s = n[i], a = t + s, o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
      o && (n[r++] = o), t = a;
    }
    return n[r] = t, this._n = r + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, r, i, s, a = 0;
    if (n > 0) {
      for (a = t[--n]; n > 0 && (r = a, i = t[--n], a = r + i, s = i - (a - r), !s); )
        ;
      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (i = s * 2, r = a + i, i == r - a && (a = r));
    }
    return a;
  }
}
class yh extends Map {
  constructor(t, n = cy) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(xh(this, t));
  }
  has(t) {
    return super.has(xh(this, t));
  }
  set(t, n) {
    return super.set(oy(this, t), n);
  }
  delete(t) {
    return super.delete(ly(this, t));
  }
}
function xh({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function oy({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function ly({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function cy(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function uy(e) {
  return e;
}
function hy(e = fr) {
  if (e === fr)
    return Qp;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Qp(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
var dy = Array.prototype, fy = dy.slice;
function il(e) {
  return () => e;
}
const py = Math.sqrt(50), my = Math.sqrt(10), gy = Math.sqrt(2);
function Ia(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), a = s >= py ? 10 : s >= my ? 5 : s >= gy ? 2 : 1;
  let o, l, c;
  return i < 0 ? (c = Math.pow(10, -i) / a, o = Math.round(e * c), l = Math.round(t * c), o / c < e && ++o, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, o = Math.round(e / c), l = Math.round(t / c), o * c < e && ++o, l * c > t && --l), l < o && 0.5 <= n && n < 2 ? Ia(e, t, n * 2) : [o, l, c];
}
function Na(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const r = t < e, [i, s, a] = r ? Ia(t, e, n) : Ia(e, t, n);
  if (!(s >= i))
    return [];
  const o = s - i + 1, l = new Array(o);
  if (r)
    if (a < 0)
      for (let c = 0; c < o; ++c)
        l[c] = (s - c) / -a;
    else
      for (let c = 0; c < o; ++c)
        l[c] = (s - c) * a;
  else if (a < 0)
    for (let c = 0; c < o; ++c)
      l[c] = (i + c) / -a;
  else
    for (let c = 0; c < o; ++c)
      l[c] = (i + c) * a;
  return l;
}
function ni(e, t, n) {
  return t = +t, e = +e, n = +n, Ia(e, t, n)[2];
}
function Yl(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? ni(t, e, n) : ni(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function vy(e, t, n) {
  let r;
  for (; ; ) {
    const i = ni(e, t, n);
    if (i === r || i === 0 || !isFinite(i))
      return [e, t];
    i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;
  }
}
function yy(e) {
  return Math.max(1, Math.ceil(Math.log(ay(e)) / Math.LN2) + 1);
}
function xy() {
  var e = uy, t = Ye, n = yy;
  function r(i) {
    Array.isArray(i) || (i = Array.from(i));
    var s, a = i.length, o, l, c = new Array(a);
    for (s = 0; s < a; ++s)
      c[s] = e(i[s], s, i);
    var u = t(c), d = u[0], h = u[1], f = n(c, d, h);
    if (!Array.isArray(f)) {
      const b = h, w = +f;
      if (t === Ye && ([d, h] = vy(d, h, w)), f = Na(d, h, w), f[0] <= d && (l = ni(d, h, w)), f[f.length - 1] >= h)
        if (b >= h && t === Ye) {
          const _ = ni(d, h, w);
          isFinite(_) && (_ > 0 ? h = (Math.floor(h / _) + 1) * _ : _ < 0 && (h = (Math.ceil(h * -_) + 1) / -_));
        } else
          f.pop();
    }
    for (var p = f.length, v = 0, m = p; f[v] <= d; )
      ++v;
    for (; f[m - 1] > h; )
      --m;
    (v || m < p) && (f = f.slice(v, m), p = m - v);
    var y = new Array(p + 1), g;
    for (s = 0; s <= p; ++s)
      g = y[s] = [], g.x0 = s > 0 ? f[s - 1] : d, g.x1 = s < p ? f[s] : h;
    if (isFinite(l)) {
      if (l > 0)
        for (s = 0; s < a; ++s)
          (o = c[s]) != null && d <= o && o <= h && y[Math.min(p, Math.floor((o - d) / l))].push(i[s]);
      else if (l < 0) {
        for (s = 0; s < a; ++s)
          if ((o = c[s]) != null && d <= o && o <= h) {
            const b = Math.floor((d - o) * l);
            y[Math.min(p, b + (f[b] <= o))].push(i[s]);
          }
      }
    } else
      for (s = 0; s < a; ++s)
        (o = c[s]) != null && d <= o && o <= h && y[uu(f, o, 0, p)].push(i[s]);
    return y;
  }
  return r.value = function(i) {
    return arguments.length ? (e = typeof i == "function" ? i : il(i), r) : e;
  }, r.domain = function(i) {
    return arguments.length ? (t = typeof i == "function" ? i : il([i[0], i[1]]), r) : t;
  }, r.thresholds = function(i) {
    return arguments.length ? (n = typeof i == "function" ? i : il(Array.isArray(i) ? fy.call(i) : i), r) : n;
  }, r;
}
function gr(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Zn(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Jp(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r))
    return e;
  for (i = i === void 0 ? Qp : hy(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, c = t - n + 1, u = Math.log(l), d = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * d * (l - d) / l) * (c - l / 2 < 0 ? -1 : 1), f = Math.max(n, Math.floor(t - c * d / l + h)), p = Math.min(r, Math.floor(t + (l - c) * d / l + h));
      Jp(e, t, f, p, i);
    }
    const s = e[t];
    let a = n, o = r;
    for (Li(e, n, t), i(e[r], s) > 0 && Li(e, n, r); a < o; ) {
      for (Li(e, a, o), ++a, --o; i(e[a], s) < 0; )
        ++a;
      for (; i(e[o], s) > 0; )
        --o;
    }
    i(e[n], s) === 0 ? Li(e, n, o) : (++o, Li(e, o, r)), o <= t && (n = o + 1), t <= o && (r = o - 1);
  }
  return e;
}
function Li(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function sl(e, t, n) {
  if (e = Float64Array.from(iy(e, n)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2)
      return Zn(e);
    if (t >= 1)
      return gr(e);
    var r, i = (r - 1) * t, s = Math.floor(i), a = gr(Jp(e, s).subarray(0, s + 1)), o = Zn(e.subarray(s + 1));
    return a + (o - a) * (i - s);
  }
}
function* by(e) {
  for (const t of e)
    yield* t;
}
function tm(e) {
  return Array.from(by(e));
}
function Ey(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(i); ++r < i; )
    s[r] = e + r * n;
  return s;
}
function _y(e) {
  return e;
}
var ba = 1, Ea = 2, Xl = 3, ji = 4, bh = 1e-6;
function wy(e) {
  return "translate(" + e + ",0)";
}
function Sy(e) {
  return "translate(0," + e + ")";
}
function Oy(e) {
  return (t) => +e(t);
}
function Ty(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function My() {
  return !this.__axis;
}
function Oo(e, t) {
  var n = [], r = null, i = null, s = 6, a = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, c = e === ba || e === ji ? -1 : 1, u = e === ji || e === Ea ? "x" : "y", d = e === ba || e === Xl ? wy : Sy;
  function h(f) {
    var p = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), v = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : _y), m = Math.max(s, 0) + o, y = t.range(), g = +y[0] + l, b = +y[y.length - 1] + l, w = (t.bandwidth ? Ty : Oy)(t.copy(), l), _ = f.selection ? f.selection() : f, S = _.selectAll(".domain").data([null]), L = _.selectAll(".tick").data(p, t).order(), D = L.exit(), k = L.enter().append("g").attr("class", "tick"), R = L.select("line"), M = L.select("text");
    S = S.merge(S.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), L = L.merge(k), R = R.merge(k.append("line").attr("stroke", "currentColor").attr(u + "2", c * s)), M = M.merge(k.append("text").attr("fill", "currentColor").attr(u, c * m).attr("dy", e === ba ? "0em" : e === Xl ? "0.71em" : "0.32em")), f !== _ && (S = S.transition(f), L = L.transition(f), R = R.transition(f), M = M.transition(f), D = D.transition(f).attr("opacity", bh).attr("transform", function(V) {
      return isFinite(V = w(V)) ? d(V + l) : this.getAttribute("transform");
    }), k.attr("opacity", bh).attr("transform", function(V) {
      var P = this.parentNode.__axis;
      return d((P && isFinite(P = P(V)) ? P : w(V)) + l);
    })), D.remove(), S.attr("d", e === ji || e === Ea ? a ? "M" + c * a + "," + g + "H" + l + "V" + b + "H" + c * a : "M" + l + "," + g + "V" + b : a ? "M" + g + "," + c * a + "V" + l + "H" + b + "V" + c * a : "M" + g + "," + l + "H" + b), L.attr("opacity", 1).attr("transform", function(V) {
      return d(w(V) + l);
    }), R.attr(u + "2", c * s), M.attr(u, c * m).text(v), _.filter(My).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === Ea ? "start" : e === ji ? "end" : "middle"), _.each(function() {
      this.__axis = w;
    });
  }
  return h.scale = function(f) {
    return arguments.length ? (t = f, h) : t;
  }, h.ticks = function() {
    return n = Array.from(arguments), h;
  }, h.tickArguments = function(f) {
    return arguments.length ? (n = f == null ? [] : Array.from(f), h) : n.slice();
  }, h.tickValues = function(f) {
    return arguments.length ? (r = f == null ? null : Array.from(f), h) : r && r.slice();
  }, h.tickFormat = function(f) {
    return arguments.length ? (i = f, h) : i;
  }, h.tickSize = function(f) {
    return arguments.length ? (s = a = +f, h) : s;
  }, h.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, h) : s;
  }, h.tickSizeOuter = function(f) {
    return arguments.length ? (a = +f, h) : a;
  }, h.tickPadding = function(f) {
    return arguments.length ? (o = +f, h) : o;
  }, h.offset = function(f) {
    return arguments.length ? (l = +f, h) : l;
  }, h;
}
function Cy(e) {
  return Oo(ba, e);
}
function Ay(e) {
  return Oo(Ea, e);
}
function hu(e) {
  return Oo(Xl, e);
}
function em(e) {
  return Oo(ji, e);
}
var $y = { value: () => {
} };
function du() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new _a(n);
}
function _a(e) {
  this._ = e;
}
function Ly(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
_a.prototype = du.prototype = {
  constructor: _a,
  on: function(e, t) {
    var n = this._, r = Ly(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((i = (e = r[s]).type) && (i = Ry(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type)
        n[i] = Eh(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Eh(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new _a(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, s; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r)
      s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
      r[i].value.apply(t, n);
  }
};
function Ry(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Eh(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = $y, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Zl = "http://www.w3.org/1999/xhtml";
const _h = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Zl,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function To(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), _h.hasOwnProperty(t) ? { space: _h[t], local: e } : e;
}
function ky(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Zl && t.documentElement.namespaceURI === Zl ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function Dy(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function nm(e) {
  var t = To(e);
  return (t.local ? Dy : ky)(t);
}
function Iy() {
}
function fu(e) {
  return e == null ? Iy : function() {
    return this.querySelector(e);
  };
}
function Ny(e) {
  typeof e != "function" && (e = fu(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = new Array(a), l, c, u = 0; u < a; ++u)
      (l = s[u]) && (c = e.call(l, l.__data__, u, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[u] = c);
  return new Ae(r, this._parents);
}
function Py(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Uy() {
  return [];
}
function rm(e) {
  return e == null ? Uy : function() {
    return this.querySelectorAll(e);
  };
}
function By(e) {
  return function() {
    return Py(e.apply(this, arguments));
  };
}
function Hy(e) {
  typeof e == "function" ? e = By(e) : e = rm(e);
  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
    for (var a = t[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && (r.push(e.call(l, l.__data__, c, a)), i.push(l));
  return new Ae(r, i);
}
function im(e) {
  return function() {
    return this.matches(e);
  };
}
function sm(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Vy = Array.prototype.find;
function Fy(e) {
  return function() {
    return Vy.call(this.children, e);
  };
}
function zy() {
  return this.firstElementChild;
}
function Gy(e) {
  return this.select(e == null ? zy : Fy(typeof e == "function" ? e : sm(e)));
}
var jy = Array.prototype.filter;
function Wy() {
  return Array.from(this.children);
}
function qy(e) {
  return function() {
    return jy.call(this.children, e);
  };
}
function Yy(e) {
  return this.selectAll(e == null ? Wy : qy(typeof e == "function" ? e : sm(e)));
}
function Xy(e) {
  typeof e != "function" && (e = im(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new Ae(r, this._parents);
}
function am(e) {
  return new Array(e.length);
}
function Zy() {
  return new Ae(this._enter || this._groups.map(am), this._parents);
}
function Pa(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Pa.prototype = {
  constructor: Pa,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Ky(e) {
  return function() {
    return e;
  };
}
function Qy(e, t, n, r, i, s) {
  for (var a = 0, o, l = t.length, c = s.length; a < c; ++a)
    (o = t[a]) ? (o.__data__ = s[a], r[a] = o) : n[a] = new Pa(e, s[a]);
  for (; a < l; ++a)
    (o = t[a]) && (i[a] = o);
}
function Jy(e, t, n, r, i, s, a) {
  var o, l, c = /* @__PURE__ */ new Map(), u = t.length, d = s.length, h = new Array(u), f;
  for (o = 0; o < u; ++o)
    (l = t[o]) && (h[o] = f = a.call(l, l.__data__, o, t) + "", c.has(f) ? i[o] = l : c.set(f, l));
  for (o = 0; o < d; ++o)
    f = a.call(e, s[o], o, s) + "", (l = c.get(f)) ? (r[o] = l, l.__data__ = s[o], c.delete(f)) : n[o] = new Pa(e, s[o]);
  for (o = 0; o < u; ++o)
    (l = t[o]) && c.get(h[o]) === l && (i[o] = l);
}
function t1(e) {
  return e.__data__;
}
function e1(e, t) {
  if (!arguments.length)
    return Array.from(this, t1);
  var n = t ? Jy : Qy, r = this._parents, i = this._groups;
  typeof e != "function" && (e = Ky(e));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var u = r[c], d = i[c], h = d.length, f = n1(e.call(u, u && u.__data__, c, r)), p = f.length, v = o[c] = new Array(p), m = a[c] = new Array(p), y = l[c] = new Array(h);
    n(u, d, v, m, y, f, t);
    for (var g = 0, b = 0, w, _; g < p; ++g)
      if (w = v[g]) {
        for (g >= b && (b = g + 1); !(_ = m[b]) && ++b < p; )
          ;
        w._next = _ || null;
      }
  }
  return a = new Ae(a, r), a._enter = o, a._exit = l, a;
}
function n1(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function r1() {
  return new Ae(this._exit || this._groups.map(am), this._parents);
}
function i1(e, t, n) {
  var r = this.enter(), i = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
}
function s1(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var c = n[l], u = r[l], d = c.length, h = o[l] = new Array(d), f, p = 0; p < d; ++p)
      (f = c[p] || u[p]) && (h[p] = f);
  for (; l < i; ++l)
    o[l] = n[l];
  return new Ae(o, this._parents);
}
function a1() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, s = r[i], a; --i >= 0; )
      (a = r[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function o1(e) {
  e || (e = l1);
  function t(d, h) {
    return d && h ? e(d.__data__, h.__data__) : !d - !h;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
    for (var a = n[s], o = a.length, l = i[s] = new Array(o), c, u = 0; u < o; ++u)
      (c = a[u]) && (l[u] = c);
    l.sort(t);
  }
  return new Ae(i, this._parents).order();
}
function l1(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function c1() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function u1() {
  return Array.from(this);
}
function h1() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length; i < s; ++i) {
      var a = r[i];
      if (a)
        return a;
    }
  return null;
}
function d1() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function f1() {
  return !this.node();
}
function p1(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && e.call(o, o.__data__, s, i);
  return this;
}
function m1(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function g1(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function v1(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function y1(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function x1(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function b1(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function E1(e, t) {
  var n = To(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? g1 : m1 : typeof t == "function" ? n.local ? b1 : x1 : n.local ? y1 : v1)(n, t));
}
function om(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function _1(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function w1(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function S1(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function O1(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? _1 : typeof t == "function" ? S1 : w1)(e, t, n ?? "")) : ri(this.node(), e);
}
function ri(e, t) {
  return e.style.getPropertyValue(t) || om(e).getComputedStyle(e, null).getPropertyValue(t);
}
function T1(e) {
  return function() {
    delete this[e];
  };
}
function M1(e, t) {
  return function() {
    this[e] = t;
  };
}
function C1(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function A1(e, t) {
  return arguments.length > 1 ? this.each((t == null ? T1 : typeof t == "function" ? C1 : M1)(e, t)) : this.node()[e];
}
function lm(e) {
  return e.trim().split(/^|\s+/);
}
function pu(e) {
  return e.classList || new cm(e);
}
function cm(e) {
  this._node = e, this._names = lm(e.getAttribute("class") || "");
}
cm.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function um(e, t) {
  for (var n = pu(e), r = -1, i = t.length; ++r < i; )
    n.add(t[r]);
}
function hm(e, t) {
  for (var n = pu(e), r = -1, i = t.length; ++r < i; )
    n.remove(t[r]);
}
function $1(e) {
  return function() {
    um(this, e);
  };
}
function L1(e) {
  return function() {
    hm(this, e);
  };
}
function R1(e, t) {
  return function() {
    (t.apply(this, arguments) ? um : hm)(this, e);
  };
}
function k1(e, t) {
  var n = lm(e + "");
  if (arguments.length < 2) {
    for (var r = pu(this.node()), i = -1, s = n.length; ++i < s; )
      if (!r.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? R1 : t ? $1 : L1)(n, t));
}
function D1() {
  this.textContent = "";
}
function I1(e) {
  return function() {
    this.textContent = e;
  };
}
function N1(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function P1(e) {
  return arguments.length ? this.each(e == null ? D1 : (typeof e == "function" ? N1 : I1)(e)) : this.node().textContent;
}
function U1() {
  this.innerHTML = "";
}
function B1(e) {
  return function() {
    this.innerHTML = e;
  };
}
function H1(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function V1(e) {
  return arguments.length ? this.each(e == null ? U1 : (typeof e == "function" ? H1 : B1)(e)) : this.node().innerHTML;
}
function F1() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function z1() {
  return this.each(F1);
}
function G1() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function j1() {
  return this.each(G1);
}
function W1(e) {
  var t = typeof e == "function" ? e : nm(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function q1() {
  return null;
}
function Y1(e, t) {
  var n = typeof e == "function" ? e : nm(e), r = t == null ? q1 : typeof t == "function" ? t : fu(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function X1() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Z1() {
  return this.each(X1);
}
function K1() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Q1() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function J1(e) {
  return this.select(e ? Q1 : K1);
}
function tx(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function ex(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function nx(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function rx(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function ix(e, t, n) {
  return function() {
    var r = this.__on, i, s = ex(t);
    if (r) {
      for (var a = 0, o = r.length; a < o; ++a)
        if ((i = r[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), i = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function sx(e, t, n) {
  var r = nx(e + ""), i, s = r.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, c = o.length, u; l < c; ++l)
        for (i = 0, u = o[l]; i < s; ++i)
          if ((a = r[i]).type === u.type && a.name === u.name)
            return u.value;
    }
    return;
  }
  for (o = t ? ix : rx, i = 0; i < s; ++i)
    this.each(o(r[i], t, n));
  return this;
}
function dm(e, t, n) {
  var r = om(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function ax(e, t) {
  return function() {
    return dm(this, e, t);
  };
}
function ox(e, t) {
  return function() {
    return dm(this, e, t.apply(this, arguments));
  };
}
function lx(e, t) {
  return this.each((typeof t == "function" ? ox : ax)(e, t));
}
function* cx() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length, a; i < s; ++i)
      (a = r[i]) && (yield a);
}
var fm = [null];
function Ae(e, t) {
  this._groups = e, this._parents = t;
}
function $s() {
  return new Ae([[document.documentElement]], fm);
}
function ux() {
  return this;
}
Ae.prototype = $s.prototype = {
  constructor: Ae,
  select: Ny,
  selectAll: Hy,
  selectChild: Gy,
  selectChildren: Yy,
  filter: Xy,
  data: e1,
  enter: Zy,
  exit: r1,
  join: i1,
  merge: s1,
  selection: ux,
  order: a1,
  sort: o1,
  call: c1,
  nodes: u1,
  node: h1,
  size: d1,
  empty: f1,
  each: p1,
  attr: E1,
  style: O1,
  property: A1,
  classed: k1,
  text: P1,
  html: V1,
  raise: z1,
  lower: j1,
  append: W1,
  insert: Y1,
  remove: Z1,
  clone: J1,
  datum: tx,
  on: sx,
  dispatch: lx,
  [Symbol.iterator]: cx
};
function I(e) {
  return typeof e == "string" ? new Ae([[document.querySelector(e)]], [document.documentElement]) : new Ae([[e]], fm);
}
function hx(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function vr(e, t) {
  if (e = hx(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const Kl = { capture: !0, passive: !1 };
function Ql(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function dx(e) {
  var t = e.document.documentElement, n = I(e).on("dragstart.drag", Ql, Kl);
  "onselectstart" in t ? n.on("selectstart.drag", Ql, Kl) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function fx(e, t) {
  var n = e.document.documentElement, r = I(e).on("dragstart.drag", null);
  t && (r.on("click.drag", Ql, Kl), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function mu(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function pm(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t)
    n[r] = t[r];
  return n;
}
function Ls() {
}
var ms = 0.7, Ua = 1 / ms, Qr = "\\s*([+-]?\\d+)\\s*", gs = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", cn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", px = /^#([0-9a-f]{3,8})$/, mx = new RegExp(`^rgb\\(${Qr},${Qr},${Qr}\\)$`), gx = new RegExp(`^rgb\\(${cn},${cn},${cn}\\)$`), vx = new RegExp(`^rgba\\(${Qr},${Qr},${Qr},${gs}\\)$`), yx = new RegExp(`^rgba\\(${cn},${cn},${cn},${gs}\\)$`), xx = new RegExp(`^hsl\\(${gs},${cn},${cn}\\)$`), bx = new RegExp(`^hsla\\(${gs},${cn},${cn},${gs}\\)$`), wh = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
mu(Ls, $n, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Sh,
  // Deprecated! Use color.formatHex.
  formatHex: Sh,
  formatHex8: Ex,
  formatHsl: _x,
  formatRgb: Oh,
  toString: Oh
});
function Sh() {
  return this.rgb().formatHex();
}
function Ex() {
  return this.rgb().formatHex8();
}
function _x() {
  return mm(this).formatHsl();
}
function Oh() {
  return this.rgb().formatRgb();
}
function $n(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = px.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Th(t) : n === 3 ? new ye(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Ks(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Ks(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = mx.exec(e)) ? new ye(t[1], t[2], t[3], 1) : (t = gx.exec(e)) ? new ye(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = vx.exec(e)) ? Ks(t[1], t[2], t[3], t[4]) : (t = yx.exec(e)) ? Ks(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = xx.exec(e)) ? Ah(t[1], t[2] / 100, t[3] / 100, 1) : (t = bx.exec(e)) ? Ah(t[1], t[2] / 100, t[3] / 100, t[4]) : wh.hasOwnProperty(e) ? Th(wh[e]) : e === "transparent" ? new ye(NaN, NaN, NaN, 0) : null;
}
function Th(e) {
  return new ye(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Ks(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new ye(e, t, n, r);
}
function wx(e) {
  return e instanceof Ls || (e = $n(e)), e ? (e = e.rgb(), new ye(e.r, e.g, e.b, e.opacity)) : new ye();
}
function Jl(e, t, n, r) {
  return arguments.length === 1 ? wx(e) : new ye(e, t, n, r ?? 1);
}
function ye(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
mu(ye, Jl, pm(Ls, {
  brighter(e) {
    return e = e == null ? Ua : Math.pow(Ua, e), new ye(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ms : Math.pow(ms, e), new ye(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ye(pr(this.r), pr(this.g), pr(this.b), Ba(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Mh,
  // Deprecated! Use color.formatHex.
  formatHex: Mh,
  formatHex8: Sx,
  formatRgb: Ch,
  toString: Ch
}));
function Mh() {
  return `#${dr(this.r)}${dr(this.g)}${dr(this.b)}`;
}
function Sx() {
  return `#${dr(this.r)}${dr(this.g)}${dr(this.b)}${dr((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Ch() {
  const e = Ba(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${pr(this.r)}, ${pr(this.g)}, ${pr(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Ba(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function pr(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function dr(e) {
  return e = pr(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Ah(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new je(e, t, n, r);
}
function mm(e) {
  if (e instanceof je)
    return new je(e.h, e.s, e.l, e.opacity);
  if (e instanceof Ls || (e = $n(e)), !e)
    return new je();
  if (e instanceof je)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (t === s ? a = (n - r) / o + (n < r) * 6 : n === s ? a = (r - t) / o + 2 : a = (t - n) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new je(a, o, l, e.opacity);
}
function gu(e, t, n, r) {
  return arguments.length === 1 ? mm(e) : new je(e, t, n, r ?? 1);
}
function je(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
mu(je, gu, pm(Ls, {
  brighter(e) {
    return e = e == null ? Ua : Math.pow(Ua, e), new je(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ms : Math.pow(ms, e), new je(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new ye(
      al(e >= 240 ? e - 240 : e + 120, i, r),
      al(e, i, r),
      al(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new je($h(this.h), Qs(this.s), Qs(this.l), Ba(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Ba(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${$h(this.h)}, ${Qs(this.s) * 100}%, ${Qs(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function $h(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Qs(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function al(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const vu = (e) => () => e;
function Ox(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function Tx(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function Mx(e) {
  return (e = +e) == 1 ? gm : function(t, n) {
    return n - t ? Tx(t, n, e) : vu(isNaN(t) ? n : t);
  };
}
function gm(e, t) {
  var n = t - e;
  return n ? Ox(e, n) : vu(isNaN(e) ? t : e);
}
const Ha = function e(t) {
  var n = Mx(t);
  function r(i, s) {
    var a = n((i = Jl(i)).r, (s = Jl(s)).r), o = n(i.g, s.g), l = n(i.b, s.b), c = gm(i.opacity, s.opacity);
    return function(u) {
      return i.r = a(u), i.g = o(u), i.b = l(u), i.opacity = c(u), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Cx(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(s) {
    for (i = 0; i < n; ++i)
      r[i] = e[i] * (1 - s) + t[i] * s;
    return r;
  };
}
function Ax(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function $x(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), s = new Array(n), a;
  for (a = 0; a < r; ++a)
    i[a] = Rs(e[a], t[a]);
  for (; a < n; ++a)
    s[a] = t[a];
  return function(o) {
    for (a = 0; a < r; ++a)
      s[a] = i[a](o);
    return s;
  };
}
function Lx(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function Me(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function Rx(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = Rs(e[i], t[i]) : r[i] = t[i];
  return function(s) {
    for (i in n)
      r[i] = n[i](s);
    return r;
  };
}
var tc = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, ol = new RegExp(tc.source, "g");
function kx(e) {
  return function() {
    return e;
  };
}
function Dx(e) {
  return function(t) {
    return e(t) + "";
  };
}
function vm(e, t) {
  var n = tc.lastIndex = ol.lastIndex = 0, r, i, s, a = -1, o = [], l = [];
  for (e = e + "", t = t + ""; (r = tc.exec(e)) && (i = ol.exec(t)); )
    (s = i.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (r = r[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: Me(r, i) })), n = ol.lastIndex;
  return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? Dx(l[0].x) : kx(t) : (t = l.length, function(c) {
    for (var u = 0, d; u < t; ++u)
      o[(d = l[u]).i] = d.x(c);
    return o.join("");
  });
}
function Rs(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? vu(t) : (n === "number" ? Me : n === "string" ? (r = $n(t)) ? (t = r, Ha) : vm : t instanceof $n ? Ha : t instanceof Date ? Lx : Ax(t) ? Cx : Array.isArray(t) ? $x : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Rx : Me)(e, t);
}
function ym(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var Lh = 180 / Math.PI, ec = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function xm(e, t, n, r, i, s) {
  var a, o, l;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * r) && (n -= e * l, r -= t * l), (o = Math.sqrt(n * n + r * r)) && (n /= o, r /= o, l /= o), e * r < t * n && (e = -e, t = -t, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(t, e) * Lh,
    skewX: Math.atan(l) * Lh,
    scaleX: a,
    scaleY: o
  };
}
var Js;
function Ix(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? ec : xm(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Nx(e) {
  return e == null || (Js || (Js = document.createElementNS("http://www.w3.org/2000/svg", "g")), Js.setAttribute("transform", e), !(e = Js.transform.baseVal.consolidate())) ? ec : (e = e.matrix, xm(e.a, e.b, e.c, e.d, e.e, e.f));
}
function bm(e, t, n, r) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, u, d, h, f, p) {
    if (c !== d || u !== h) {
      var v = f.push("translate(", null, t, null, n);
      p.push({ i: v - 4, x: Me(c, d) }, { i: v - 2, x: Me(u, h) });
    } else
      (d || h) && f.push("translate(" + d + t + h + n);
  }
  function a(c, u, d, h) {
    c !== u ? (c - u > 180 ? u += 360 : u - c > 180 && (c += 360), h.push({ i: d.push(i(d) + "rotate(", null, r) - 2, x: Me(c, u) })) : u && d.push(i(d) + "rotate(" + u + r);
  }
  function o(c, u, d, h) {
    c !== u ? h.push({ i: d.push(i(d) + "skewX(", null, r) - 2, x: Me(c, u) }) : u && d.push(i(d) + "skewX(" + u + r);
  }
  function l(c, u, d, h, f, p) {
    if (c !== d || u !== h) {
      var v = f.push(i(f) + "scale(", null, ",", null, ")");
      p.push({ i: v - 4, x: Me(c, d) }, { i: v - 2, x: Me(u, h) });
    } else
      (d !== 1 || h !== 1) && f.push(i(f) + "scale(" + d + "," + h + ")");
  }
  return function(c, u) {
    var d = [], h = [];
    return c = e(c), u = e(u), s(c.translateX, c.translateY, u.translateX, u.translateY, d, h), a(c.rotate, u.rotate, d, h), o(c.skewX, u.skewX, d, h), l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, d, h), c = u = null, function(f) {
      for (var p = -1, v = h.length, m; ++p < v; )
        d[(m = h[p]).i] = m.x(f);
      return d.join("");
    };
  };
}
var Px = bm(Ix, "px, ", "px)", "deg)"), Ux = bm(Nx, ", ", ")", ")");
function Bx(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r)
    n[r] = e(r / (t - 1));
  return n;
}
var ii = 0, Wi = 0, Ri = 0, Em = 1e3, Va, qi, Fa = 0, yr = 0, Mo = 0, vs = typeof performance == "object" && performance.now ? performance : Date, _m = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function yu() {
  return yr || (_m(Hx), yr = vs.now() + Mo);
}
function Hx() {
  yr = 0;
}
function za() {
  this._call = this._time = this._next = null;
}
za.prototype = wm.prototype = {
  constructor: za,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? yu() : +n) + (t == null ? 0 : +t), !this._next && qi !== this && (qi ? qi._next = this : Va = this, qi = this), this._call = e, this._time = n, nc();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, nc());
  }
};
function wm(e, t, n) {
  var r = new za();
  return r.restart(e, t, n), r;
}
function Vx() {
  yu(), ++ii;
  for (var e = Va, t; e; )
    (t = yr - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --ii;
}
function Rh() {
  yr = (Fa = vs.now()) + Mo, ii = Wi = 0;
  try {
    Vx();
  } finally {
    ii = 0, zx(), yr = 0;
  }
}
function Fx() {
  var e = vs.now(), t = e - Fa;
  t > Em && (Mo -= t, Fa = e);
}
function zx() {
  for (var e, t = Va, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Va = n);
  qi = e, nc(r);
}
function nc(e) {
  if (!ii) {
    Wi && (Wi = clearTimeout(Wi));
    var t = e - yr;
    t > 24 ? (e < 1 / 0 && (Wi = setTimeout(Rh, e - vs.now() - Mo)), Ri && (Ri = clearInterval(Ri))) : (Ri || (Fa = vs.now(), Ri = setInterval(Fx, Em)), ii = 1, _m(Rh));
  }
}
function kh(e, t, n) {
  var r = new za();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var Gx = du("start", "end", "cancel", "interrupt"), jx = [], Sm = 0, Dh = 1, rc = 2, wa = 3, Ih = 4, ic = 5, Sa = 6;
function Co(e, t, n, r, i, s) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  Wx(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Gx,
    tween: jx,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Sm
  });
}
function xu(e, t) {
  var n = Je(e, t);
  if (n.state > Sm)
    throw new Error("too late; already scheduled");
  return n;
}
function fn(e, t) {
  var n = Je(e, t);
  if (n.state > wa)
    throw new Error("too late; already running");
  return n;
}
function Je(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Wx(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = wm(s, 0, n.time);
  function s(c) {
    n.state = Dh, n.timer.restart(a, n.delay, n.time), n.delay <= c && a(c - n.delay);
  }
  function a(c) {
    var u, d, h, f;
    if (n.state !== Dh)
      return l();
    for (u in r)
      if (f = r[u], f.name === n.name) {
        if (f.state === wa)
          return kh(a);
        f.state === Ih ? (f.state = Sa, f.timer.stop(), f.on.call("interrupt", e, e.__data__, f.index, f.group), delete r[u]) : +u < t && (f.state = Sa, f.timer.stop(), f.on.call("cancel", e, e.__data__, f.index, f.group), delete r[u]);
      }
    if (kh(function() {
      n.state === wa && (n.state = Ih, n.timer.restart(o, n.delay, n.time), o(c));
    }), n.state = rc, n.on.call("start", e, e.__data__, n.index, n.group), n.state === rc) {
      for (n.state = wa, i = new Array(h = n.tween.length), u = 0, d = -1; u < h; ++u)
        (f = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++d] = f);
      i.length = d + 1;
    }
  }
  function o(c) {
    for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), n.state = ic, 1), d = -1, h = i.length; ++d < h; )
      i[d].call(e, u);
    n.state === ic && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = Sa, n.timer.stop(), delete r[t];
    for (var c in r)
      return;
    delete e.__transition;
  }
}
function sc(e, t) {
  var n = e.__transition, r, i, s = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((r = n[a]).name !== t) {
        s = !1;
        continue;
      }
      i = r.state > rc && r.state < ic, r.state = Sa, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
    }
    s && delete e.__transition;
  }
}
function qx(e) {
  return this.each(function() {
    sc(this, e);
  });
}
function Yx(e, t) {
  var n, r;
  return function() {
    var i = fn(this, e), s = i.tween;
    if (s !== n) {
      r = n = s;
      for (var a = 0, o = r.length; a < o; ++a)
        if (r[a].name === t) {
          r = r.slice(), r.splice(a, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function Xx(e, t, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var s = fn(this, e), a = s.tween;
    if (a !== r) {
      i = (r = a).slice();
      for (var o = { name: t, value: n }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === t) {
          i[l] = o;
          break;
        }
      l === c && i.push(o);
    }
    s.tween = i;
  };
}
function Zx(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Je(this.node(), n).tween, i = 0, s = r.length, a; i < s; ++i)
      if ((a = r[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? Yx : Xx)(n, e, t));
}
function bu(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = fn(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Je(i, r).value[t];
  };
}
function Om(e, t) {
  var n;
  return (typeof t == "number" ? Me : t instanceof $n ? Ha : (n = $n(t)) ? (t = n, Ha) : vm)(e, t);
}
function Kx(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Qx(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Jx(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function tb(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function eb(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function nb(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function rb(e, t) {
  var n = To(e), r = n === "transform" ? Ux : Om;
  return this.attrTween(e, typeof t == "function" ? (n.local ? nb : eb)(n, r, bu(this, "attr." + e, t)) : t == null ? (n.local ? Qx : Kx)(n) : (n.local ? tb : Jx)(n, r, t));
}
function ib(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function sb(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function ab(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && sb(e, s)), n;
  }
  return i._value = t, i;
}
function ob(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && ib(e, s)), n;
  }
  return i._value = t, i;
}
function lb(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var r = To(e);
  return this.tween(n, (r.local ? ab : ob)(r, t));
}
function cb(e, t) {
  return function() {
    xu(this, e).delay = +t.apply(this, arguments);
  };
}
function ub(e, t) {
  return t = +t, function() {
    xu(this, e).delay = t;
  };
}
function hb(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? cb : ub)(t, e)) : Je(this.node(), t).delay;
}
function db(e, t) {
  return function() {
    fn(this, e).duration = +t.apply(this, arguments);
  };
}
function fb(e, t) {
  return t = +t, function() {
    fn(this, e).duration = t;
  };
}
function pb(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? db : fb)(t, e)) : Je(this.node(), t).duration;
}
function mb(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    fn(this, e).ease = t;
  };
}
function gb(e) {
  var t = this._id;
  return arguments.length ? this.each(mb(t, e)) : Je(this.node(), t).ease;
}
function vb(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    fn(this, e).ease = n;
  };
}
function yb(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(vb(this._id, e));
}
function xb(e) {
  typeof e != "function" && (e = im(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new Ln(r, this._parents, this._name, this._id);
}
function bb(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), a = new Array(r), o = 0; o < s; ++o)
    for (var l = t[o], c = n[o], u = l.length, d = a[o] = new Array(u), h, f = 0; f < u; ++f)
      (h = l[f] || c[f]) && (d[f] = h);
  for (; o < r; ++o)
    a[o] = t[o];
  return new Ln(a, this._parents, this._name, this._id);
}
function Eb(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function _b(e, t, n) {
  var r, i, s = Eb(t) ? xu : fn;
  return function() {
    var a = s(this, e), o = a.on;
    o !== r && (i = (r = o).copy()).on(t, n), a.on = i;
  };
}
function wb(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Je(this.node(), n).on.on(e) : this.each(_b(n, e, t));
}
function Sb(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function Ob() {
  return this.on("end.remove", Sb(this._id));
}
function Tb(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = fu(e));
  for (var r = this._groups, i = r.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = r[a], l = o.length, c = s[a] = new Array(l), u, d, h = 0; h < l; ++h)
      (u = o[h]) && (d = e.call(u, u.__data__, h, o)) && ("__data__" in u && (d.__data__ = u.__data__), c[h] = d, Co(c[h], t, n, h, c, Je(u, n)));
  return new Ln(s, this._parents, t, n);
}
function Mb(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = rm(e));
  for (var r = this._groups, i = r.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = r[o], c = l.length, u, d = 0; d < c; ++d)
      if (u = l[d]) {
        for (var h = e.call(u, u.__data__, d, l), f, p = Je(u, n), v = 0, m = h.length; v < m; ++v)
          (f = h[v]) && Co(f, t, n, v, h, p);
        s.push(h), a.push(u);
      }
  return new Ln(s, a, t, n);
}
var Cb = $s.prototype.constructor;
function Ab() {
  return new Cb(this._groups, this._parents);
}
function $b(e, t) {
  var n, r, i;
  return function() {
    var s = ri(this, e), a = (this.style.removeProperty(e), ri(this, e));
    return s === a ? null : s === n && a === r ? i : i = t(n = s, r = a);
  };
}
function Tm(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Lb(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = ri(this, e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function Rb(e, t, n) {
  var r, i, s;
  return function() {
    var a = ri(this, e), o = n(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(e), ri(this, e))), a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o));
  };
}
function kb(e, t) {
  var n, r, i, s = "style." + t, a = "end." + s, o;
  return function() {
    var l = fn(this, e), c = l.on, u = l.value[s] == null ? o || (o = Tm(t)) : void 0;
    (c !== n || i !== u) && (r = (n = c).copy()).on(a, i = u), l.on = r;
  };
}
function Db(e, t, n) {
  var r = (e += "") == "transform" ? Px : Om;
  return t == null ? this.styleTween(e, $b(e, r)).on("end.style." + e, Tm(e)) : typeof t == "function" ? this.styleTween(e, Rb(e, r, bu(this, "style." + e, t))).each(kb(this._id, e)) : this.styleTween(e, Lb(e, r, t), n).on("end.style." + e, null);
}
function Ib(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function Nb(e, t, n) {
  var r, i;
  function s() {
    var a = t.apply(this, arguments);
    return a !== i && (r = (i = a) && Ib(e, a, n)), r;
  }
  return s._value = t, s;
}
function Pb(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, Nb(e, t, n ?? ""));
}
function Ub(e) {
  return function() {
    this.textContent = e;
  };
}
function Bb(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Hb(e) {
  return this.tween("text", typeof e == "function" ? Bb(bu(this, "text", e)) : Ub(e == null ? "" : e + ""));
}
function Vb(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Fb(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Vb(i)), t;
  }
  return r._value = e, r;
}
function zb(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, Fb(e));
}
function Gb() {
  for (var e = this._name, t = this._id, n = Mm(), r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      if (l = a[c]) {
        var u = Je(l, t);
        Co(l, e, n, c, a, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new Ln(r, this._parents, e, n);
}
function jb() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    n.each(function() {
      var c = fn(this, r), u = c.on;
      u !== e && (t = (e = u).copy(), t._.cancel.push(o), t._.interrupt.push(o), t._.end.push(l)), c.on = t;
    }), i === 0 && s();
  });
}
var Wb = 0;
function Ln(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function Mm() {
  return ++Wb;
}
var vn = $s.prototype;
Ln.prototype = {
  constructor: Ln,
  select: Tb,
  selectAll: Mb,
  selectChild: vn.selectChild,
  selectChildren: vn.selectChildren,
  filter: xb,
  merge: bb,
  selection: Ab,
  transition: Gb,
  call: vn.call,
  nodes: vn.nodes,
  node: vn.node,
  size: vn.size,
  empty: vn.empty,
  each: vn.each,
  on: wb,
  attr: rb,
  attrTween: lb,
  style: Db,
  styleTween: Pb,
  text: Hb,
  textTween: zb,
  remove: Ob,
  tween: Zx,
  delay: hb,
  duration: pb,
  ease: gb,
  easeVarying: yb,
  end: jb,
  [Symbol.iterator]: vn[Symbol.iterator]
};
const qb = (e) => +e;
function Cm(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Yb = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Cm
};
function Xb(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Zb(e) {
  var t, n;
  e instanceof Ln ? (t = e._id, e = e._name) : (t = Mm(), (n = Yb).time = yu(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && Co(l, e, t, c, a, n || Xb(l, t));
  return new Ln(r, this._parents, e, t);
}
$s.prototype.interrupt = qx;
$s.prototype.transition = Zb;
const ll = (e) => () => e;
function Kb(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function Qb(e) {
  e.stopImmediatePropagation();
}
function cl(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var Nh = { name: "drag" }, ul = { name: "space" }, kr = { name: "handle" }, Dr = { name: "center" };
const { abs: Ph, max: ae, min: oe } = Math;
function Uh(e) {
  return [+e[0], +e[1]];
}
function Bh(e) {
  return [Uh(e[0]), Uh(e[1])];
}
var Oa = {
  name: "x",
  handles: ["w", "e"].map(Ga),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, hl = {
  name: "y",
  handles: ["n", "s"].map(Ga),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, yn = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, Hh = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, Vh = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Jb = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, tE = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Ga(e) {
  return { type: e };
}
function eE(e) {
  return !e.ctrlKey && !e.button;
}
function nE() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function rE() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function dl(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function iE(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function Am() {
  return sE(Oa);
}
function sE(e) {
  var t = nE, n = eE, r = rE, i = !0, s = du("start", "brush", "end"), a = 6, o;
  function l(m) {
    var y = m.property("__brush", v).selectAll(".overlay").data([Ga("overlay")]);
    y.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", yn.overlay).merge(y).each(function() {
      var b = dl(this).extent;
      I(this).attr("x", b[0][0]).attr("y", b[0][1]).attr("width", b[1][0] - b[0][0]).attr("height", b[1][1] - b[0][1]);
    }), m.selectAll(".selection").data([Ga("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", yn.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var g = m.selectAll(".handle").data(e.handles, function(b) {
      return b.type;
    });
    g.exit().remove(), g.enter().append("rect").attr("class", function(b) {
      return "handle handle--" + b.type;
    }).attr("cursor", function(b) {
      return yn[b.type];
    }), m.each(c).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(r).on("touchstart.brush", h).on("touchmove.brush", f).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  l.move = function(m, y, g) {
    m.tween ? m.on("start.brush", function(b) {
      u(this, arguments).beforestart().start(b);
    }).on("interrupt.brush end.brush", function(b) {
      u(this, arguments).end(b);
    }).tween("brush", function() {
      var b = this, w = b.__brush, _ = u(b, arguments), S = w.selection, L = e.input(typeof y == "function" ? y.apply(this, arguments) : y, w.extent), D = Rs(S, L);
      function k(R) {
        w.selection = R === 1 && L === null ? null : D(R), c.call(b), _.brush();
      }
      return S !== null && L !== null ? k : k(1);
    }) : m.each(function() {
      var b = this, w = arguments, _ = b.__brush, S = e.input(typeof y == "function" ? y.apply(b, w) : y, _.extent), L = u(b, w).beforestart();
      sc(b), _.selection = S === null ? null : S, c.call(b), L.start(g).brush(g).end(g);
    });
  }, l.clear = function(m, y) {
    l.move(m, null, y);
  };
  function c() {
    var m = I(this), y = dl(this).selection;
    y ? (m.selectAll(".selection").style("display", null).attr("x", y[0][0]).attr("y", y[0][1]).attr("width", y[1][0] - y[0][0]).attr("height", y[1][1] - y[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(g) {
      return g.type[g.type.length - 1] === "e" ? y[1][0] - a / 2 : y[0][0] - a / 2;
    }).attr("y", function(g) {
      return g.type[0] === "s" ? y[1][1] - a / 2 : y[0][1] - a / 2;
    }).attr("width", function(g) {
      return g.type === "n" || g.type === "s" ? y[1][0] - y[0][0] + a : a;
    }).attr("height", function(g) {
      return g.type === "e" || g.type === "w" ? y[1][1] - y[0][1] + a : a;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function u(m, y, g) {
    var b = m.__brush.emitter;
    return b && (!g || !b.clean) ? b : new d(m, y, g);
  }
  function d(m, y, g) {
    this.that = m, this.args = y, this.state = m.__brush, this.active = 0, this.clean = g;
  }
  d.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, y) {
      return this.starting ? (this.starting = !1, this.emit("start", m, y)) : this.emit("brush", m), this;
    },
    brush: function(m, y) {
      return this.emit("brush", m, y), this;
    },
    end: function(m, y) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, y)), this;
    },
    emit: function(m, y, g) {
      var b = I(this.that).datum();
      s.call(
        m,
        this.that,
        new Kb(m, {
          sourceEvent: y,
          target: l,
          selection: e.output(this.state.selection),
          mode: g,
          dispatch: s
        }),
        b
      );
    }
  };
  function h(m) {
    if (o && !m.touches || !n.apply(this, arguments))
      return;
    var y = this, g = m.target.__data__.type, b = (i && m.metaKey ? g = "overlay" : g) === "selection" ? Nh : i && m.altKey ? Dr : kr, w = e === hl ? null : Jb[g], _ = e === Oa ? null : tE[g], S = dl(y), L = S.extent, D = S.selection, k = L[0][0], R, M, V = L[0][1], P, H, E = L[1][0], A, $, U = L[1][1], B, W, K = 0, Q = 0, dt, it = w && _ && i && m.shiftKey, pt, Z, tt = Array.from(m.touches || [m], (nt) => {
      const Tt = nt.identifier;
      return nt = vr(nt, y), nt.point0 = nt.slice(), nt.identifier = Tt, nt;
    });
    sc(y);
    var ft = u(y, arguments, !0).beforestart();
    if (g === "overlay") {
      D && (dt = !0);
      const nt = [tt[0], tt[1] || tt[0]];
      S.selection = D = [[
        R = e === hl ? k : oe(nt[0][0], nt[1][0]),
        P = e === Oa ? V : oe(nt[0][1], nt[1][1])
      ], [
        A = e === hl ? E : ae(nt[0][0], nt[1][0]),
        B = e === Oa ? U : ae(nt[0][1], nt[1][1])
      ]], tt.length > 1 && wt(m);
    } else
      R = D[0][0], P = D[0][1], A = D[1][0], B = D[1][1];
    M = R, H = P, $ = A, W = B;
    var q = I(y).attr("pointer-events", "none"), J = q.selectAll(".overlay").attr("cursor", yn[g]);
    if (m.touches)
      ft.moved = G, ft.ended = bt;
    else {
      var ot = I(m.view).on("mousemove.brush", G, !0).on("mouseup.brush", bt, !0);
      i && ot.on("keydown.brush", Gt, !0).on("keyup.brush", It, !0), dx(m.view);
    }
    c.call(y), ft.start(m, b.name);
    function G(nt) {
      for (const Tt of nt.changedTouches || [nt])
        for (const we of tt)
          we.identifier === Tt.identifier && (we.cur = vr(Tt, y));
      if (it && !pt && !Z && tt.length === 1) {
        const Tt = tt[0];
        Ph(Tt.cur[0] - Tt[0]) > Ph(Tt.cur[1] - Tt[1]) ? Z = !0 : pt = !0;
      }
      for (const Tt of tt)
        Tt.cur && (Tt[0] = Tt.cur[0], Tt[1] = Tt.cur[1]);
      dt = !0, cl(nt), wt(nt);
    }
    function wt(nt) {
      const Tt = tt[0], we = Tt.point0;
      var Se;
      switch (K = Tt[0] - we[0], Q = Tt[1] - we[1], b) {
        case ul:
        case Nh: {
          w && (K = ae(k - R, oe(E - A, K)), M = R + K, $ = A + K), _ && (Q = ae(V - P, oe(U - B, Q)), H = P + Q, W = B + Q);
          break;
        }
        case kr: {
          tt[1] ? (w && (M = ae(k, oe(E, tt[0][0])), $ = ae(k, oe(E, tt[1][0])), w = 1), _ && (H = ae(V, oe(U, tt[0][1])), W = ae(V, oe(U, tt[1][1])), _ = 1)) : (w < 0 ? (K = ae(k - R, oe(E - R, K)), M = R + K, $ = A) : w > 0 && (K = ae(k - A, oe(E - A, K)), M = R, $ = A + K), _ < 0 ? (Q = ae(V - P, oe(U - P, Q)), H = P + Q, W = B) : _ > 0 && (Q = ae(V - B, oe(U - B, Q)), H = P, W = B + Q));
          break;
        }
        case Dr: {
          w && (M = ae(k, oe(E, R - K * w)), $ = ae(k, oe(E, A + K * w))), _ && (H = ae(V, oe(U, P - Q * _)), W = ae(V, oe(U, B + Q * _)));
          break;
        }
      }
      $ < M && (w *= -1, Se = R, R = A, A = Se, Se = M, M = $, $ = Se, g in Hh && J.attr("cursor", yn[g = Hh[g]])), W < H && (_ *= -1, Se = P, P = B, B = Se, Se = H, H = W, W = Se, g in Vh && J.attr("cursor", yn[g = Vh[g]])), S.selection && (D = S.selection), pt && (M = D[0][0], $ = D[1][0]), Z && (H = D[0][1], W = D[1][1]), (D[0][0] !== M || D[0][1] !== H || D[1][0] !== $ || D[1][1] !== W) && (S.selection = [[M, H], [$, W]], c.call(y), ft.brush(nt, b.name));
    }
    function bt(nt) {
      if (Qb(nt), nt.touches) {
        if (nt.touches.length)
          return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        fx(nt.view, dt), ot.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      q.attr("pointer-events", "all"), J.attr("cursor", yn.overlay), S.selection && (D = S.selection), iE(D) && (S.selection = null, c.call(y)), ft.end(nt, b.name);
    }
    function Gt(nt) {
      switch (nt.keyCode) {
        case 16: {
          it = w && _;
          break;
        }
        case 18: {
          b === kr && (w && (A = $ - K * w, R = M + K * w), _ && (B = W - Q * _, P = H + Q * _), b = Dr, wt(nt));
          break;
        }
        case 32: {
          (b === kr || b === Dr) && (w < 0 ? A = $ - K : w > 0 && (R = M - K), _ < 0 ? B = W - Q : _ > 0 && (P = H - Q), b = ul, J.attr("cursor", yn.selection), wt(nt));
          break;
        }
        default:
          return;
      }
      cl(nt);
    }
    function It(nt) {
      switch (nt.keyCode) {
        case 16: {
          it && (pt = Z = it = !1, wt(nt));
          break;
        }
        case 18: {
          b === Dr && (w < 0 ? A = $ : w > 0 && (R = M), _ < 0 ? B = W : _ > 0 && (P = H), b = kr, wt(nt));
          break;
        }
        case 32: {
          b === ul && (nt.altKey ? (w && (A = $ - K * w, R = M + K * w), _ && (B = W - Q * _, P = H + Q * _), b = Dr) : (w < 0 ? A = $ : w > 0 && (R = M), _ < 0 ? B = W : _ > 0 && (P = H), b = kr), J.attr("cursor", yn[g]), wt(nt));
          break;
        }
        default:
          return;
      }
      cl(nt);
    }
  }
  function f(m) {
    u(this, arguments).moved(m);
  }
  function p(m) {
    u(this, arguments).ended(m);
  }
  function v() {
    var m = this.__brush || { selection: null };
    return m.extent = Bh(t.apply(this, arguments)), m.dim = e, m;
  }
  return l.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : ll(Bh(m)), l) : t;
  }, l.filter = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : ll(!!m), l) : n;
  }, l.touchable = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : ll(!!m), l) : r;
  }, l.handleSize = function(m) {
    return arguments.length ? (a = +m, l) : a;
  }, l.keyModifiers = function(m) {
    return arguments.length ? (i = !!m, l) : i;
  }, l.on = function() {
    var m = s.on.apply(s, arguments);
    return m === s ? l : m;
  }, l;
}
const ac = Math.PI, oc = 2 * ac, ar = 1e-6, aE = oc - ar;
function $m(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function oE(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return $m;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, s = r.length; i < s; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
let Eu = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? $m : oE(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, s, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, s) {
    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, l = r - t, c = i - n, u = a - t, d = o - n, h = u * u + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (h > ar)
      if (!(Math.abs(d * l - c * u) > ar) || !s)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let f = r - a, p = i - o, v = l * l + c * c, m = f * f + p * p, y = Math.sqrt(v), g = Math.sqrt(h), b = s * Math.tan((ac - Math.acos((v + h - m) / (2 * y * g))) / 2), w = b / g, _ = b / y;
        Math.abs(w - 1) > ar && this._append`L${t + w * u},${n + w * d}`, this._append`A${s},${s},0,0,${+(d * f > u * p)},${this._x1 = t + _ * l},${this._y1 = n + _ * c}`;
      }
  }
  arc(t, n, r, i, s, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0)
      throw new Error(`negative radius: ${r}`);
    let o = r * Math.cos(i), l = r * Math.sin(i), c = t + o, u = n + l, d = 1 ^ a, h = a ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > ar || Math.abs(this._y1 - u) > ar) && this._append`L${c},${u}`, r && (h < 0 && (h = h % oc + oc), h > aE ? this._append`A${r},${r},0,1,${d},${t - o},${n - l}A${r},${r},0,1,${d},${this._x1 = c},${this._y1 = u}` : h > ar && this._append`A${r},${r},0,${+(h >= ac)},${d},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
};
function Lm() {
  return new Eu();
}
Lm.prototype = Eu.prototype;
function lE(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function ja(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function si(e) {
  return e = ja(Math.abs(e)), e ? e[1] : NaN;
}
function cE(e, t) {
  return function(n, r) {
    for (var i = n.length, s = [], a = 0, o = e[0], l = 0; i > 0 && o > 0 && (l + o + 1 > r && (o = Math.max(1, r - l)), s.push(n.substring(i -= o, i + o)), !((l += o + 1) > r)); )
      o = e[a = (a + 1) % e.length];
    return s.reverse().join(t);
  };
}
function uE(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var hE = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function ys(e) {
  if (!(t = hE.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new _u({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
ys.prototype = _u.prototype;
function _u(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
_u.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function dE(e) {
  t:
    for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
      switch (e[n]) {
        case ".":
          r = i = n;
          break;
        case "0":
          r === 0 && (r = n), i = n;
          break;
        default:
          if (!+e[n])
            break t;
          r > 0 && (r = 0);
          break;
      }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var Rm;
function fE(e, t) {
  var n = ja(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1], s = i - (Rm = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return s === a ? r : s > a ? r + new Array(s - a + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + ja(e, Math.max(0, t + s - 1))[0];
}
function Fh(e, t) {
  var n = ja(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const zh = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: lE,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => Fh(e * 100, t),
  r: Fh,
  s: fE,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function Gh(e) {
  return e;
}
var jh = Array.prototype.map, Wh = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function pE(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? Gh : cE(jh.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? Gh : uE(jh.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", o = e.minus === void 0 ? "−" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function c(d) {
    d = ys(d);
    var h = d.fill, f = d.align, p = d.sign, v = d.symbol, m = d.zero, y = d.width, g = d.comma, b = d.precision, w = d.trim, _ = d.type;
    _ === "n" ? (g = !0, _ = "g") : zh[_] || (b === void 0 && (b = 12), w = !0, _ = "g"), (m || h === "0" && f === "=") && (m = !0, h = "0", f = "=");
    var S = v === "$" ? n : v === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", L = v === "$" ? r : /[%p]/.test(_) ? a : "", D = zh[_], k = /[defgprs%]/.test(_);
    b = b === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, b)) : Math.max(0, Math.min(20, b));
    function R(M) {
      var V = S, P = L, H, E, A;
      if (_ === "c")
        P = D(M) + P, M = "";
      else {
        M = +M;
        var $ = M < 0 || 1 / M < 0;
        if (M = isNaN(M) ? l : D(Math.abs(M), b), w && (M = dE(M)), $ && +M == 0 && p !== "+" && ($ = !1), V = ($ ? p === "(" ? p : o : p === "-" || p === "(" ? "" : p) + V, P = (_ === "s" ? Wh[8 + Rm / 3] : "") + P + ($ && p === "(" ? ")" : ""), k) {
          for (H = -1, E = M.length; ++H < E; )
            if (A = M.charCodeAt(H), 48 > A || A > 57) {
              P = (A === 46 ? i + M.slice(H + 1) : M.slice(H)) + P, M = M.slice(0, H);
              break;
            }
        }
      }
      g && !m && (M = t(M, 1 / 0));
      var U = V.length + M.length + P.length, B = U < y ? new Array(y - U + 1).join(h) : "";
      switch (g && m && (M = t(B + M, B.length ? y - P.length : 1 / 0), B = ""), f) {
        case "<":
          M = V + M + P + B;
          break;
        case "=":
          M = V + B + M + P;
          break;
        case "^":
          M = B.slice(0, U = B.length >> 1) + V + M + P + B.slice(U);
          break;
        default:
          M = B + V + M + P;
          break;
      }
      return s(M);
    }
    return R.toString = function() {
      return d + "";
    }, R;
  }
  function u(d, h) {
    var f = c((d = ys(d), d.type = "f", d)), p = Math.max(-8, Math.min(8, Math.floor(si(h) / 3))) * 3, v = Math.pow(10, -p), m = Wh[8 + p / 3];
    return function(y) {
      return f(v * y) + m;
    };
  }
  return {
    format: c,
    formatPrefix: u
  };
}
var ta, wu, km;
mE({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function mE(e) {
  return ta = pE(e), wu = ta.format, km = ta.formatPrefix, ta;
}
function gE(e) {
  return Math.max(0, -si(Math.abs(e)));
}
function vE(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(si(t) / 3))) * 3 - si(Math.abs(e)));
}
function yE(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, si(t) - si(e)) + 1;
}
var Rt = 1e-6, Dm = 1e-12, vt = Math.PI, xe = vt / 2, qh = vt / 4, $e = vt * 2, he = 180 / vt, Xt = vt / 180, kt = Math.abs, Im = Math.atan, xr = Math.atan2, Dt = Math.cos, xE = Math.exp, bE = Math.log, At = Math.sin, Yn = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, Ze = Math.sqrt, EE = Math.tan;
function _E(e) {
  return e > 1 ? 0 : e < -1 ? vt : Math.acos(e);
}
function Rn(e) {
  return e > 1 ? xe : e < -1 ? -xe : Math.asin(e);
}
function Pe() {
}
function Wa(e, t) {
  e && Xh.hasOwnProperty(e.type) && Xh[e.type](e, t);
}
var Yh = {
  Feature: function(e, t) {
    Wa(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, r = -1, i = n.length; ++r < i; )
      Wa(n[r].geometry, t);
  }
}, Xh = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      e = n[r], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    lc(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      lc(n[r], t, 0);
  },
  Polygon: function(e, t) {
    Zh(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      Zh(n[r], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, r = -1, i = n.length; ++r < i; )
      Wa(n[r], t);
  }
};
function lc(e, t, n) {
  var r = -1, i = e.length - n, s;
  for (t.lineStart(); ++r < i; )
    s = e[r], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function Zh(e, t) {
  var n = -1, r = e.length;
  for (t.polygonStart(); ++n < r; )
    lc(e[n], t, 1);
  t.polygonEnd();
}
function Hr(e, t) {
  e && Yh.hasOwnProperty(e.type) ? Yh[e.type](e, t) : Wa(e, t);
}
function cc(e) {
  return [xr(e[1], e[0]), Rn(e[2])];
}
function ai(e) {
  var t = e[0], n = e[1], r = Dt(n);
  return [r * Dt(t), r * At(t), At(n)];
}
function ea(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function qa(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function fl(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function na(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function uc(e) {
  var t = Ze(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
function hc(e, t) {
  function n(r, i) {
    return r = e(r, i), t(r[0], r[1]);
  }
  return e.invert && t.invert && (n.invert = function(r, i) {
    return r = t.invert(r, i), r && e.invert(r[0], r[1]);
  }), n;
}
function dc(e, t) {
  return kt(e) > vt && (e -= Math.round(e / $e) * $e), [e, t];
}
dc.invert = dc;
function Nm(e, t, n) {
  return (e %= $e) ? t || n ? hc(Qh(e), Jh(t, n)) : Qh(e) : t || n ? Jh(t, n) : dc;
}
function Kh(e) {
  return function(t, n) {
    return t += e, kt(t) > vt && (t -= Math.round(t / $e) * $e), [t, n];
  };
}
function Qh(e) {
  var t = Kh(e);
  return t.invert = Kh(-e), t;
}
function Jh(e, t) {
  var n = Dt(e), r = At(e), i = Dt(t), s = At(t);
  function a(o, l) {
    var c = Dt(l), u = Dt(o) * c, d = At(o) * c, h = At(l), f = h * n + u * r;
    return [
      xr(d * i - f * s, u * n - h * r),
      Rn(f * i + d * s)
    ];
  }
  return a.invert = function(o, l) {
    var c = Dt(l), u = Dt(o) * c, d = At(o) * c, h = At(l), f = h * i - d * s;
    return [
      xr(d * i + h * s, u * n + f * r),
      Rn(f * n - u * r)
    ];
  }, a;
}
function wE(e) {
  e = Nm(e[0] * Xt, e[1] * Xt, e.length > 2 ? e[2] * Xt : 0);
  function t(n) {
    return n = e(n[0] * Xt, n[1] * Xt), n[0] *= he, n[1] *= he, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Xt, n[1] * Xt), n[0] *= he, n[1] *= he, n;
  }, t;
}
function SE(e, t, n, r, i, s) {
  if (n) {
    var a = Dt(t), o = At(t), l = r * n;
    i == null ? (i = t + r * $e, s = t - l / 2) : (i = td(a, i), s = td(a, s), (r > 0 ? i < s : i > s) && (i += r * $e));
    for (var c, u = i; r > 0 ? u > s : u < s; u -= l)
      c = cc([a, -o * Dt(u), -o * At(u)]), e.point(c[0], c[1]);
  }
}
function td(e, t) {
  t = ai(t), t[0] -= e, uc(t);
  var n = _E(-t[1]);
  return ((-t[2] < 0 ? -n : n) + $e - Rt) % $e;
}
function Pm() {
  var e = [], t;
  return {
    point: function(n, r, i) {
      t.push([n, r, i]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Pe,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function Ta(e, t) {
  return kt(e[0] - t[0]) < Rt && kt(e[1] - t[1]) < Rt;
}
function ra(e, t, n, r) {
  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
}
function Um(e, t, n, r, i) {
  var s = [], a = [], o, l;
  if (e.forEach(function(p) {
    if (!((v = p.length - 1) <= 0)) {
      var v, m = p[0], y = p[v], g;
      if (Ta(m, y)) {
        if (!m[2] && !y[2]) {
          for (i.lineStart(), o = 0; o < v; ++o)
            i.point((m = p[o])[0], m[1]);
          i.lineEnd();
          return;
        }
        y[0] += 2 * Rt;
      }
      s.push(g = new ra(m, p, null, !0)), a.push(g.o = new ra(m, null, g, !1)), s.push(g = new ra(y, p, null, !1)), a.push(g.o = new ra(y, null, g, !0));
    }
  }), !!s.length) {
    for (a.sort(t), ed(s), ed(a), o = 0, l = a.length; o < l; ++o)
      a[o].e = n = !n;
    for (var c = s[0], u, d; ; ) {
      for (var h = c, f = !0; h.v; )
        if ((h = h.n) === c)
          return;
      u = h.z, i.lineStart();
      do {
        if (h.v = h.o.v = !0, h.e) {
          if (f)
            for (o = 0, l = u.length; o < l; ++o)
              i.point((d = u[o])[0], d[1]);
          else
            r(h.x, h.n.x, 1, i);
          h = h.n;
        } else {
          if (f)
            for (u = h.p.z, o = u.length - 1; o >= 0; --o)
              i.point((d = u[o])[0], d[1]);
          else
            r(h.x, h.p.x, -1, i);
          h = h.p;
        }
        h = h.o, u = h.z, f = !f;
      } while (!h.v);
      i.lineEnd();
    }
  }
}
function ed(e) {
  if (t = e.length) {
    for (var t, n = 0, r = e[0], i; ++n < t; )
      r.n = i = e[n], i.p = r, r = i;
    r.n = i = e[0], i.p = r;
  }
}
function pl(e) {
  return kt(e[0]) <= vt ? e[0] : Yn(e[0]) * ((kt(e[0]) + vt) % $e - vt);
}
function OE(e, t) {
  var n = pl(t), r = t[1], i = At(r), s = [At(n), -Dt(n), 0], a = 0, o = 0, l = new mr();
  i === 1 ? r = xe + Rt : i === -1 && (r = -xe - Rt);
  for (var c = 0, u = e.length; c < u; ++c)
    if (h = (d = e[c]).length)
      for (var d, h, f = d[h - 1], p = pl(f), v = f[1] / 2 + qh, m = At(v), y = Dt(v), g = 0; g < h; ++g, p = w, m = S, y = L, f = b) {
        var b = d[g], w = pl(b), _ = b[1] / 2 + qh, S = At(_), L = Dt(_), D = w - p, k = D >= 0 ? 1 : -1, R = k * D, M = R > vt, V = m * S;
        if (l.add(xr(V * k * At(R), y * L + V * Dt(R))), a += M ? D + k * $e : D, M ^ p >= n ^ w >= n) {
          var P = qa(ai(f), ai(b));
          uc(P);
          var H = qa(s, P);
          uc(H);
          var E = (M ^ D >= 0 ? -1 : 1) * Rn(H[2]);
          (r > E || r === E && (P[0] || P[1])) && (o += M ^ D >= 0 ? 1 : -1);
        }
      }
  return (a < -Rt || a < Rt && l < -Dm) ^ o & 1;
}
function Bm(e, t, n, r) {
  return function(i) {
    var s = t(i), a = Pm(), o = t(a), l = !1, c, u, d, h = {
      point: f,
      lineStart: v,
      lineEnd: m,
      polygonStart: function() {
        h.point = y, h.lineStart = g, h.lineEnd = b, u = [], c = [];
      },
      polygonEnd: function() {
        h.point = f, h.lineStart = v, h.lineEnd = m, u = tm(u);
        var w = OE(c, r);
        u.length ? (l || (i.polygonStart(), l = !0), Um(u, ME, w, n, i)) : w && (l || (i.polygonStart(), l = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), u = c = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function f(w, _) {
      e(w, _) && i.point(w, _);
    }
    function p(w, _) {
      s.point(w, _);
    }
    function v() {
      h.point = p, s.lineStart();
    }
    function m() {
      h.point = f, s.lineEnd();
    }
    function y(w, _) {
      d.push([w, _]), o.point(w, _);
    }
    function g() {
      o.lineStart(), d = [];
    }
    function b() {
      y(d[0][0], d[0][1]), o.lineEnd();
      var w = o.clean(), _ = a.result(), S, L = _.length, D, k, R;
      if (d.pop(), c.push(d), d = null, !!L) {
        if (w & 1) {
          if (k = _[0], (D = k.length - 1) > 0) {
            for (l || (i.polygonStart(), l = !0), i.lineStart(), S = 0; S < D; ++S)
              i.point((R = k[S])[0], R[1]);
            i.lineEnd();
          }
          return;
        }
        L > 1 && w & 2 && _.push(_.pop().concat(_.shift())), u.push(_.filter(TE));
      }
    }
    return h;
  };
}
function TE(e) {
  return e.length > 1;
}
function ME(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - xe - Rt : xe - e[1]) - ((t = t.x)[0] < 0 ? t[1] - xe - Rt : xe - t[1]);
}
const nd = Bm(
  function() {
    return !0;
  },
  CE,
  $E,
  [-vt, -xe]
);
function CE(e) {
  var t = NaN, n = NaN, r = NaN, i;
  return {
    lineStart: function() {
      e.lineStart(), i = 1;
    },
    point: function(s, a) {
      var o = s > 0 ? vt : -vt, l = kt(s - t);
      kt(l - vt) < Rt ? (e.point(t, n = (n + a) / 2 > 0 ? xe : -xe), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), i = 0) : r !== o && l >= vt && (kt(t - r) < Rt && (t -= r * Rt), kt(s - o) < Rt && (s -= o * Rt), n = AE(t, n, s, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), i = 0), e.point(t = s, n = a), r = o;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function AE(e, t, n, r) {
  var i, s, a = At(e - n);
  return kt(a) > Rt ? Im((At(t) * (s = Dt(r)) * At(n) - At(r) * (i = Dt(t)) * At(e)) / (i * s * a)) : (t + r) / 2;
}
function $E(e, t, n, r) {
  var i;
  if (e == null)
    i = n * xe, r.point(-vt, i), r.point(0, i), r.point(vt, i), r.point(vt, 0), r.point(vt, -i), r.point(0, -i), r.point(-vt, -i), r.point(-vt, 0), r.point(-vt, i);
  else if (kt(e[0] - t[0]) > Rt) {
    var s = e[0] < t[0] ? vt : -vt;
    i = n * s / 2, r.point(-s, i), r.point(0, i), r.point(s, i);
  } else
    r.point(t[0], t[1]);
}
function LE(e) {
  var t = Dt(e), n = 2 * Xt, r = t > 0, i = kt(t) > Rt;
  function s(u, d, h, f) {
    SE(f, e, n, h, u, d);
  }
  function a(u, d) {
    return Dt(u) * Dt(d) > t;
  }
  function o(u) {
    var d, h, f, p, v;
    return {
      lineStart: function() {
        p = f = !1, v = 1;
      },
      point: function(m, y) {
        var g = [m, y], b, w = a(m, y), _ = r ? w ? 0 : c(m, y) : w ? c(m + (m < 0 ? vt : -vt), y) : 0;
        if (!d && (p = f = w) && u.lineStart(), w !== f && (b = l(d, g), (!b || Ta(d, b) || Ta(g, b)) && (g[2] = 1)), w !== f)
          v = 0, w ? (u.lineStart(), b = l(g, d), u.point(b[0], b[1])) : (b = l(d, g), u.point(b[0], b[1], 2), u.lineEnd()), d = b;
        else if (i && d && r ^ w) {
          var S;
          !(_ & h) && (S = l(g, d, !0)) && (v = 0, r ? (u.lineStart(), u.point(S[0][0], S[0][1]), u.point(S[1][0], S[1][1]), u.lineEnd()) : (u.point(S[1][0], S[1][1]), u.lineEnd(), u.lineStart(), u.point(S[0][0], S[0][1], 3)));
        }
        w && (!d || !Ta(d, g)) && u.point(g[0], g[1]), d = g, f = w, h = _;
      },
      lineEnd: function() {
        f && u.lineEnd(), d = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return v | (p && f) << 1;
      }
    };
  }
  function l(u, d, h) {
    var f = ai(u), p = ai(d), v = [1, 0, 0], m = qa(f, p), y = ea(m, m), g = m[0], b = y - g * g;
    if (!b)
      return !h && u;
    var w = t * y / b, _ = -t * g / b, S = qa(v, m), L = na(v, w), D = na(m, _);
    fl(L, D);
    var k = S, R = ea(L, k), M = ea(k, k), V = R * R - M * (ea(L, L) - 1);
    if (!(V < 0)) {
      var P = Ze(V), H = na(k, (-R - P) / M);
      if (fl(H, L), H = cc(H), !h)
        return H;
      var E = u[0], A = d[0], $ = u[1], U = d[1], B;
      A < E && (B = E, E = A, A = B);
      var W = A - E, K = kt(W - vt) < Rt, Q = K || W < Rt;
      if (!K && U < $ && (B = $, $ = U, U = B), Q ? K ? $ + U > 0 ^ H[1] < (kt(H[0] - E) < Rt ? $ : U) : $ <= H[1] && H[1] <= U : W > vt ^ (E <= H[0] && H[0] <= A)) {
        var dt = na(k, (-R + P) / M);
        return fl(dt, L), [H, cc(dt)];
      }
    }
  }
  function c(u, d) {
    var h = r ? e : vt - e, f = 0;
    return u < -h ? f |= 1 : u > h && (f |= 2), d < -h ? f |= 4 : d > h && (f |= 8), f;
  }
  return Bm(a, o, s, r ? [0, -e] : [-vt, e - vt]);
}
function RE(e, t, n, r, i, s) {
  var a = e[0], o = e[1], l = t[0], c = t[1], u = 0, d = 1, h = l - a, f = c - o, p;
  if (p = n - a, !(!h && p > 0)) {
    if (p /= h, h < 0) {
      if (p < u)
        return;
      p < d && (d = p);
    } else if (h > 0) {
      if (p > d)
        return;
      p > u && (u = p);
    }
    if (p = i - a, !(!h && p < 0)) {
      if (p /= h, h < 0) {
        if (p > d)
          return;
        p > u && (u = p);
      } else if (h > 0) {
        if (p < u)
          return;
        p < d && (d = p);
      }
      if (p = r - o, !(!f && p > 0)) {
        if (p /= f, f < 0) {
          if (p < u)
            return;
          p < d && (d = p);
        } else if (f > 0) {
          if (p > d)
            return;
          p > u && (u = p);
        }
        if (p = s - o, !(!f && p < 0)) {
          if (p /= f, f < 0) {
            if (p > d)
              return;
            p > u && (u = p);
          } else if (f > 0) {
            if (p < u)
              return;
            p < d && (d = p);
          }
          return u > 0 && (e[0] = a + u * h, e[1] = o + u * f), d < 1 && (t[0] = a + d * h, t[1] = o + d * f), !0;
        }
      }
    }
  }
}
var Yi = 1e9, ia = -Yi;
function kE(e, t, n, r) {
  function i(c, u) {
    return e <= c && c <= n && t <= u && u <= r;
  }
  function s(c, u, d, h) {
    var f = 0, p = 0;
    if (c == null || (f = a(c, d)) !== (p = a(u, d)) || l(c, u) < 0 ^ d > 0)
      do
        h.point(f === 0 || f === 3 ? e : n, f > 1 ? r : t);
      while ((f = (f + d + 4) % 4) !== p);
    else
      h.point(u[0], u[1]);
  }
  function a(c, u) {
    return kt(c[0] - e) < Rt ? u > 0 ? 0 : 3 : kt(c[0] - n) < Rt ? u > 0 ? 2 : 1 : kt(c[1] - t) < Rt ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
  }
  function o(c, u) {
    return l(c.x, u.x);
  }
  function l(c, u) {
    var d = a(c, 1), h = a(u, 1);
    return d !== h ? d - h : d === 0 ? u[1] - c[1] : d === 1 ? c[0] - u[0] : d === 2 ? c[1] - u[1] : u[0] - c[0];
  }
  return function(c) {
    var u = c, d = Pm(), h, f, p, v, m, y, g, b, w, _, S, L = {
      point: D,
      lineStart: V,
      lineEnd: P,
      polygonStart: R,
      polygonEnd: M
    };
    function D(E, A) {
      i(E, A) && u.point(E, A);
    }
    function k() {
      for (var E = 0, A = 0, $ = f.length; A < $; ++A)
        for (var U = f[A], B = 1, W = U.length, K = U[0], Q, dt, it = K[0], pt = K[1]; B < W; ++B)
          Q = it, dt = pt, K = U[B], it = K[0], pt = K[1], dt <= r ? pt > r && (it - Q) * (r - dt) > (pt - dt) * (e - Q) && ++E : pt <= r && (it - Q) * (r - dt) < (pt - dt) * (e - Q) && --E;
      return E;
    }
    function R() {
      u = d, h = [], f = [], S = !0;
    }
    function M() {
      var E = k(), A = S && E, $ = (h = tm(h)).length;
      (A || $) && (c.polygonStart(), A && (c.lineStart(), s(null, null, 1, c), c.lineEnd()), $ && Um(h, o, E, s, c), c.polygonEnd()), u = c, h = f = p = null;
    }
    function V() {
      L.point = H, f && f.push(p = []), _ = !0, w = !1, g = b = NaN;
    }
    function P() {
      h && (H(v, m), y && w && d.rejoin(), h.push(d.result())), L.point = D, w && u.lineEnd();
    }
    function H(E, A) {
      var $ = i(E, A);
      if (f && p.push([E, A]), _)
        v = E, m = A, y = $, _ = !1, $ && (u.lineStart(), u.point(E, A));
      else if ($ && w)
        u.point(E, A);
      else {
        var U = [g = Math.max(ia, Math.min(Yi, g)), b = Math.max(ia, Math.min(Yi, b))], B = [E = Math.max(ia, Math.min(Yi, E)), A = Math.max(ia, Math.min(Yi, A))];
        RE(U, B, e, t, n, r) ? (w || (u.lineStart(), u.point(U[0], U[1])), u.point(B[0], B[1]), $ || u.lineEnd(), S = !1) : $ && (u.lineStart(), u.point(E, A), S = !1);
      }
      g = E, b = A, w = $;
    }
    return L;
  };
}
const fc = (e) => e;
var ml = new mr(), pc = new mr(), Hm, Vm, mc, gc, Sn = {
  point: Pe,
  lineStart: Pe,
  lineEnd: Pe,
  polygonStart: function() {
    Sn.lineStart = DE, Sn.lineEnd = NE;
  },
  polygonEnd: function() {
    Sn.lineStart = Sn.lineEnd = Sn.point = Pe, ml.add(kt(pc)), pc = new mr();
  },
  result: function() {
    var e = ml / 2;
    return ml = new mr(), e;
  }
};
function DE() {
  Sn.point = IE;
}
function IE(e, t) {
  Sn.point = Fm, Hm = mc = e, Vm = gc = t;
}
function Fm(e, t) {
  pc.add(gc * e - mc * t), mc = e, gc = t;
}
function NE() {
  Fm(Hm, Vm);
}
var oi = 1 / 0, Ya = oi, xs = -oi, Xa = xs, Za = {
  point: PE,
  lineStart: Pe,
  lineEnd: Pe,
  polygonStart: Pe,
  polygonEnd: Pe,
  result: function() {
    var e = [[oi, Ya], [xs, Xa]];
    return xs = Xa = -(Ya = oi = 1 / 0), e;
  }
};
function PE(e, t) {
  e < oi && (oi = e), e > xs && (xs = e), t < Ya && (Ya = t), t > Xa && (Xa = t);
}
var vc = 0, yc = 0, Xi = 0, Ka = 0, Qa = 0, Wr = 0, xc = 0, bc = 0, Zi = 0, zm, Gm, on, ln, Ne = {
  point: br,
  lineStart: rd,
  lineEnd: id,
  polygonStart: function() {
    Ne.lineStart = HE, Ne.lineEnd = VE;
  },
  polygonEnd: function() {
    Ne.point = br, Ne.lineStart = rd, Ne.lineEnd = id;
  },
  result: function() {
    var e = Zi ? [xc / Zi, bc / Zi] : Wr ? [Ka / Wr, Qa / Wr] : Xi ? [vc / Xi, yc / Xi] : [NaN, NaN];
    return vc = yc = Xi = Ka = Qa = Wr = xc = bc = Zi = 0, e;
  }
};
function br(e, t) {
  vc += e, yc += t, ++Xi;
}
function rd() {
  Ne.point = UE;
}
function UE(e, t) {
  Ne.point = BE, br(on = e, ln = t);
}
function BE(e, t) {
  var n = e - on, r = t - ln, i = Ze(n * n + r * r);
  Ka += i * (on + e) / 2, Qa += i * (ln + t) / 2, Wr += i, br(on = e, ln = t);
}
function id() {
  Ne.point = br;
}
function HE() {
  Ne.point = FE;
}
function VE() {
  jm(zm, Gm);
}
function FE(e, t) {
  Ne.point = jm, br(zm = on = e, Gm = ln = t);
}
function jm(e, t) {
  var n = e - on, r = t - ln, i = Ze(n * n + r * r);
  Ka += i * (on + e) / 2, Qa += i * (ln + t) / 2, Wr += i, i = ln * e - on * t, xc += i * (on + e), bc += i * (ln + t), Zi += i * 3, br(on = e, ln = t);
}
function Wm(e) {
  this._context = e;
}
Wm.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, $e);
        break;
      }
    }
  },
  result: Pe
};
var Ec = new mr(), gl, qm, Ym, Ki, Qi, bs = {
  point: Pe,
  lineStart: function() {
    bs.point = zE;
  },
  lineEnd: function() {
    gl && Xm(qm, Ym), bs.point = Pe;
  },
  polygonStart: function() {
    gl = !0;
  },
  polygonEnd: function() {
    gl = null;
  },
  result: function() {
    var e = +Ec;
    return Ec = new mr(), e;
  }
};
function zE(e, t) {
  bs.point = Xm, qm = Ki = e, Ym = Qi = t;
}
function Xm(e, t) {
  Ki -= e, Qi -= t, Ec.add(Ze(Ki * Ki + Qi * Qi)), Ki = e, Qi = t;
}
let sd, Ja, ad, od;
class ld {
  constructor(t) {
    this._append = t == null ? Zm : GE(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== ad || this._append !== Ja) {
          const r = this._radius, i = this._;
          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, ad = r, Ja = this._append, od = this._, this._ = i;
        }
        this._ += od;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function Zm(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function GE(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return Zm;
  if (t !== sd) {
    const n = 10 ** t;
    sd = t, Ja = function(i) {
      let s = 1;
      this._ += i[0];
      for (const a = i.length; s < a; ++s)
        this._ += Math.round(arguments[s] * n) / n + i[s];
    };
  }
  return Ja;
}
function jE(e, t) {
  let n = 3, r = 4.5, i, s;
  function a(o) {
    return o && (typeof r == "function" && s.pointRadius(+r.apply(this, arguments)), Hr(o, i(s))), s.result();
  }
  return a.area = function(o) {
    return Hr(o, i(Sn)), Sn.result();
  }, a.measure = function(o) {
    return Hr(o, i(bs)), bs.result();
  }, a.bounds = function(o) {
    return Hr(o, i(Za)), Za.result();
  }, a.centroid = function(o) {
    return Hr(o, i(Ne)), Ne.result();
  }, a.projection = function(o) {
    return arguments.length ? (i = o == null ? (e = null, fc) : (e = o).stream, a) : e;
  }, a.context = function(o) {
    return arguments.length ? (s = o == null ? (t = null, new ld(n)) : new Wm(t = o), typeof r != "function" && s.pointRadius(r), a) : t;
  }, a.pointRadius = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : r;
  }, a.digits = function(o) {
    if (!arguments.length)
      return n;
    if (o == null)
      n = null;
    else {
      const l = Math.floor(o);
      if (!(l >= 0))
        throw new RangeError(`invalid digits: ${o}`);
      n = l;
    }
    return t === null && (s = new ld(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function Su(e) {
  return function(t) {
    var n = new _c();
    for (var r in e)
      n[r] = e[r];
    return n.stream = t, n;
  };
}
function _c() {
}
_c.prototype = {
  constructor: _c,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function Ou(e, t, n) {
  var r = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), Hr(n, e.stream(Za)), t(Za.result()), r != null && e.clipExtent(r), e;
}
function Km(e, t, n) {
  return Ou(e, function(r) {
    var i = t[1][0] - t[0][0], s = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), s / (r[1][1] - r[0][1])), o = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, l = +t[0][1] + (s - a * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * a).translate([o, l]);
  }, n);
}
function WE(e, t, n) {
  return Km(e, [[0, 0], t], n);
}
function qE(e, t, n) {
  return Ou(e, function(r) {
    var i = +t, s = i / (r[1][0] - r[0][0]), a = (i - s * (r[1][0] + r[0][0])) / 2, o = -s * r[0][1];
    e.scale(150 * s).translate([a, o]);
  }, n);
}
function YE(e, t, n) {
  return Ou(e, function(r) {
    var i = +t, s = i / (r[1][1] - r[0][1]), a = -s * r[0][0], o = (i - s * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * s).translate([a, o]);
  }, n);
}
var cd = 16, XE = Dt(30 * Xt);
function ud(e, t) {
  return +t ? KE(e, t) : ZE(e);
}
function ZE(e) {
  return Su({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function KE(e, t) {
  function n(r, i, s, a, o, l, c, u, d, h, f, p, v, m) {
    var y = c - r, g = u - i, b = y * y + g * g;
    if (b > 4 * t && v--) {
      var w = a + h, _ = o + f, S = l + p, L = Ze(w * w + _ * _ + S * S), D = Rn(S /= L), k = kt(kt(S) - 1) < Rt || kt(s - d) < Rt ? (s + d) / 2 : xr(_, w), R = e(k, D), M = R[0], V = R[1], P = M - r, H = V - i, E = g * P - y * H;
      (E * E / b > t || kt((y * P + g * H) / b - 0.5) > 0.3 || a * h + o * f + l * p < XE) && (n(r, i, s, a, o, l, M, V, k, w /= L, _ /= L, S, v, m), m.point(M, V), n(M, V, k, w, _, S, c, u, d, h, f, p, v, m));
    }
  }
  return function(r) {
    var i, s, a, o, l, c, u, d, h, f, p, v, m = {
      point: y,
      lineStart: g,
      lineEnd: w,
      polygonStart: function() {
        r.polygonStart(), m.lineStart = _;
      },
      polygonEnd: function() {
        r.polygonEnd(), m.lineStart = g;
      }
    };
    function y(D, k) {
      D = e(D, k), r.point(D[0], D[1]);
    }
    function g() {
      d = NaN, m.point = b, r.lineStart();
    }
    function b(D, k) {
      var R = ai([D, k]), M = e(D, k);
      n(d, h, u, f, p, v, d = M[0], h = M[1], u = D, f = R[0], p = R[1], v = R[2], cd, r), r.point(d, h);
    }
    function w() {
      m.point = y, r.lineEnd();
    }
    function _() {
      g(), m.point = S, m.lineEnd = L;
    }
    function S(D, k) {
      b(i = D, k), s = d, a = h, o = f, l = p, c = v, m.point = b;
    }
    function L() {
      n(d, h, u, f, p, v, s, a, i, o, l, c, cd, r), m.lineEnd = w, w();
    }
    return m;
  };
}
var QE = Su({
  point: function(e, t) {
    this.stream.point(e * Xt, t * Xt);
  }
});
function JE(e) {
  return Su({
    point: function(t, n) {
      var r = e(t, n);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function t_(e, t, n, r, i) {
  function s(a, o) {
    return a *= r, o *= i, [t + e * a, n - e * o];
  }
  return s.invert = function(a, o) {
    return [(a - t) / e * r, (n - o) / e * i];
  }, s;
}
function hd(e, t, n, r, i, s) {
  if (!s)
    return t_(e, t, n, r, i);
  var a = Dt(s), o = At(s), l = a * e, c = o * e, u = a / e, d = o / e, h = (o * n - a * t) / e, f = (o * t + a * n) / e;
  function p(v, m) {
    return v *= r, m *= i, [l * v - c * m + t, n - c * v - l * m];
  }
  return p.invert = function(v, m) {
    return [r * (u * v - d * m + h), i * (f - d * v - u * m)];
  }, p;
}
function Ao(e) {
  return Qm(function() {
    return e;
  })();
}
function Qm(e) {
  var t, n = 150, r = 480, i = 250, s = 0, a = 0, o = 0, l = 0, c = 0, u, d = 0, h = 1, f = 1, p = null, v = nd, m = null, y, g, b, w = fc, _ = 0.5, S, L, D, k, R;
  function M(E) {
    return D(E[0] * Xt, E[1] * Xt);
  }
  function V(E) {
    return E = D.invert(E[0], E[1]), E && [E[0] * he, E[1] * he];
  }
  M.stream = function(E) {
    return k && R === E ? k : k = QE(JE(u)(v(S(w(R = E)))));
  }, M.preclip = function(E) {
    return arguments.length ? (v = E, p = void 0, H()) : v;
  }, M.postclip = function(E) {
    return arguments.length ? (w = E, m = y = g = b = null, H()) : w;
  }, M.clipAngle = function(E) {
    return arguments.length ? (v = +E ? LE(p = E * Xt) : (p = null, nd), H()) : p * he;
  }, M.clipExtent = function(E) {
    return arguments.length ? (w = E == null ? (m = y = g = b = null, fc) : kE(m = +E[0][0], y = +E[0][1], g = +E[1][0], b = +E[1][1]), H()) : m == null ? null : [[m, y], [g, b]];
  }, M.scale = function(E) {
    return arguments.length ? (n = +E, P()) : n;
  }, M.translate = function(E) {
    return arguments.length ? (r = +E[0], i = +E[1], P()) : [r, i];
  }, M.center = function(E) {
    return arguments.length ? (s = E[0] % 360 * Xt, a = E[1] % 360 * Xt, P()) : [s * he, a * he];
  }, M.rotate = function(E) {
    return arguments.length ? (o = E[0] % 360 * Xt, l = E[1] % 360 * Xt, c = E.length > 2 ? E[2] % 360 * Xt : 0, P()) : [o * he, l * he, c * he];
  }, M.angle = function(E) {
    return arguments.length ? (d = E % 360 * Xt, P()) : d * he;
  }, M.reflectX = function(E) {
    return arguments.length ? (h = E ? -1 : 1, P()) : h < 0;
  }, M.reflectY = function(E) {
    return arguments.length ? (f = E ? -1 : 1, P()) : f < 0;
  }, M.precision = function(E) {
    return arguments.length ? (S = ud(L, _ = E * E), H()) : Ze(_);
  }, M.fitExtent = function(E, A) {
    return Km(M, E, A);
  }, M.fitSize = function(E, A) {
    return WE(M, E, A);
  }, M.fitWidth = function(E, A) {
    return qE(M, E, A);
  }, M.fitHeight = function(E, A) {
    return YE(M, E, A);
  };
  function P() {
    var E = hd(n, 0, 0, h, f, d).apply(null, t(s, a)), A = hd(n, r - E[0], i - E[1], h, f, d);
    return u = Nm(o, l, c), L = hc(t, A), D = hc(u, L), S = ud(L, _), H();
  }
  function H() {
    return k = R = null, M;
  }
  return function() {
    return t = e.apply(this, arguments), M.invert = t.invert && V, P();
  };
}
function Jm(e) {
  var t = 0, n = vt / 3, r = Qm(e), i = r(t, n);
  return i.parallels = function(s) {
    return arguments.length ? r(t = s[0] * Xt, n = s[1] * Xt) : [t * he, n * he];
  }, i;
}
function e_(e) {
  var t = Dt(e);
  function n(r, i) {
    return [r * t, At(i) / t];
  }
  return n.invert = function(r, i) {
    return [r / t, Rn(i * t)];
  }, n;
}
function n_(e, t) {
  var n = At(e), r = (n + At(t)) / 2;
  if (kt(r) < Rt)
    return e_(e);
  var i = 1 + n * (2 * r - n), s = Ze(i) / r;
  function a(o, l) {
    var c = Ze(i - 2 * r * At(l)) / r;
    return [c * At(o *= r), s - c * Dt(o)];
  }
  return a.invert = function(o, l) {
    var c = s - l, u = xr(o, kt(c)) * Yn(c);
    return c * r < 0 && (u -= vt * Yn(o) * Yn(c)), [u / r, Rn((i - (o * o + c * c) * r * r) / (2 * r))];
  }, a;
}
function tg() {
  return Jm(n_).scale(155.424).center([0, 33.6442]);
}
function r_() {
  return tg().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function Tu(e, t) {
  return [e, bE(EE((xe + t) / 2))];
}
Tu.invert = function(e, t) {
  return [e, 2 * Im(xE(t)) - xe];
};
function i_() {
  return s_(Tu).scale(961 / $e);
}
function s_(e) {
  var t = Ao(e), n = t.center, r = t.scale, i = t.translate, s = t.clipExtent, a = null, o, l, c;
  t.scale = function(d) {
    return arguments.length ? (r(d), u()) : r();
  }, t.translate = function(d) {
    return arguments.length ? (i(d), u()) : i();
  }, t.center = function(d) {
    return arguments.length ? (n(d), u()) : n();
  }, t.clipExtent = function(d) {
    return arguments.length ? (d == null ? a = o = l = c = null : (a = +d[0][0], o = +d[0][1], l = +d[1][0], c = +d[1][1]), u()) : a == null ? null : [[a, o], [l, c]];
  };
  function u() {
    var d = vt * r(), h = t(wE(t.rotate()).invert([0, 0]));
    return s(a == null ? [[h[0] - d, h[1] - d], [h[0] + d, h[1] + d]] : e === Tu ? [[Math.max(h[0] - d, a), o], [Math.min(h[0] + d, l), c]] : [[a, Math.max(h[1] - d, o)], [l, Math.min(h[1] + d, c)]]);
  }
  return u();
}
function to(e, t) {
  return [e, t];
}
to.invert = to;
function a_() {
  return Ao(to).scale(152.63);
}
function o_(e, t) {
  var n = Dt(e), r = e === t ? At(e) : (n - Dt(t)) / (t - e), i = n / r + e;
  if (kt(r) < Rt)
    return to;
  function s(a, o) {
    var l = i - o, c = r * a;
    return [l * At(c), i - l * Dt(c)];
  }
  return s.invert = function(a, o) {
    var l = i - o, c = xr(a, kt(l)) * Yn(l);
    return l * r < 0 && (c -= vt * Yn(a) * Yn(l)), [c / r, i - Yn(r) * Ze(a * a + l * l)];
  }, s;
}
function l_() {
  return Jm(o_).scale(131.154).center([0, 13.9389]);
}
var os = 1.340264, ls = -0.081106, cs = 893e-6, us = 3796e-6, eo = Ze(3) / 2, c_ = 12;
function eg(e, t) {
  var n = Rn(eo * At(t)), r = n * n, i = r * r * r;
  return [
    e * Dt(n) / (eo * (os + 3 * ls * r + i * (7 * cs + 9 * us * r))),
    n * (os + ls * r + i * (cs + us * r))
  ];
}
eg.invert = function(e, t) {
  for (var n = t, r = n * n, i = r * r * r, s = 0, a, o, l; s < c_ && (o = n * (os + ls * r + i * (cs + us * r)) - t, l = os + 3 * ls * r + i * (7 * cs + 9 * us * r), n -= a = o / l, r = n * n, i = r * r * r, !(kt(a) < Dm)); ++s)
    ;
  return [
    eo * e * (os + 3 * ls * r + i * (7 * cs + 9 * us * r)) / Dt(n),
    Rn(At(n) / eo)
  ];
};
function u_() {
  return Ao(eg).scale(177.158);
}
function ng(e, t) {
  var n = t * t, r = n * n;
  return [
    e * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (3971e-6 * n - 1529e-6 * r))),
    t * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 5916e-6 * r)))
  ];
}
ng.invert = function(e, t) {
  var n = t, r = 25, i;
  do {
    var s = n * n, a = s * s;
    n -= i = (n * (1.007226 + s * (0.015085 + a * (-0.044475 + 0.028874 * s - 5916e-6 * a))) - t) / (1.007226 + s * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * a)));
  } while (kt(i) > Rt && --r > 0);
  return [
    e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),
    n
  ];
};
function h_() {
  return Ao(ng).scale(175.295);
}
function d_(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function f_(e) {
  return e.reduce(p_, 0) / e.length;
}
function p_(e, t) {
  return e + t.x;
}
function m_(e) {
  return 1 + e.reduce(g_, 0);
}
function g_(e, t) {
  return Math.max(e, t.y);
}
function v_(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function y_(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function x_() {
  var e = d_, t = 1, n = 1, r = !1;
  function i(s) {
    var a, o = 0;
    s.eachAfter(function(h) {
      var f = h.children;
      f ? (h.x = f_(f), h.y = m_(f)) : (h.x = a ? o += e(h, a) : 0, h.y = 0, a = h);
    });
    var l = v_(s), c = y_(s), u = l.x - e(l, c) / 2, d = c.x + e(c, l) / 2;
    return s.eachAfter(r ? function(h) {
      h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n;
    } : function(h) {
      h.x = (h.x - u) / (d - u) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;
    });
  }
  return i.separation = function(s) {
    return arguments.length ? (e = s, i) : e;
  }, i.size = function(s) {
    return arguments.length ? (r = !1, t = +s[0], n = +s[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(s) {
    return arguments.length ? (r = !0, t = +s[0], n = +s[1], i) : r ? [t, n] : null;
  }, i;
}
function b_(e) {
  var t = 0, n = e.children, r = n && n.length;
  if (!r)
    t = 1;
  else
    for (; --r >= 0; )
      t += n[r].value;
  e.value = t;
}
function E_() {
  return this.eachAfter(b_);
}
function __(e, t) {
  let n = -1;
  for (const r of this)
    e.call(t, r, ++n, this);
  return this;
}
function w_(e, t) {
  for (var n = this, r = [n], i, s, a = -1; n = r.pop(); )
    if (e.call(t, n, ++a, this), i = n.children)
      for (s = i.length - 1; s >= 0; --s)
        r.push(i[s]);
  return this;
}
function S_(e, t) {
  for (var n = this, r = [n], i = [], s, a, o, l = -1; n = r.pop(); )
    if (i.push(n), s = n.children)
      for (a = 0, o = s.length; a < o; ++a)
        r.push(s[a]);
  for (; n = i.pop(); )
    e.call(t, n, ++l, this);
  return this;
}
function O_(e, t) {
  let n = -1;
  for (const r of this)
    if (e.call(t, r, ++n, this))
      return r;
}
function T_(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; )
      n += r[i].value;
    t.value = n;
  });
}
function M_(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function C_(e) {
  for (var t = this, n = A_(t, e), r = [t]; t !== n; )
    t = t.parent, r.push(t);
  for (var i = r.length; e !== n; )
    r.splice(i, 0, e), e = e.parent;
  return r;
}
function A_(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), r = t.ancestors(), i = null;
  for (e = n.pop(), t = r.pop(); e === t; )
    i = e, e = n.pop(), t = r.pop();
  return i;
}
function $_() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function L_() {
  return Array.from(this);
}
function R_() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function k_() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* D_() {
  var e = this, t, n = [e], r, i, s;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, r = e.children)
        for (i = 0, s = r.length; i < s; ++i)
          n.push(r[i]);
  while (n.length);
}
function ks(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = P_)) : t === void 0 && (t = N_);
  for (var n = new Es(e), r, i = [n], s, a, o, l; r = i.pop(); )
    if ((a = t(r.data)) && (l = (a = Array.from(a)).length))
      for (r.children = a, o = l - 1; o >= 0; --o)
        i.push(s = a[o] = new Es(a[o])), s.parent = r, s.depth = r.depth + 1;
  return n.eachBefore(B_);
}
function I_() {
  return ks(this).eachBefore(U_);
}
function N_(e) {
  return e.children;
}
function P_(e) {
  return Array.isArray(e) ? e[1] : null;
}
function U_(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function B_(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function Es(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
Es.prototype = ks.prototype = {
  constructor: Es,
  count: E_,
  each: __,
  eachAfter: S_,
  eachBefore: w_,
  find: O_,
  sum: T_,
  sort: M_,
  path: C_,
  ancestors: $_,
  descendants: L_,
  leaves: R_,
  links: k_,
  copy: I_,
  [Symbol.iterator]: D_
};
function H_(e) {
  return e == null ? null : rg(e);
}
function rg(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function hr() {
  return 0;
}
function Vr(e) {
  return function() {
    return e;
  };
}
const V_ = 1664525, F_ = 1013904223, dd = 4294967296;
function z_() {
  let e = 1;
  return () => (e = (V_ * e + F_) % dd) / dd;
}
function G_(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function j_(e, t) {
  let n = e.length, r, i;
  for (; n; )
    i = t() * n-- | 0, r = e[n], e[n] = e[i], e[i] = r;
  return e;
}
function W_(e, t) {
  for (var n = 0, r = (e = j_(Array.from(e), t)).length, i = [], s, a; n < r; )
    s = e[n], a && ig(a, s) ? ++n : (a = Y_(i = q_(i, s)), n = 0);
  return a;
}
function q_(e, t) {
  var n, r;
  if (vl(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (sa(t, e[n]) && vl(Ji(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (r = n + 1; r < e.length; ++r)
      if (sa(Ji(e[n], e[r]), t) && sa(Ji(e[n], t), e[r]) && sa(Ji(e[r], t), e[n]) && vl(sg(e[n], e[r], t), e))
        return [e[n], e[r], t];
  throw new Error();
}
function sa(e, t) {
  var n = e.r - t.r, r = t.x - e.x, i = t.y - e.y;
  return n < 0 || n * n < r * r + i * i;
}
function ig(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function vl(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!ig(e, t[n]))
      return !1;
  return !0;
}
function Y_(e) {
  switch (e.length) {
    case 1:
      return X_(e[0]);
    case 2:
      return Ji(e[0], e[1]);
    case 3:
      return sg(e[0], e[1], e[2]);
  }
}
function X_(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function Ji(e, t) {
  var n = e.x, r = e.y, i = e.r, s = t.x, a = t.y, o = t.r, l = s - n, c = a - r, u = o - i, d = Math.sqrt(l * l + c * c);
  return {
    x: (n + s + l / d * u) / 2,
    y: (r + a + c / d * u) / 2,
    r: (d + i + o) / 2
  };
}
function sg(e, t, n) {
  var r = e.x, i = e.y, s = e.r, a = t.x, o = t.y, l = t.r, c = n.x, u = n.y, d = n.r, h = r - a, f = r - c, p = i - o, v = i - u, m = l - s, y = d - s, g = r * r + i * i - s * s, b = g - a * a - o * o + l * l, w = g - c * c - u * u + d * d, _ = f * p - h * v, S = (p * w - v * b) / (_ * 2) - r, L = (v * m - p * y) / _, D = (f * b - h * w) / (_ * 2) - i, k = (h * y - f * m) / _, R = L * L + k * k - 1, M = 2 * (s + S * L + D * k), V = S * S + D * D - s * s, P = -(Math.abs(R) > 1e-6 ? (M + Math.sqrt(M * M - 4 * R * V)) / (2 * R) : V / M);
  return {
    x: r + S + L * P,
    y: i + D + k * P,
    r: P
  };
}
function fd(e, t, n) {
  var r = e.x - t.x, i, s, a = e.y - t.y, o, l, c = r * r + a * a;
  c ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (i = (c + l - s) / (2 * c), o = Math.sqrt(Math.max(0, l / c - i * i)), n.x = e.x - i * r - o * a, n.y = e.y - i * a + o * r) : (i = (c + s - l) / (2 * c), o = Math.sqrt(Math.max(0, s / c - i * i)), n.x = t.x + i * r - o * a, n.y = t.y + i * a + o * r)) : (n.x = t.x + n.r, n.y = t.y);
}
function pd(e, t) {
  var n = e.r + t.r - 1e-6, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function md(e) {
  var t = e._, n = e.next._, r = t.r + n.r, i = (t.x * n.r + n.x * t.r) / r, s = (t.y * n.r + n.y * t.r) / r;
  return i * i + s * s;
}
function aa(e) {
  this._ = e, this.next = null, this.previous = null;
}
function Z_(e, t) {
  if (!(s = (e = G_(e)).length))
    return 0;
  var n, r, i, s, a, o, l, c, u, d, h;
  if (n = e[0], n.x = 0, n.y = 0, !(s > 1))
    return n.r;
  if (r = e[1], n.x = -r.r, r.x = n.r, r.y = 0, !(s > 2))
    return n.r + r.r;
  fd(r, n, i = e[2]), n = new aa(n), r = new aa(r), i = new aa(i), n.next = i.previous = r, r.next = n.previous = i, i.next = r.previous = n;
  t:
    for (l = 3; l < s; ++l) {
      fd(n._, r._, i = e[l]), i = new aa(i), c = r.next, u = n.previous, d = r._.r, h = n._.r;
      do
        if (d <= h) {
          if (pd(c._, i._)) {
            r = c, n.next = r, r.previous = n, --l;
            continue t;
          }
          d += c._.r, c = c.next;
        } else {
          if (pd(u._, i._)) {
            n = u, n.next = r, r.previous = n, --l;
            continue t;
          }
          h += u._.r, u = u.previous;
        }
      while (c !== u.next);
      for (i.previous = n, i.next = r, n.next = r.previous = r = i, a = md(n); (i = i.next) !== r; )
        (o = md(i)) < a && (n = i, a = o);
      r = n.next;
    }
  for (n = [r._], i = r; (i = i.next) !== r; )
    n.push(i._);
  for (i = W_(n, t), l = 0; l < s; ++l)
    n = e[l], n.x -= i.x, n.y -= i.y;
  return i.r;
}
function K_(e) {
  return Math.sqrt(e.value);
}
function Q_() {
  var e = null, t = 1, n = 1, r = hr;
  function i(s) {
    const a = z_();
    return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(gd(e)).eachAfter(yl(r, 0.5, a)).eachBefore(vd(1)) : s.eachBefore(gd(K_)).eachAfter(yl(hr, 1, a)).eachAfter(yl(r, s.r / Math.min(t, n), a)).eachBefore(vd(Math.min(t, n) / (2 * s.r))), s;
  }
  return i.radius = function(s) {
    return arguments.length ? (e = H_(s), i) : e;
  }, i.size = function(s) {
    return arguments.length ? (t = +s[0], n = +s[1], i) : [t, n];
  }, i.padding = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : Vr(+s), i) : r;
  }, i;
}
function gd(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function yl(e, t, n) {
  return function(r) {
    if (i = r.children) {
      var i, s, a = i.length, o = e(r) * t || 0, l;
      if (o)
        for (s = 0; s < a; ++s)
          i[s].r += o;
      if (l = Z_(i, n), o)
        for (s = 0; s < a; ++s)
          i[s].r -= o;
      r.r = l + o;
    }
  };
}
function vd(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function J_(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function tw(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (r - t) / e.value; ++o < l; )
    a = s[o], a.y0 = n, a.y1 = i, a.x0 = t, a.x1 = t += a.value * c;
}
function ew(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function xl(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function bl(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function nw(e, t, n) {
  var r = n / (t.i - e.i);
  t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;
}
function rw(e) {
  for (var t = 0, n = 0, r = e.children, i = r.length, s; --i >= 0; )
    s = r[i], s.z += t, s.m += t, t += s.s + (n += s.c);
}
function iw(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function Ma(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
Ma.prototype = Object.create(Es.prototype);
function sw(e) {
  for (var t = new Ma(e, 0), n, r = [t], i, s, a, o; n = r.pop(); )
    if (s = n._.children)
      for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a)
        r.push(i = n.children[a] = new Ma(s[a], a)), i.parent = n;
  return (t.parent = new Ma(null, 0)).children = [t], t;
}
function aw() {
  var e = ew, t = 1, n = 1, r = null;
  function i(c) {
    var u = sw(c);
    if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(a), r)
      c.eachBefore(l);
    else {
      var d = c, h = c, f = c;
      c.eachBefore(function(g) {
        g.x < d.x && (d = g), g.x > h.x && (h = g), g.depth > f.depth && (f = g);
      });
      var p = d === h ? 1 : e(d, h) / 2, v = p - d.x, m = t / (h.x + p + v), y = n / (f.depth || 1);
      c.eachBefore(function(g) {
        g.x = (g.x + v) * m, g.y = g.depth * y;
      });
    }
    return c;
  }
  function s(c) {
    var u = c.children, d = c.parent.children, h = c.i ? d[c.i - 1] : null;
    if (u) {
      rw(c);
      var f = (u[0].z + u[u.length - 1].z) / 2;
      h ? (c.z = h.z + e(c._, h._), c.m = c.z - f) : c.z = f;
    } else
      h && (c.z = h.z + e(c._, h._));
    c.parent.A = o(c, h, c.parent.A || d[0]);
  }
  function a(c) {
    c._.x = c.z + c.parent.m, c.m += c.parent.m;
  }
  function o(c, u, d) {
    if (u) {
      for (var h = c, f = c, p = u, v = h.parent.children[0], m = h.m, y = f.m, g = p.m, b = v.m, w; p = bl(p), h = xl(h), p && h; )
        v = xl(v), f = bl(f), f.a = c, w = p.z + g - h.z - m + e(p._, h._), w > 0 && (nw(iw(p, c, d), c, w), m += w, y += w), g += p.m, m += h.m, b += v.m, y += f.m;
      p && !bl(f) && (f.t = p, f.m += g - y), h && !xl(v) && (v.t = h, v.m += m - b, d = c);
    }
    return d;
  }
  function l(c) {
    c.x *= t, c.y = c.depth * n;
  }
  return i.separation = function(c) {
    return arguments.length ? (e = c, i) : e;
  }, i.size = function(c) {
    return arguments.length ? (r = !1, t = +c[0], n = +c[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(c) {
    return arguments.length ? (r = !0, t = +c[0], n = +c[1], i) : r ? [t, n] : null;
  }, i;
}
function ow(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (i - n) / e.value; ++o < l; )
    a = s[o], a.x0 = t, a.x1 = r, a.y0 = n, a.y1 = n += a.value * c;
}
var lw = (1 + Math.sqrt(5)) / 2;
function cw(e, t, n, r, i, s) {
  for (var a = [], o = t.children, l, c, u = 0, d = 0, h = o.length, f, p, v = t.value, m, y, g, b, w, _, S; u < h; ) {
    f = i - n, p = s - r;
    do
      m = o[d++].value;
    while (!m && d < h);
    for (y = g = m, _ = Math.max(p / f, f / p) / (v * e), S = m * m * _, w = Math.max(g / S, S / y); d < h; ++d) {
      if (m += c = o[d].value, c < y && (y = c), c > g && (g = c), S = m * m * _, b = Math.max(g / S, S / y), b > w) {
        m -= c;
        break;
      }
      w = b;
    }
    a.push(l = { value: m, dice: f < p, children: o.slice(u, d) }), l.dice ? tw(l, n, r, i, v ? r += p * m / v : s) : ow(l, n, r, v ? n += f * m / v : i, s), v -= m, u = d;
  }
  return a;
}
const uw = function e(t) {
  function n(r, i, s, a, o) {
    cw(t, r, i, s, a, o);
  }
  return n.ratio = function(r) {
    return e((r = +r) > 1 ? r : 1);
  }, n;
}(lw);
function hw() {
  var e = uw, t = !1, n = 1, r = 1, i = [0], s = hr, a = hr, o = hr, l = hr, c = hr;
  function u(h) {
    return h.x0 = h.y0 = 0, h.x1 = n, h.y1 = r, h.eachBefore(d), i = [0], t && h.eachBefore(J_), h;
  }
  function d(h) {
    var f = i[h.depth], p = h.x0 + f, v = h.y0 + f, m = h.x1 - f, y = h.y1 - f;
    m < p && (p = m = (p + m) / 2), y < v && (v = y = (v + y) / 2), h.x0 = p, h.y0 = v, h.x1 = m, h.y1 = y, h.children && (f = i[h.depth + 1] = s(h) / 2, p += c(h) - f, v += a(h) - f, m -= o(h) - f, y -= l(h) - f, m < p && (p = m = (p + m) / 2), y < v && (v = y = (v + y) / 2), e(h, p, v, m, y));
  }
  return u.round = function(h) {
    return arguments.length ? (t = !!h, u) : t;
  }, u.size = function(h) {
    return arguments.length ? (n = +h[0], r = +h[1], u) : [n, r];
  }, u.tile = function(h) {
    return arguments.length ? (e = rg(h), u) : e;
  }, u.padding = function(h) {
    return arguments.length ? u.paddingInner(h).paddingOuter(h) : u.paddingInner();
  }, u.paddingInner = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : Vr(+h), u) : s;
  }, u.paddingOuter = function(h) {
    return arguments.length ? u.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : u.paddingTop();
  }, u.paddingTop = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : Vr(+h), u) : a;
  }, u.paddingRight = function(h) {
    return arguments.length ? (o = typeof h == "function" ? h : Vr(+h), u) : o;
  }, u.paddingBottom = function(h) {
    return arguments.length ? (l = typeof h == "function" ? h : Vr(+h), u) : l;
  }, u.paddingLeft = function(h) {
    return arguments.length ? (c = typeof h == "function" ? h : Vr(+h), u) : c;
  }, u;
}
function gi(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
const yd = Symbol("implicit");
function $o() {
  var e = new yh(), t = [], n = [], r = yd;
  function i(s) {
    let a = e.get(s);
    if (a === void 0) {
      if (r !== yd)
        return r;
      e.set(s, a = t.push(s) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new yh();
    for (const a of s)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return $o(t, n).unknown(r);
  }, gi.apply(i, arguments), i;
}
function Ds() {
  var e = $o().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, s, a, o = !1, l = 0, c = 0, u = 0.5;
  delete e.unknown;
  function d() {
    var h = t().length, f = i < r, p = f ? i : r, v = f ? r : i;
    s = (v - p) / Math.max(1, h - l + c * 2), o && (s = Math.floor(s)), p += (v - p - s * (h - l)) * u, a = s * (1 - l), o && (p = Math.round(p), a = Math.round(a));
    var m = Ey(h).map(function(y) {
      return p + s * y;
    });
    return n(f ? m.reverse() : m);
  }
  return e.domain = function(h) {
    return arguments.length ? (t(h), d()) : t();
  }, e.range = function(h) {
    return arguments.length ? ([r, i] = h, r = +r, i = +i, d()) : [r, i];
  }, e.rangeRound = function(h) {
    return [r, i] = h, r = +r, i = +i, o = !0, d();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return s;
  }, e.round = function(h) {
    return arguments.length ? (o = !!h, d()) : o;
  }, e.padding = function(h) {
    return arguments.length ? (l = Math.min(1, c = +h), d()) : l;
  }, e.paddingInner = function(h) {
    return arguments.length ? (l = Math.min(1, h), d()) : l;
  }, e.paddingOuter = function(h) {
    return arguments.length ? (c = +h, d()) : c;
  }, e.align = function(h) {
    return arguments.length ? (u = Math.max(0, Math.min(1, h)), d()) : u;
  }, e.copy = function() {
    return Ds(t(), [r, i]).round(o).paddingInner(l).paddingOuter(c).align(u);
  }, gi.apply(d(), arguments);
}
function dw(e) {
  return function() {
    return e;
  };
}
function fw(e) {
  return +e;
}
var xd = [0, 1];
function qr(e) {
  return e;
}
function wc(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : dw(isNaN(t) ? NaN : 0.5);
}
function pw(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function mw(e, t, n) {
  var r = e[0], i = e[1], s = t[0], a = t[1];
  return i < r ? (r = wc(i, r), s = n(a, s)) : (r = wc(r, i), s = n(s, a)), function(o) {
    return s(r(o));
  };
}
function gw(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), s = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = wc(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
  return function(o) {
    var l = uu(e, o, 1, r) - 1;
    return s[l](i[l](o));
  };
}
function Mu(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function ag() {
  var e = xd, t = xd, n = Rs, r, i, s, a = qr, o, l, c;
  function u() {
    var h = Math.min(e.length, t.length);
    return a !== qr && (a = pw(e[0], e[h - 1])), o = h > 2 ? gw : mw, l = c = null, d;
  }
  function d(h) {
    return h == null || isNaN(h = +h) ? s : (l || (l = o(e.map(r), t, n)))(r(a(h)));
  }
  return d.invert = function(h) {
    return a(i((c || (c = o(t, e.map(r), Me)))(h)));
  }, d.domain = function(h) {
    return arguments.length ? (e = Array.from(h, fw), u()) : e.slice();
  }, d.range = function(h) {
    return arguments.length ? (t = Array.from(h), u()) : t.slice();
  }, d.rangeRound = function(h) {
    return t = Array.from(h), n = ym, u();
  }, d.clamp = function(h) {
    return arguments.length ? (a = h ? !0 : qr, u()) : a !== qr;
  }, d.interpolate = function(h) {
    return arguments.length ? (n = h, u()) : n;
  }, d.unknown = function(h) {
    return arguments.length ? (s = h, d) : s;
  }, function(h, f) {
    return r = h, i = f, u();
  };
}
function og() {
  return ag()(qr, qr);
}
function vw(e, t, n, r) {
  var i = Yl(e, t, n), s;
  switch (r = ys(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(s = vE(i, a)) && (r.precision = s), km(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = yE(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = gE(i)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return wu(r);
}
function lg(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return Na(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return vw(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, s = r.length - 1, a = r[i], o = r[s], l, c, u = 10;
    for (o < a && (c = a, a = o, o = c, c = i, i = s, s = c); u-- > 0; ) {
      if (c = ni(a, o, n), c === l)
        return r[i] = a, r[s] = o, t(r);
      if (c > 0)
        a = Math.floor(a / c) * c, o = Math.ceil(o / c) * c;
      else if (c < 0)
        a = Math.ceil(a * c) / c, o = Math.floor(o * c) / c;
      else
        break;
      l = c;
    }
    return e;
  }, e;
}
function Ke() {
  var e = og();
  return e.copy = function() {
    return Mu(e, Ke());
  }, gi.apply(e, arguments), lg(e);
}
function cg(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], s = e[r], a;
  return s < i && (a = n, n = r, r = a, a = i, i = s, s = a), e[n] = t.floor(i), e[r] = t.ceil(s), e;
}
function bd(e) {
  return Math.log(e);
}
function Ed(e) {
  return Math.exp(e);
}
function yw(e) {
  return -Math.log(-e);
}
function xw(e) {
  return -Math.exp(-e);
}
function bw(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function Ew(e) {
  return e === 10 ? bw : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function _w(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function _d(e) {
  return (t, n) => -e(-t, n);
}
function ww(e) {
  const t = e(bd, Ed), n = t.domain;
  let r = 10, i, s;
  function a() {
    return i = _w(r), s = Ew(r), n()[0] < 0 ? (i = _d(i), s = _d(s), e(yw, xw)) : e(bd, Ed), t;
  }
  return t.base = function(o) {
    return arguments.length ? (r = +o, a()) : r;
  }, t.domain = function(o) {
    return arguments.length ? (n(o), a()) : n();
  }, t.ticks = (o) => {
    const l = n();
    let c = l[0], u = l[l.length - 1];
    const d = u < c;
    d && ([c, u] = [u, c]);
    let h = i(c), f = i(u), p, v;
    const m = o == null ? 10 : +o;
    let y = [];
    if (!(r % 1) && f - h < m) {
      if (h = Math.floor(h), f = Math.ceil(f), c > 0) {
        for (; h <= f; ++h)
          for (p = 1; p < r; ++p)
            if (v = h < 0 ? p / s(-h) : p * s(h), !(v < c)) {
              if (v > u)
                break;
              y.push(v);
            }
      } else
        for (; h <= f; ++h)
          for (p = r - 1; p >= 1; --p)
            if (v = h > 0 ? p / s(-h) : p * s(h), !(v < c)) {
              if (v > u)
                break;
              y.push(v);
            }
      y.length * 2 < m && (y = Na(c, u, m));
    } else
      y = Na(h, f, Math.min(f - h, m)).map(s);
    return d ? y.reverse() : y;
  }, t.tickFormat = (o, l) => {
    if (o == null && (o = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = ys(l)).precision == null && (l.trim = !0), l = wu(l)), o === 1 / 0)
      return l;
    const c = Math.max(1, r * o / t.ticks().length);
    return (u) => {
      let d = u / s(Math.round(i(u)));
      return d * r < r - 0.5 && (d *= r), d <= c ? l(u) : "";
    };
  }, t.nice = () => n(cg(n(), {
    floor: (o) => s(Math.floor(i(o))),
    ceil: (o) => s(Math.ceil(i(o)))
  })), t;
}
function ug() {
  const e = ww(ag()).domain([1, 10]);
  return e.copy = () => Mu(e, ug()).base(e.base()), gi.apply(e, arguments), e;
}
function Cu() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], s;
  function a(l) {
    return l != null && l <= l ? i[uu(r, l, 0, n)] : s;
  }
  function o() {
    var l = -1;
    for (r = new Array(n); ++l < n; )
      r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, o()) : [e, t];
  }, a.range = function(l) {
    return arguments.length ? (n = (i = Array.from(l)).length - 1, o()) : i.slice();
  }, a.invertExtent = function(l) {
    var c = i.indexOf(l);
    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];
  }, a.unknown = function(l) {
    return arguments.length && (s = l), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return Cu().domain([e, t]).range(i).unknown(s);
  }, gi.apply(lg(a), arguments);
}
const El = /* @__PURE__ */ new Date(), _l = /* @__PURE__ */ new Date();
function ne(e, t, n, r) {
  function i(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
    const a = i(s), o = i.ceil(s);
    return s - a < o - s ? a : o;
  }, i.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, o) => {
    const l = [];
    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0))
      return l;
    let c;
    do
      l.push(c = /* @__PURE__ */ new Date(+s)), t(s, o), e(s);
    while (c < s && s < a);
    return l;
  }, i.filter = (s) => ne((a) => {
    if (a >= a)
      for (; e(a), !s(a); )
        a.setTime(a - 1);
  }, (a, o) => {
    if (a >= a)
      if (o < 0)
        for (; ++o <= 0; )
          for (; t(a, -1), !s(a); )
            ;
      else
        for (; --o >= 0; )
          for (; t(a, 1), !s(a); )
            ;
  }), n && (i.count = (s, a) => (El.setTime(+s), _l.setTime(+a), e(El), e(_l), Math.floor(n(El, _l))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (a) => r(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;
}
const no = ne(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
no.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? ne((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : no);
no.range;
const Tn = 1e3, Ue = Tn * 60, Mn = Ue * 60, kn = Mn * 24, Au = kn * 7, wd = kn * 30, wl = kn * 365, Yr = ne((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * Tn);
}, (e, t) => (t - e) / Tn, (e) => e.getUTCSeconds());
Yr.range;
const $u = ne((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Tn);
}, (e, t) => {
  e.setTime(+e + t * Ue);
}, (e, t) => (t - e) / Ue, (e) => e.getMinutes());
$u.range;
const Sw = ne((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Ue);
}, (e, t) => (t - e) / Ue, (e) => e.getUTCMinutes());
Sw.range;
const Lu = ne((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Tn - e.getMinutes() * Ue);
}, (e, t) => {
  e.setTime(+e + t * Mn);
}, (e, t) => (t - e) / Mn, (e) => e.getHours());
Lu.range;
const Ow = ne((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Mn);
}, (e, t) => (t - e) / Mn, (e) => e.getUTCHours());
Ow.range;
const Is = ne(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ue) / kn,
  (e) => e.getDate() - 1
);
Is.range;
const Ru = ne((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / kn, (e) => e.getUTCDate() - 1);
Ru.range;
const Tw = ne((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / kn, (e) => Math.floor(e / kn));
Tw.range;
function Sr(e) {
  return ne((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ue) / Au);
}
const Lo = Sr(0), ro = Sr(1), Mw = Sr(2), Cw = Sr(3), li = Sr(4), Aw = Sr(5), $w = Sr(6);
Lo.range;
ro.range;
Mw.range;
Cw.range;
li.range;
Aw.range;
$w.range;
function Or(e) {
  return ne((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Au);
}
const hg = Or(0), io = Or(1), Lw = Or(2), Rw = Or(3), ci = Or(4), kw = Or(5), Dw = Or(6);
hg.range;
io.range;
Lw.range;
Rw.range;
ci.range;
kw.range;
Dw.range;
const ku = ne((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
ku.range;
const Iw = ne((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Iw.range;
const Dn = ne((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Dn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ne((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
Dn.range;
const Er = ne((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Er.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ne((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
Er.range;
function Nw(e, t, n, r, i, s) {
  const a = [
    [Yr, 1, Tn],
    [Yr, 5, 5 * Tn],
    [Yr, 15, 15 * Tn],
    [Yr, 30, 30 * Tn],
    [s, 1, Ue],
    [s, 5, 5 * Ue],
    [s, 15, 15 * Ue],
    [s, 30, 30 * Ue],
    [i, 1, Mn],
    [i, 3, 3 * Mn],
    [i, 6, 6 * Mn],
    [i, 12, 12 * Mn],
    [r, 1, kn],
    [r, 2, 2 * kn],
    [n, 1, Au],
    [t, 1, wd],
    [t, 3, 3 * wd],
    [e, 1, wl]
  ];
  function o(c, u, d) {
    const h = u < c;
    h && ([c, u] = [u, c]);
    const f = d && typeof d.range == "function" ? d : l(c, u, d), p = f ? f.range(c, +u + 1) : [];
    return h ? p.reverse() : p;
  }
  function l(c, u, d) {
    const h = Math.abs(u - c) / d, f = cu(([, , m]) => m).right(a, h);
    if (f === a.length)
      return e.every(Yl(c / wl, u / wl, d));
    if (f === 0)
      return no.every(Math.max(Yl(c, u, d), 1));
    const [p, v] = a[h / a[f - 1][2] < a[f][2] / h ? f - 1 : f];
    return p.every(v);
  }
  return [o, l];
}
const [Pw, Uw] = Nw(Dn, ku, Lo, Is, Lu, $u);
function Sl(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ol(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ki(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function Bw(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, s = e.days, a = e.shortDays, o = e.months, l = e.shortMonths, c = Di(i), u = Ii(i), d = Di(s), h = Ii(s), f = Di(a), p = Ii(a), v = Di(o), m = Ii(o), y = Di(l), g = Ii(l), b = {
    a: $,
    A: U,
    b: B,
    B: W,
    c: null,
    d: Ad,
    e: Ad,
    f: lS,
    g: yS,
    G: bS,
    H: sS,
    I: aS,
    j: oS,
    L: dg,
    m: cS,
    M: uS,
    p: K,
    q: Q,
    Q: Rd,
    s: kd,
    S: hS,
    u: dS,
    U: fS,
    V: pS,
    w: mS,
    W: gS,
    x: null,
    X: null,
    y: vS,
    Y: xS,
    Z: ES,
    "%": Ld
  }, w = {
    a: dt,
    A: it,
    b: pt,
    B: Z,
    c: null,
    d: $d,
    e: $d,
    f: OS,
    g: IS,
    G: PS,
    H: _S,
    I: wS,
    j: SS,
    L: pg,
    m: TS,
    M: MS,
    p: tt,
    q: ft,
    Q: Rd,
    s: kd,
    S: CS,
    u: AS,
    U: $S,
    V: LS,
    w: RS,
    W: kS,
    x: null,
    X: null,
    y: DS,
    Y: NS,
    Z: US,
    "%": Ld
  }, _ = {
    a: R,
    A: M,
    b: V,
    B: P,
    c: H,
    d: Md,
    e: Md,
    f: eS,
    g: Td,
    G: Od,
    H: Cd,
    I: Cd,
    j: Kw,
    L: tS,
    m: Zw,
    M: Qw,
    p: k,
    q: Xw,
    Q: rS,
    s: iS,
    S: Jw,
    u: Gw,
    U: jw,
    V: Ww,
    w: zw,
    W: qw,
    x: E,
    X: A,
    y: Td,
    Y: Od,
    Z: Yw,
    "%": nS
  };
  b.x = S(n, b), b.X = S(r, b), b.c = S(t, b), w.x = S(n, w), w.X = S(r, w), w.c = S(t, w);
  function S(q, J) {
    return function(ot) {
      var G = [], wt = -1, bt = 0, Gt = q.length, It, nt, Tt;
      for (ot instanceof Date || (ot = /* @__PURE__ */ new Date(+ot)); ++wt < Gt; )
        q.charCodeAt(wt) === 37 && (G.push(q.slice(bt, wt)), (nt = Sd[It = q.charAt(++wt)]) != null ? It = q.charAt(++wt) : nt = It === "e" ? " " : "0", (Tt = J[It]) && (It = Tt(ot, nt)), G.push(It), bt = wt + 1);
      return G.push(q.slice(bt, wt)), G.join("");
    };
  }
  function L(q, J) {
    return function(ot) {
      var G = ki(1900, void 0, 1), wt = D(G, q, ot += "", 0), bt, Gt;
      if (wt != ot.length)
        return null;
      if ("Q" in G)
        return new Date(G.Q);
      if ("s" in G)
        return new Date(G.s * 1e3 + ("L" in G ? G.L : 0));
      if (J && !("Z" in G) && (G.Z = 0), "p" in G && (G.H = G.H % 12 + G.p * 12), G.m === void 0 && (G.m = "q" in G ? G.q : 0), "V" in G) {
        if (G.V < 1 || G.V > 53)
          return null;
        "w" in G || (G.w = 1), "Z" in G ? (bt = Ol(ki(G.y, 0, 1)), Gt = bt.getUTCDay(), bt = Gt > 4 || Gt === 0 ? io.ceil(bt) : io(bt), bt = Ru.offset(bt, (G.V - 1) * 7), G.y = bt.getUTCFullYear(), G.m = bt.getUTCMonth(), G.d = bt.getUTCDate() + (G.w + 6) % 7) : (bt = Sl(ki(G.y, 0, 1)), Gt = bt.getDay(), bt = Gt > 4 || Gt === 0 ? ro.ceil(bt) : ro(bt), bt = Is.offset(bt, (G.V - 1) * 7), G.y = bt.getFullYear(), G.m = bt.getMonth(), G.d = bt.getDate() + (G.w + 6) % 7);
      } else
        ("W" in G || "U" in G) && ("w" in G || (G.w = "u" in G ? G.u % 7 : "W" in G ? 1 : 0), Gt = "Z" in G ? Ol(ki(G.y, 0, 1)).getUTCDay() : Sl(ki(G.y, 0, 1)).getDay(), G.m = 0, G.d = "W" in G ? (G.w + 6) % 7 + G.W * 7 - (Gt + 5) % 7 : G.w + G.U * 7 - (Gt + 6) % 7);
      return "Z" in G ? (G.H += G.Z / 100 | 0, G.M += G.Z % 100, Ol(G)) : Sl(G);
    };
  }
  function D(q, J, ot, G) {
    for (var wt = 0, bt = J.length, Gt = ot.length, It, nt; wt < bt; ) {
      if (G >= Gt)
        return -1;
      if (It = J.charCodeAt(wt++), It === 37) {
        if (It = J.charAt(wt++), nt = _[It in Sd ? J.charAt(wt++) : It], !nt || (G = nt(q, ot, G)) < 0)
          return -1;
      } else if (It != ot.charCodeAt(G++))
        return -1;
    }
    return G;
  }
  function k(q, J, ot) {
    var G = c.exec(J.slice(ot));
    return G ? (q.p = u.get(G[0].toLowerCase()), ot + G[0].length) : -1;
  }
  function R(q, J, ot) {
    var G = f.exec(J.slice(ot));
    return G ? (q.w = p.get(G[0].toLowerCase()), ot + G[0].length) : -1;
  }
  function M(q, J, ot) {
    var G = d.exec(J.slice(ot));
    return G ? (q.w = h.get(G[0].toLowerCase()), ot + G[0].length) : -1;
  }
  function V(q, J, ot) {
    var G = y.exec(J.slice(ot));
    return G ? (q.m = g.get(G[0].toLowerCase()), ot + G[0].length) : -1;
  }
  function P(q, J, ot) {
    var G = v.exec(J.slice(ot));
    return G ? (q.m = m.get(G[0].toLowerCase()), ot + G[0].length) : -1;
  }
  function H(q, J, ot) {
    return D(q, t, J, ot);
  }
  function E(q, J, ot) {
    return D(q, n, J, ot);
  }
  function A(q, J, ot) {
    return D(q, r, J, ot);
  }
  function $(q) {
    return a[q.getDay()];
  }
  function U(q) {
    return s[q.getDay()];
  }
  function B(q) {
    return l[q.getMonth()];
  }
  function W(q) {
    return o[q.getMonth()];
  }
  function K(q) {
    return i[+(q.getHours() >= 12)];
  }
  function Q(q) {
    return 1 + ~~(q.getMonth() / 3);
  }
  function dt(q) {
    return a[q.getUTCDay()];
  }
  function it(q) {
    return s[q.getUTCDay()];
  }
  function pt(q) {
    return l[q.getUTCMonth()];
  }
  function Z(q) {
    return o[q.getUTCMonth()];
  }
  function tt(q) {
    return i[+(q.getUTCHours() >= 12)];
  }
  function ft(q) {
    return 1 + ~~(q.getUTCMonth() / 3);
  }
  return {
    format: function(q) {
      var J = S(q += "", b);
      return J.toString = function() {
        return q;
      }, J;
    },
    parse: function(q) {
      var J = L(q += "", !1);
      return J.toString = function() {
        return q;
      }, J;
    },
    utcFormat: function(q) {
      var J = S(q += "", w);
      return J.toString = function() {
        return q;
      }, J;
    },
    utcParse: function(q) {
      var J = L(q += "", !0);
      return J.toString = function() {
        return q;
      }, J;
    }
  };
}
var Sd = { "-": "", _: " ", 0: "0" }, re = /^\s*\d+/, Hw = /^%/, Vw = /[\\^$*+?|[\]().{}]/g;
function Ot(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", s = i.length;
  return r + (s < n ? new Array(n - s + 1).join(t) + i : i);
}
function Fw(e) {
  return e.replace(Vw, "\\$&");
}
function Di(e) {
  return new RegExp("^(?:" + e.map(Fw).join("|") + ")", "i");
}
function Ii(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function zw(e, t, n) {
  var r = re.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function Gw(e, t, n) {
  var r = re.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function jw(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function Ww(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function qw(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function Od(e, t, n) {
  var r = re.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function Td(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function Yw(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function Xw(e, t, n) {
  var r = re.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function Zw(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function Md(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function Kw(e, t, n) {
  var r = re.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function Cd(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function Qw(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function Jw(e, t, n) {
  var r = re.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function tS(e, t, n) {
  var r = re.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function eS(e, t, n) {
  var r = re.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function nS(e, t, n) {
  var r = Hw.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function rS(e, t, n) {
  var r = re.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function iS(e, t, n) {
  var r = re.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function Ad(e, t) {
  return Ot(e.getDate(), t, 2);
}
function sS(e, t) {
  return Ot(e.getHours(), t, 2);
}
function aS(e, t) {
  return Ot(e.getHours() % 12 || 12, t, 2);
}
function oS(e, t) {
  return Ot(1 + Is.count(Dn(e), e), t, 3);
}
function dg(e, t) {
  return Ot(e.getMilliseconds(), t, 3);
}
function lS(e, t) {
  return dg(e, t) + "000";
}
function cS(e, t) {
  return Ot(e.getMonth() + 1, t, 2);
}
function uS(e, t) {
  return Ot(e.getMinutes(), t, 2);
}
function hS(e, t) {
  return Ot(e.getSeconds(), t, 2);
}
function dS(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function fS(e, t) {
  return Ot(Lo.count(Dn(e) - 1, e), t, 2);
}
function fg(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? li(e) : li.ceil(e);
}
function pS(e, t) {
  return e = fg(e), Ot(li.count(Dn(e), e) + (Dn(e).getDay() === 4), t, 2);
}
function mS(e) {
  return e.getDay();
}
function gS(e, t) {
  return Ot(ro.count(Dn(e) - 1, e), t, 2);
}
function vS(e, t) {
  return Ot(e.getFullYear() % 100, t, 2);
}
function yS(e, t) {
  return e = fg(e), Ot(e.getFullYear() % 100, t, 2);
}
function xS(e, t) {
  return Ot(e.getFullYear() % 1e4, t, 4);
}
function bS(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? li(e) : li.ceil(e), Ot(e.getFullYear() % 1e4, t, 4);
}
function ES(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ot(t / 60 | 0, "0", 2) + Ot(t % 60, "0", 2);
}
function $d(e, t) {
  return Ot(e.getUTCDate(), t, 2);
}
function _S(e, t) {
  return Ot(e.getUTCHours(), t, 2);
}
function wS(e, t) {
  return Ot(e.getUTCHours() % 12 || 12, t, 2);
}
function SS(e, t) {
  return Ot(1 + Ru.count(Er(e), e), t, 3);
}
function pg(e, t) {
  return Ot(e.getUTCMilliseconds(), t, 3);
}
function OS(e, t) {
  return pg(e, t) + "000";
}
function TS(e, t) {
  return Ot(e.getUTCMonth() + 1, t, 2);
}
function MS(e, t) {
  return Ot(e.getUTCMinutes(), t, 2);
}
function CS(e, t) {
  return Ot(e.getUTCSeconds(), t, 2);
}
function AS(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function $S(e, t) {
  return Ot(hg.count(Er(e) - 1, e), t, 2);
}
function mg(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? ci(e) : ci.ceil(e);
}
function LS(e, t) {
  return e = mg(e), Ot(ci.count(Er(e), e) + (Er(e).getUTCDay() === 4), t, 2);
}
function RS(e) {
  return e.getUTCDay();
}
function kS(e, t) {
  return Ot(io.count(Er(e) - 1, e), t, 2);
}
function DS(e, t) {
  return Ot(e.getUTCFullYear() % 100, t, 2);
}
function IS(e, t) {
  return e = mg(e), Ot(e.getUTCFullYear() % 100, t, 2);
}
function NS(e, t) {
  return Ot(e.getUTCFullYear() % 1e4, t, 4);
}
function PS(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? ci(e) : ci.ceil(e), Ot(e.getUTCFullYear() % 1e4, t, 4);
}
function US() {
  return "+0000";
}
function Ld() {
  return "%";
}
function Rd(e) {
  return +e;
}
function kd(e) {
  return Math.floor(+e / 1e3);
}
var Ir, gg;
BS({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function BS(e) {
  return Ir = Bw(e), gg = Ir.format, Ir.parse, Ir.utcFormat, Ir.utcParse, Ir;
}
function HS(e) {
  return new Date(e);
}
function VS(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function vg(e, t, n, r, i, s, a, o, l, c) {
  var u = og(), d = u.invert, h = u.domain, f = c(".%L"), p = c(":%S"), v = c("%I:%M"), m = c("%I %p"), y = c("%a %d"), g = c("%b %d"), b = c("%B"), w = c("%Y");
  function _(S) {
    return (l(S) < S ? f : o(S) < S ? p : a(S) < S ? v : s(S) < S ? m : r(S) < S ? i(S) < S ? y : g : n(S) < S ? b : w)(S);
  }
  return u.invert = function(S) {
    return new Date(d(S));
  }, u.domain = function(S) {
    return arguments.length ? h(Array.from(S, VS)) : h().map(HS);
  }, u.ticks = function(S) {
    var L = h();
    return e(L[0], L[L.length - 1], S ?? 10);
  }, u.tickFormat = function(S, L) {
    return L == null ? _ : c(L);
  }, u.nice = function(S) {
    var L = h();
    return (!S || typeof S.range != "function") && (S = t(L[0], L[L.length - 1], S ?? 10)), S ? h(cg(L, S)) : u;
  }, u.copy = function() {
    return Mu(u, vg(e, t, n, r, i, s, a, o, l, c));
  }, u;
}
function yg() {
  return gi.apply(vg(Pw, Uw, Dn, ku, Lo, Is, Lu, $u, Yr, gg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function mt(e) {
  return function() {
    return e;
  };
}
const Dd = Math.abs, le = Math.atan2, ir = Math.cos, FS = Math.max, Tl = Math.min, sn = Math.sin, Xr = Math.sqrt, ce = 1e-12, _s = Math.PI, so = _s / 2, Ca = 2 * _s;
function zS(e) {
  return e > 1 ? 0 : e < -1 ? _s : Math.acos(e);
}
function Id(e) {
  return e >= 1 ? so : e <= -1 ? -so : Math.asin(e);
}
function Ro(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new Eu(t);
}
function GS(e) {
  return e.innerRadius;
}
function jS(e) {
  return e.outerRadius;
}
function WS(e) {
  return e.startAngle;
}
function qS(e) {
  return e.endAngle;
}
function YS(e) {
  return e && e.padAngle;
}
function XS(e, t, n, r, i, s, a, o) {
  var l = n - e, c = r - t, u = a - i, d = o - s, h = d * l - u * c;
  if (!(h * h < ce))
    return h = (u * (t - s) - d * (e - i)) / h, [e + h * l, t + h * c];
}
function oa(e, t, n, r, i, s, a) {
  var o = e - n, l = t - r, c = (a ? s : -s) / Xr(o * o + l * l), u = c * l, d = -c * o, h = e + u, f = t + d, p = n + u, v = r + d, m = (h + p) / 2, y = (f + v) / 2, g = p - h, b = v - f, w = g * g + b * b, _ = i - s, S = h * v - p * f, L = (b < 0 ? -1 : 1) * Xr(FS(0, _ * _ * w - S * S)), D = (S * b - g * L) / w, k = (-S * g - b * L) / w, R = (S * b + g * L) / w, M = (-S * g + b * L) / w, V = D - m, P = k - y, H = R - m, E = M - y;
  return V * V + P * P > H * H + E * E && (D = R, k = M), {
    cx: D,
    cy: k,
    x01: -u,
    y01: -d,
    x11: D * (i / _ - 1),
    y11: k * (i / _ - 1)
  };
}
function ws() {
  var e = GS, t = jS, n = mt(0), r = null, i = WS, s = qS, a = YS, o = null, l = Ro(c);
  function c() {
    var u, d, h = +e.apply(this, arguments), f = +t.apply(this, arguments), p = i.apply(this, arguments) - so, v = s.apply(this, arguments) - so, m = Dd(v - p), y = v > p;
    if (o || (o = u = l()), f < h && (d = f, f = h, h = d), !(f > ce))
      o.moveTo(0, 0);
    else if (m > Ca - ce)
      o.moveTo(f * ir(p), f * sn(p)), o.arc(0, 0, f, p, v, !y), h > ce && (o.moveTo(h * ir(v), h * sn(v)), o.arc(0, 0, h, v, p, y));
    else {
      var g = p, b = v, w = p, _ = v, S = m, L = m, D = a.apply(this, arguments) / 2, k = D > ce && (r ? +r.apply(this, arguments) : Xr(h * h + f * f)), R = Tl(Dd(f - h) / 2, +n.apply(this, arguments)), M = R, V = R, P, H;
      if (k > ce) {
        var E = Id(k / h * sn(D)), A = Id(k / f * sn(D));
        (S -= E * 2) > ce ? (E *= y ? 1 : -1, w += E, _ -= E) : (S = 0, w = _ = (p + v) / 2), (L -= A * 2) > ce ? (A *= y ? 1 : -1, g += A, b -= A) : (L = 0, g = b = (p + v) / 2);
      }
      var $ = f * ir(g), U = f * sn(g), B = h * ir(_), W = h * sn(_);
      if (R > ce) {
        var K = f * ir(b), Q = f * sn(b), dt = h * ir(w), it = h * sn(w), pt;
        if (m < _s)
          if (pt = XS($, U, dt, it, K, Q, B, W)) {
            var Z = $ - pt[0], tt = U - pt[1], ft = K - pt[0], q = Q - pt[1], J = 1 / sn(zS((Z * ft + tt * q) / (Xr(Z * Z + tt * tt) * Xr(ft * ft + q * q))) / 2), ot = Xr(pt[0] * pt[0] + pt[1] * pt[1]);
            M = Tl(R, (h - ot) / (J - 1)), V = Tl(R, (f - ot) / (J + 1));
          } else
            M = V = 0;
      }
      L > ce ? V > ce ? (P = oa(dt, it, $, U, f, V, y), H = oa(K, Q, B, W, f, V, y), o.moveTo(P.cx + P.x01, P.cy + P.y01), V < R ? o.arc(P.cx, P.cy, V, le(P.y01, P.x01), le(H.y01, H.x01), !y) : (o.arc(P.cx, P.cy, V, le(P.y01, P.x01), le(P.y11, P.x11), !y), o.arc(0, 0, f, le(P.cy + P.y11, P.cx + P.x11), le(H.cy + H.y11, H.cx + H.x11), !y), o.arc(H.cx, H.cy, V, le(H.y11, H.x11), le(H.y01, H.x01), !y))) : (o.moveTo($, U), o.arc(0, 0, f, g, b, !y)) : o.moveTo($, U), !(h > ce) || !(S > ce) ? o.lineTo(B, W) : M > ce ? (P = oa(B, W, K, Q, h, -M, y), H = oa($, U, dt, it, h, -M, y), o.lineTo(P.cx + P.x01, P.cy + P.y01), M < R ? o.arc(P.cx, P.cy, M, le(P.y01, P.x01), le(H.y01, H.x01), !y) : (o.arc(P.cx, P.cy, M, le(P.y01, P.x01), le(P.y11, P.x11), !y), o.arc(0, 0, h, le(P.cy + P.y11, P.cx + P.x11), le(H.cy + H.y11, H.cx + H.x11), y), o.arc(H.cx, H.cy, M, le(H.y11, H.x11), le(H.y01, H.x01), !y))) : o.arc(0, 0, h, _, w, y);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return c.centroid = function() {
    var u = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - _s / 2;
    return [ir(d) * u, sn(d) * u];
  }, c.innerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : mt(+u), c) : e;
  }, c.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : mt(+u), c) : t;
  }, c.cornerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : mt(+u), c) : n;
  }, c.padRadius = function(u) {
    return arguments.length ? (r = u == null ? null : typeof u == "function" ? u : mt(+u), c) : r;
  }, c.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : mt(+u), c) : i;
  }, c.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : mt(+u), c) : s;
  }, c.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : mt(+u), c) : a;
  }, c.context = function(u) {
    return arguments.length ? (o = u ?? null, c) : o;
  }, c;
}
var ZS = Array.prototype.slice;
function ko(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function xg(e) {
  this._context = e;
}
xg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Do(e) {
  return new xg(e);
}
function Du(e) {
  return e[0];
}
function Iu(e) {
  return e[1];
}
function Ns(e, t) {
  var n = mt(!0), r = null, i = Do, s = null, a = Ro(o);
  e = typeof e == "function" ? e : e === void 0 ? Du : mt(e), t = typeof t == "function" ? t : t === void 0 ? Iu : mt(t);
  function o(l) {
    var c, u = (l = ko(l)).length, d, h = !1, f;
    for (r == null && (s = i(f = a())), c = 0; c <= u; ++c)
      !(c < u && n(d = l[c], c, l)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(d, c, l), +t(d, c, l));
    if (f)
      return s = null, f + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : mt(+l), o) : e;
  }, o.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : mt(+l), o) : t;
  }, o.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : mt(!!l), o) : n;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, r != null && (s = i(r)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? r = s = null : s = i(r = l), o) : r;
  }, o;
}
function Nu(e, t, n) {
  var r = null, i = mt(!0), s = null, a = Do, o = null, l = Ro(c);
  e = typeof e == "function" ? e : e === void 0 ? Du : mt(+e), t = typeof t == "function" ? t : mt(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? Iu : mt(+n);
  function c(d) {
    var h, f, p, v = (d = ko(d)).length, m, y = !1, g, b = new Array(v), w = new Array(v);
    for (s == null && (o = a(g = l())), h = 0; h <= v; ++h) {
      if (!(h < v && i(m = d[h], h, d)) === y)
        if (y = !y)
          f = h, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), p = h - 1; p >= f; --p)
            o.point(b[p], w[p]);
          o.lineEnd(), o.areaEnd();
        }
      y && (b[h] = +e(m, h, d), w[h] = +t(m, h, d), o.point(r ? +r(m, h, d) : b[h], n ? +n(m, h, d) : w[h]));
    }
    if (g)
      return o = null, g + "" || null;
  }
  function u() {
    return Ns().defined(i).curve(a).context(s);
  }
  return c.x = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : mt(+d), r = null, c) : e;
  }, c.x0 = function(d) {
    return arguments.length ? (e = typeof d == "function" ? d : mt(+d), c) : e;
  }, c.x1 = function(d) {
    return arguments.length ? (r = d == null ? null : typeof d == "function" ? d : mt(+d), c) : r;
  }, c.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : mt(+d), n = null, c) : t;
  }, c.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : mt(+d), c) : t;
  }, c.y1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : mt(+d), c) : n;
  }, c.lineX0 = c.lineY0 = function() {
    return u().x(e).y(t);
  }, c.lineY1 = function() {
    return u().x(e).y(n);
  }, c.lineX1 = function() {
    return u().x(r).y(t);
  }, c.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : mt(!!d), c) : i;
  }, c.curve = function(d) {
    return arguments.length ? (a = d, s != null && (o = a(s)), c) : a;
  }, c.context = function(d) {
    return arguments.length ? (d == null ? s = o = null : o = a(s = d), c) : s;
  }, c;
}
function KS(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function QS(e) {
  return e;
}
function JS() {
  var e = QS, t = KS, n = null, r = mt(0), i = mt(Ca), s = mt(0);
  function a(o) {
    var l, c = (o = ko(o)).length, u, d, h = 0, f = new Array(c), p = new Array(c), v = +r.apply(this, arguments), m = Math.min(Ca, Math.max(-Ca, i.apply(this, arguments) - v)), y, g = Math.min(Math.abs(m) / c, s.apply(this, arguments)), b = g * (m < 0 ? -1 : 1), w;
    for (l = 0; l < c; ++l)
      (w = p[f[l] = l] = +e(o[l], l, o)) > 0 && (h += w);
    for (t != null ? f.sort(function(_, S) {
      return t(p[_], p[S]);
    }) : n != null && f.sort(function(_, S) {
      return n(o[_], o[S]);
    }), l = 0, d = h ? (m - c * b) / h : 0; l < c; ++l, v = y)
      u = f[l], w = p[u], y = v + (w > 0 ? w * d : 0) + b, p[u] = {
        data: o[u],
        index: l,
        value: w,
        startAngle: v,
        endAngle: y,
        padAngle: g
      };
    return p;
  }
  return a.value = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : mt(+o), a) : e;
  }, a.sortValues = function(o) {
    return arguments.length ? (t = o, n = null, a) : t;
  }, a.sort = function(o) {
    return arguments.length ? (n = o, t = null, a) : n;
  }, a.startAngle = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : mt(+o), a) : r;
  }, a.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : mt(+o), a) : i;
  }, a.padAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : mt(+o), a) : s;
  }, a;
}
var tO = Eg(Do);
function bg(e) {
  this._curve = e;
}
bg.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(e, t) {
    this._curve.point(t * Math.sin(e), t * -Math.cos(e));
  }
};
function Eg(e) {
  function t(n) {
    return new bg(e(n));
  }
  return t._curve = e, t;
}
function eO(e) {
  var t = e.curve;
  return e.angle = e.x, delete e.x, e.radius = e.y, delete e.y, e.curve = function(n) {
    return arguments.length ? t(Eg(n)) : t()._curve;
  }, e;
}
function nO() {
  return eO(Ns().curve(tO));
}
class rO {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function iO(e) {
  return new rO(e, !0);
}
function sO(e) {
  return e.source;
}
function aO(e) {
  return e.target;
}
function oO(e) {
  let t = sO, n = aO, r = Du, i = Iu, s = null, a = null, o = Ro(l);
  function l() {
    let c;
    const u = ZS.call(arguments), d = t.apply(this, u), h = n.apply(this, u);
    if (s == null && (a = e(c = o())), a.lineStart(), u[0] = d, a.point(+r.apply(this, u), +i.apply(this, u)), u[0] = h, a.point(+r.apply(this, u), +i.apply(this, u)), a.lineEnd(), c)
      return a = null, c + "" || null;
  }
  return l.source = function(c) {
    return arguments.length ? (t = c, l) : t;
  }, l.target = function(c) {
    return arguments.length ? (n = c, l) : n;
  }, l.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : mt(+c), l) : r;
  }, l.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : mt(+c), l) : i;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? s = a = null : a = e(s = c), l) : s;
  }, l;
}
function lO() {
  return oO(iO);
}
function Kn() {
}
function ao(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Io(e) {
  this._context = e;
}
Io.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        ao(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        ao(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function cO(e) {
  return new Io(e);
}
function _g(e) {
  this._context = e;
}
_g.prototype = {
  areaStart: Kn,
  areaEnd: Kn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        ao(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function uO(e) {
  return new _g(e);
}
function wg(e) {
  this._context = e;
}
wg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        ao(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function hO(e) {
  return new wg(e);
}
function Sg(e, t) {
  this._basis = new Io(e), this._beta = t;
}
Sg.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], s = e[n] - r, a = t[n] - i, o = -1, l; ++o <= n; )
        l = o / n, this._basis.point(
          this._beta * e[o] + (1 - this._beta) * (r + l * s),
          this._beta * t[o] + (1 - this._beta) * (i + l * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const dO = function e(t) {
  function n(r) {
    return t === 1 ? new Io(r) : new Sg(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function oo(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function Pu(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Pu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        oo(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        oo(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const fO = function e(t) {
  function n(r) {
    return new Pu(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Uu(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Uu.prototype = {
  areaStart: Kn,
  areaEnd: Kn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        oo(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const pO = function e(t) {
  function n(r) {
    return new Uu(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Bu(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Bu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        oo(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const mO = function e(t) {
  function n(r) {
    return new Bu(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Hu(e, t, n) {
  var r = e._x1, i = e._y1, s = e._x2, a = e._y2;
  if (e._l01_a > ce) {
    var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, i = (i * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > ce) {
    var c = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * c + e._x1 * e._l23_2a - t * e._l12_2a) / u, a = (a * c + e._y1 * e._l23_2a - n * e._l12_2a) / u;
  }
  e._context.bezierCurveTo(r, i, s, a, e._x2, e._y2);
}
function Og(e, t) {
  this._context = e, this._alpha = t;
}
Og.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Hu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const gO = function e(t) {
  function n(r) {
    return t ? new Og(r, t) : new Pu(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Tg(e, t) {
  this._context = e, this._alpha = t;
}
Tg.prototype = {
  areaStart: Kn,
  areaEnd: Kn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Hu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const vO = function e(t) {
  function n(r) {
    return t ? new Tg(r, t) : new Uu(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Mg(e, t) {
  this._context = e, this._alpha = t;
}
Mg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Hu(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const yO = function e(t) {
  function n(r) {
    return t ? new Mg(r, t) : new Bu(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Cg(e) {
  this._context = e;
}
Cg.prototype = {
  areaStart: Kn,
  areaEnd: Kn,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function Ag(e) {
  return new Cg(e);
}
function Nd(e) {
  return e < 0 ? -1 : 1;
}
function Pd(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), o = (s * i + a * r) / (r + i);
  return (Nd(s) + Nd(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Ud(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function Ml(e, t, n) {
  var r = e._x0, i = e._y0, s = e._x1, a = e._y1, o = (s - r) / 3;
  e._context.bezierCurveTo(r + o, i + o * t, s - o, a - o * n, s, a);
}
function lo(e) {
  this._context = e;
}
lo.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Ml(this, this._t0, Ud(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Ml(this, Ud(this, n = Pd(this, e, t)), n);
          break;
        default:
          Ml(this, this._t0, n = Pd(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function $g(e) {
  this._context = new Lg(e);
}
($g.prototype = Object.create(lo.prototype)).point = function(e, t) {
  lo.prototype.point.call(this, t, e);
};
function Lg(e) {
  this._context = e;
}
Lg.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._context.bezierCurveTo(t, e, r, n, s, i);
  }
};
function xO(e) {
  return new lo(e);
}
function bO(e) {
  return new $g(e);
}
function Rg(e) {
  this._context = e;
}
Rg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Bd(e), i = Bd(t), s = 0, a = 1; a < n; ++s, ++a)
          this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Bd(e) {
  var t, n = e.length - 1, r, i = new Array(n), s = new Array(n), a = new Array(n);
  for (i[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / s[t - 1], s[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (a[t] - i[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    s[t] = 2 * e[t + 1] - i[t + 1];
  return [i, s];
}
function EO(e) {
  return new Rg(e);
}
function No(e, t) {
  this._context = e, this._t = t;
}
No.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function _O(e) {
  return new No(e, 0.5);
}
function wO(e) {
  return new No(e, 0);
}
function SO(e) {
  return new No(e, 1);
}
function Hd(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, s = e[t[0]], a, o = s.length; n < a; ++n)
      for (i = s, s = e[t[n]], r = 0; r < o; ++r)
        s[r][1] += s[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function Vd(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function OO(e, t) {
  return e[t];
}
function TO(e) {
  const t = [];
  return t.key = e, t;
}
function Cl() {
  var e = mt([]), t = Vd, n = Hd, r = OO;
  function i(s) {
    var a = Array.from(e.apply(this, arguments), TO), o, l = a.length, c = -1, u;
    for (const d of s)
      for (o = 0, ++c; o < l; ++o)
        (a[o][c] = [0, +r(d, a[o].key, c, s)]).data = d;
    for (o = 0, u = ko(t(a)); o < l; ++o)
      a[u[o]].index = o;
    return n(a, u), a;
  }
  return i.keys = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : mt(Array.from(s)), i) : e;
  }, i.value = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : mt(+s), i) : r;
  }, i.order = function(s) {
    return arguments.length ? (t = s == null ? Vd : typeof s == "function" ? s : mt(Array.from(s)), i) : t;
  }, i.offset = function(s) {
    return arguments.length ? (n = s ?? Hd, i) : n;
  }, i;
}
function MO(e, t) {
  if ((l = e.length) > 0)
    for (var n, r = 0, i, s, a, o, l, c = e[t[0]].length; r < c; ++r)
      for (a = o = 0, n = 0; n < l; ++n)
        (s = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = a, i[1] = a += s) : s < 0 ? (i[1] = o, i[0] = o += s) : (i[0] = 0, i[1] = s);
}
function ts(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
ts.prototype = {
  constructor: ts,
  scale: function(e) {
    return e === 1 ? this : new ts(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new ts(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
ts.prototype;
function Al(e) {
  return (t = {}) => {
    const n = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[n] || e.formats[e.defaultWidth];
  };
}
function Ni(e) {
  return (t, n) => {
    const r = n != null && n.context ? String(n.context) : "standalone";
    let i;
    if (r === "formatting" && e.formattingValues) {
      const a = e.defaultFormattingWidth || e.defaultWidth, o = n != null && n.width ? String(n.width) : a;
      i = e.formattingValues[o] || e.formattingValues[a];
    } else {
      const a = e.defaultWidth, o = n != null && n.width ? String(n.width) : e.defaultWidth;
      i = e.values[o] || e.values[a];
    }
    const s = e.argumentCallback ? e.argumentCallback(t) : t;
    return i[s];
  };
}
function Pi(e) {
  return (t, n = {}) => {
    const r = n.width, i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(i);
    if (!s)
      return null;
    const a = s[0], o = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(o) ? AO(o, (d) => d.test(a)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      CO(o, (d) => d.test(a))
    );
    let c;
    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      n.valueCallback(c)
    ) : c;
    const u = t.slice(a.length);
    return { value: c, rest: u };
  };
}
function CO(e, t) {
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n]))
      return n;
}
function AO(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function $O(e) {
  return (t, n = {}) => {
    const r = t.match(e.matchPattern);
    if (!r)
      return null;
    const i = r[0], s = t.match(e.parsePattern);
    if (!s)
      return null;
    let a = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    a = n.valueCallback ? n.valueCallback(a) : a;
    const o = t.slice(i.length);
    return { value: a, rest: o };
  };
}
function St(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : /* @__PURE__ */ new Date(NaN);
}
let LO = {};
function Po() {
  return LO;
}
function Ss(e, t) {
  var n, r, i, s;
  const a = Po(), o = (t == null ? void 0 : t.weekStartsOn) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.weekStartsOn) ?? a.weekStartsOn ?? ((s = (i = a.locale) == null ? void 0 : i.options) == null ? void 0 : s.weekStartsOn) ?? 0, l = St(e), c = l.getDay(), u = (c < o ? 7 : 0) + c - o;
  return l.setDate(l.getDate() - u), l.setHours(0, 0, 0, 0), l;
}
const RO = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, kO = (e, t, n) => {
  let r;
  const i = RO[e];
  return typeof i == "string" ? r = i : t === 1 ? r = i.one : r = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;
}, DO = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, IO = (e, t, n, r) => DO[e], NO = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, PO = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, UO = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, BO = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, HO = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, VO = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, FO = (e, t) => {
  const n = Number(e), r = n % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, zO = {
  ordinalNumber: FO,
  era: Ni({
    values: NO,
    defaultWidth: "wide"
  }),
  quarter: Ni({
    values: PO,
    defaultWidth: "wide",
    argumentCallback: (e) => e - 1
  }),
  month: Ni({
    values: UO,
    defaultWidth: "wide"
  }),
  day: Ni({
    values: BO,
    defaultWidth: "wide"
  }),
  dayPeriod: Ni({
    values: HO,
    defaultWidth: "wide",
    formattingValues: VO,
    defaultFormattingWidth: "wide"
  })
}, GO = /^(\d+)(th|st|nd|rd)?/i, jO = /\d+/i, WO = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, qO = {
  any: [/^b/i, /^(a|c)/i]
}, YO = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, XO = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, ZO = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, KO = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, QO = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, JO = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, tT = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, eT = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, nT = {
  ordinalNumber: $O({
    matchPattern: GO,
    parsePattern: jO,
    valueCallback: (e) => parseInt(e, 10)
  }),
  era: Pi({
    matchPatterns: WO,
    defaultMatchWidth: "wide",
    parsePatterns: qO,
    defaultParseWidth: "any"
  }),
  quarter: Pi({
    matchPatterns: YO,
    defaultMatchWidth: "wide",
    parsePatterns: XO,
    defaultParseWidth: "any",
    valueCallback: (e) => e + 1
  }),
  month: Pi({
    matchPatterns: ZO,
    defaultMatchWidth: "wide",
    parsePatterns: KO,
    defaultParseWidth: "any"
  }),
  day: Pi({
    matchPatterns: QO,
    defaultMatchWidth: "wide",
    parsePatterns: JO,
    defaultParseWidth: "any"
  }),
  dayPeriod: Pi({
    matchPatterns: tT,
    defaultMatchWidth: "any",
    parsePatterns: eT,
    defaultParseWidth: "any"
  })
}, rT = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, iT = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, sT = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, aT = {
  date: Al({
    formats: rT,
    defaultWidth: "full"
  }),
  time: Al({
    formats: iT,
    defaultWidth: "full"
  }),
  dateTime: Al({
    formats: sT,
    defaultWidth: "full"
  })
}, kg = {
  code: "en-US",
  formatDistance: kO,
  formatLong: aT,
  formatRelative: IO,
  localize: zO,
  match: nT,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var Dg = typeof global == "object" && global && global.Object === Object && global, oT = typeof self == "object" && self && self.Object === Object && self, tn = Dg || oT || Function("return this")(), Be = tn.Symbol, Ig = Object.prototype, lT = Ig.hasOwnProperty, cT = Ig.toString, Ui = Be ? Be.toStringTag : void 0;
function uT(e) {
  var t = lT.call(e, Ui), n = e[Ui];
  try {
    e[Ui] = void 0;
    var r = !0;
  } catch {
  }
  var i = cT.call(e);
  return r && (t ? e[Ui] = n : delete e[Ui]), i;
}
var hT = Object.prototype, dT = hT.toString;
function fT(e) {
  return dT.call(e);
}
var pT = "[object Null]", mT = "[object Undefined]", Fd = Be ? Be.toStringTag : void 0;
function Tr(e) {
  return e == null ? e === void 0 ? mT : pT : Fd && Fd in Object(e) ? uT(e) : fT(e);
}
function dn(e) {
  return e != null && typeof e == "object";
}
var gT = "[object Symbol]";
function Uo(e) {
  return typeof e == "symbol" || dn(e) && Tr(e) == gT;
}
function Vu(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var se = Array.isArray, vT = 1 / 0, zd = Be ? Be.prototype : void 0, Gd = zd ? zd.toString : void 0;
function Ng(e) {
  if (typeof e == "string")
    return e;
  if (se(e))
    return Vu(e, Ng) + "";
  if (Uo(e))
    return Gd ? Gd.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -vT ? "-0" : t;
}
function He(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function Fu(e) {
  return e;
}
var yT = "[object AsyncFunction]", xT = "[object Function]", bT = "[object GeneratorFunction]", ET = "[object Proxy]";
function zu(e) {
  if (!He(e))
    return !1;
  var t = Tr(e);
  return t == xT || t == bT || t == yT || t == ET;
}
var $l = tn["__core-js_shared__"], jd = function() {
  var e = /[^.]+$/.exec($l && $l.keys && $l.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function _T(e) {
  return !!jd && jd in e;
}
var wT = Function.prototype, ST = wT.toString;
function Mr(e) {
  if (e != null) {
    try {
      return ST.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var OT = /[\\^$.*+?()[\]{}|]/g, TT = /^\[object .+?Constructor\]$/, MT = Function.prototype, CT = Object.prototype, AT = MT.toString, $T = CT.hasOwnProperty, LT = RegExp(
  "^" + AT.call($T).replace(OT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function RT(e) {
  if (!He(e) || _T(e))
    return !1;
  var t = zu(e) ? LT : TT;
  return t.test(Mr(e));
}
function kT(e, t) {
  return e == null ? void 0 : e[t];
}
function Cr(e, t) {
  var n = kT(e, t);
  return RT(n) ? n : void 0;
}
var Sc = Cr(tn, "WeakMap"), Wd = Object.create, DT = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!He(t))
      return {};
    if (Wd)
      return Wd(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function IT(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function NT() {
}
function Pg(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var PT = 800, UT = 16, BT = Date.now;
function HT(e) {
  var t = 0, n = 0;
  return function() {
    var r = BT(), i = UT - (r - n);
    if (n = r, i > 0) {
      if (++t >= PT)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function VT(e) {
  return function() {
    return e;
  };
}
var co = function() {
  try {
    var e = Cr(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), FT = co ? function(e, t) {
  return co(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: VT(t),
    writable: !0
  });
} : Fu;
const zT = FT;
var Ug = HT(zT);
function GT(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function jT(e, t, n, r) {
  for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function WT(e) {
  return e !== e;
}
function qT(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
function YT(e, t, n) {
  return t === t ? qT(e, t, n) : jT(e, WT, n);
}
function XT(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && YT(e, t, 0) > -1;
}
var ZT = 9007199254740991, KT = /^(?:0|[1-9]\d*)$/;
function Gu(e, t) {
  var n = typeof e;
  return t = t ?? ZT, !!t && (n == "number" || n != "symbol" && KT.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Bo(e, t, n) {
  t == "__proto__" && co ? co(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function Ps(e, t) {
  return e === t || e !== e && t !== t;
}
var QT = Object.prototype, JT = QT.hasOwnProperty;
function Bg(e, t, n) {
  var r = e[t];
  (!(JT.call(e, t) && Ps(r, n)) || n === void 0 && !(t in e)) && Bo(e, t, n);
}
function vi(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = r ? r(n[o], e[o], o, n, e) : void 0;
    l === void 0 && (l = e[o]), i ? Bo(n, o, l) : Bg(n, o, l);
  }
  return n;
}
var qd = Math.max;
function Hg(e, t, n) {
  return t = qd(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = qd(r.length - t, 0), a = Array(s); ++i < s; )
      a[i] = r[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = r[i];
    return o[t] = n(a), IT(e, this, o);
  };
}
function ju(e, t) {
  return Ug(Hg(e, t, Fu), e + "");
}
var tM = 9007199254740991;
function Wu(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= tM;
}
function Ar(e) {
  return e != null && Wu(e.length) && !zu(e);
}
function Vg(e, t, n) {
  if (!He(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? Ar(n) && Gu(t, n.length) : r == "string" && t in n) ? Ps(n[t], e) : !1;
}
function eM(e) {
  return ju(function(t, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && Vg(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {
      var o = n[r];
      o && e(t, o, r, s);
    }
    return t;
  });
}
var nM = Object.prototype;
function Ho(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || nM;
  return e === n;
}
function rM(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var iM = "[object Arguments]";
function Yd(e) {
  return dn(e) && Tr(e) == iM;
}
var Fg = Object.prototype, sM = Fg.hasOwnProperty, aM = Fg.propertyIsEnumerable, oM = Yd(/* @__PURE__ */ function() {
  return arguments;
}()) ? Yd : function(e) {
  return dn(e) && sM.call(e, "callee") && !aM.call(e, "callee");
};
const ui = oM;
function lM() {
  return !1;
}
var zg = typeof exports == "object" && exports && !exports.nodeType && exports, Xd = zg && typeof module == "object" && module && !module.nodeType && module, cM = Xd && Xd.exports === zg, Zd = cM ? tn.Buffer : void 0, uM = Zd ? Zd.isBuffer : void 0, hM = uM || lM;
const hi = hM;
var dM = "[object Arguments]", fM = "[object Array]", pM = "[object Boolean]", mM = "[object Date]", gM = "[object Error]", vM = "[object Function]", yM = "[object Map]", xM = "[object Number]", bM = "[object Object]", EM = "[object RegExp]", _M = "[object Set]", wM = "[object String]", SM = "[object WeakMap]", OM = "[object ArrayBuffer]", TM = "[object DataView]", MM = "[object Float32Array]", CM = "[object Float64Array]", AM = "[object Int8Array]", $M = "[object Int16Array]", LM = "[object Int32Array]", RM = "[object Uint8Array]", kM = "[object Uint8ClampedArray]", DM = "[object Uint16Array]", IM = "[object Uint32Array]", Ft = {};
Ft[MM] = Ft[CM] = Ft[AM] = Ft[$M] = Ft[LM] = Ft[RM] = Ft[kM] = Ft[DM] = Ft[IM] = !0;
Ft[dM] = Ft[fM] = Ft[OM] = Ft[pM] = Ft[TM] = Ft[mM] = Ft[gM] = Ft[vM] = Ft[yM] = Ft[xM] = Ft[bM] = Ft[EM] = Ft[_M] = Ft[wM] = Ft[SM] = !1;
function NM(e) {
  return dn(e) && Wu(e.length) && !!Ft[Tr(e)];
}
function qu(e) {
  return function(t) {
    return e(t);
  };
}
var Gg = typeof exports == "object" && exports && !exports.nodeType && exports, hs = Gg && typeof module == "object" && module && !module.nodeType && module, PM = hs && hs.exports === Gg, Ll = PM && Dg.process, di = function() {
  try {
    var e = hs && hs.require && hs.require("util").types;
    return e || Ll && Ll.binding && Ll.binding("util");
  } catch {
  }
}(), Kd = di && di.isTypedArray, UM = Kd ? qu(Kd) : NM;
const Vo = UM;
var BM = Object.prototype, HM = BM.hasOwnProperty;
function jg(e, t) {
  var n = se(e), r = !n && ui(e), i = !n && !r && hi(e), s = !n && !r && !i && Vo(e), a = n || r || i || s, o = a ? rM(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || HM.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Gu(c, l))) && o.push(c);
  return o;
}
function Wg(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var VM = Wg(Object.keys, Object), FM = Object.prototype, zM = FM.hasOwnProperty;
function qg(e) {
  if (!Ho(e))
    return VM(e);
  var t = [];
  for (var n in Object(e))
    zM.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function Us(e) {
  return Ar(e) ? jg(e) : qg(e);
}
function GM(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var jM = Object.prototype, WM = jM.hasOwnProperty;
function qM(e) {
  if (!He(e))
    return GM(e);
  var t = Ho(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !WM.call(e, r)) || n.push(r);
  return n;
}
function Bs(e) {
  return Ar(e) ? jg(e, !0) : qM(e);
}
var YM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, XM = /^\w*$/;
function Yu(e, t) {
  if (se(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Uo(e) ? !0 : XM.test(e) || !YM.test(e) || t != null && e in Object(t);
}
var Os = Cr(Object, "create");
function ZM() {
  this.__data__ = Os ? Os(null) : {}, this.size = 0;
}
function KM(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var QM = "__lodash_hash_undefined__", JM = Object.prototype, tC = JM.hasOwnProperty;
function eC(e) {
  var t = this.__data__;
  if (Os) {
    var n = t[e];
    return n === QM ? void 0 : n;
  }
  return tC.call(t, e) ? t[e] : void 0;
}
var nC = Object.prototype, rC = nC.hasOwnProperty;
function iC(e) {
  var t = this.__data__;
  return Os ? t[e] !== void 0 : rC.call(t, e);
}
var sC = "__lodash_hash_undefined__";
function aC(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Os && t === void 0 ? sC : t, this;
}
function _r(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
_r.prototype.clear = ZM;
_r.prototype.delete = KM;
_r.prototype.get = eC;
_r.prototype.has = iC;
_r.prototype.set = aC;
function oC() {
  this.__data__ = [], this.size = 0;
}
function Fo(e, t) {
  for (var n = e.length; n--; )
    if (Ps(e[n][0], t))
      return n;
  return -1;
}
var lC = Array.prototype, cC = lC.splice;
function uC(e) {
  var t = this.__data__, n = Fo(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : cC.call(t, n, 1), --this.size, !0;
}
function hC(e) {
  var t = this.__data__, n = Fo(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function dC(e) {
  return Fo(this.__data__, e) > -1;
}
function fC(e, t) {
  var n = this.__data__, r = Fo(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function Pn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Pn.prototype.clear = oC;
Pn.prototype.delete = uC;
Pn.prototype.get = hC;
Pn.prototype.has = dC;
Pn.prototype.set = fC;
var Ts = Cr(tn, "Map");
function pC() {
  this.size = 0, this.__data__ = {
    hash: new _r(),
    map: new (Ts || Pn)(),
    string: new _r()
  };
}
function mC(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function zo(e, t) {
  var n = e.__data__;
  return mC(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function gC(e) {
  var t = zo(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function vC(e) {
  return zo(this, e).get(e);
}
function yC(e) {
  return zo(this, e).has(e);
}
function xC(e, t) {
  var n = zo(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function Un(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Un.prototype.clear = pC;
Un.prototype.delete = gC;
Un.prototype.get = vC;
Un.prototype.has = yC;
Un.prototype.set = xC;
var bC = "Expected a function";
function Xu(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(bC);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, r);
    return n.cache = s.set(i, a) || s, a;
  };
  return n.cache = new (Xu.Cache || Un)(), n;
}
Xu.Cache = Un;
var EC = 500;
function _C(e) {
  var t = Xu(e, function(r) {
    return n.size === EC && n.clear(), r;
  }), n = t.cache;
  return t;
}
var wC = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, SC = /\\(\\)?/g, OC = _C(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(wC, function(n, r, i, s) {
    t.push(i ? s.replace(SC, "$1") : r || n);
  }), t;
});
function Hs(e) {
  return e == null ? "" : Ng(e);
}
function Go(e, t) {
  return se(e) ? e : Yu(e, t) ? [e] : OC(Hs(e));
}
var TC = 1 / 0;
function Vs(e) {
  if (typeof e == "string" || Uo(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -TC ? "-0" : t;
}
function Zu(e, t) {
  t = Go(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[Vs(t[n++])];
  return n && n == r ? e : void 0;
}
function _t(e, t, n) {
  var r = e == null ? void 0 : Zu(e, t);
  return r === void 0 ? n : r;
}
function Ku(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var Qd = Be ? Be.isConcatSpreadable : void 0;
function MC(e) {
  return se(e) || ui(e) || !!(Qd && e && e[Qd]);
}
function jo(e, t, n, r, i) {
  var s = -1, a = e.length;
  for (n || (n = MC), i || (i = []); ++s < a; ) {
    var o = e[s];
    t > 0 && n(o) ? t > 1 ? jo(o, t - 1, n, r, i) : Ku(i, o) : r || (i[i.length] = o);
  }
  return i;
}
var CC = Wg(Object.getPrototypeOf, Object);
const Qu = CC;
var AC = "[object Object]", $C = Function.prototype, LC = Object.prototype, Yg = $C.toString, RC = LC.hasOwnProperty, kC = Yg.call(Object);
function Xg(e) {
  if (!dn(e) || Tr(e) != AC)
    return !1;
  var t = Qu(e);
  if (t === null)
    return !0;
  var n = RC.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && Yg.call(n) == kC;
}
function DC() {
  this.__data__ = new Pn(), this.size = 0;
}
function IC(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function NC(e) {
  return this.__data__.get(e);
}
function PC(e) {
  return this.__data__.has(e);
}
var UC = 200;
function BC(e, t) {
  var n = this.__data__;
  if (n instanceof Pn) {
    var r = n.__data__;
    if (!Ts || r.length < UC - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Un(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Xe(e) {
  var t = this.__data__ = new Pn(e);
  this.size = t.size;
}
Xe.prototype.clear = DC;
Xe.prototype.delete = IC;
Xe.prototype.get = NC;
Xe.prototype.has = PC;
Xe.prototype.set = BC;
function HC(e, t) {
  return e && vi(t, Us(t), e);
}
function VC(e, t) {
  return e && vi(t, Bs(t), e);
}
var Zg = typeof exports == "object" && exports && !exports.nodeType && exports, Jd = Zg && typeof module == "object" && module && !module.nodeType && module, FC = Jd && Jd.exports === Zg, tf = FC ? tn.Buffer : void 0, ef = tf ? tf.allocUnsafe : void 0;
function Kg(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = ef ? ef(n) : new e.constructor(n);
  return e.copy(r), r;
}
function zC(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
function Qg() {
  return [];
}
var GC = Object.prototype, jC = GC.propertyIsEnumerable, nf = Object.getOwnPropertySymbols, Ju = nf ? function(e) {
  return e == null ? [] : (e = Object(e), zC(nf(e), function(t) {
    return jC.call(e, t);
  }));
} : Qg;
function WC(e, t) {
  return vi(e, Ju(e), t);
}
var qC = Object.getOwnPropertySymbols, Jg = qC ? function(e) {
  for (var t = []; e; )
    Ku(t, Ju(e)), e = Qu(e);
  return t;
} : Qg;
function YC(e, t) {
  return vi(e, Jg(e), t);
}
function tv(e, t, n) {
  var r = t(e);
  return se(e) ? r : Ku(r, n(e));
}
function Oc(e) {
  return tv(e, Us, Ju);
}
function ev(e) {
  return tv(e, Bs, Jg);
}
var Tc = Cr(tn, "DataView"), Mc = Cr(tn, "Promise"), Jr = Cr(tn, "Set"), rf = "[object Map]", XC = "[object Object]", sf = "[object Promise]", af = "[object Set]", of = "[object WeakMap]", lf = "[object DataView]", ZC = Mr(Tc), KC = Mr(Ts), QC = Mr(Mc), JC = Mr(Jr), tA = Mr(Sc), or = Tr;
(Tc && or(new Tc(new ArrayBuffer(1))) != lf || Ts && or(new Ts()) != rf || Mc && or(Mc.resolve()) != sf || Jr && or(new Jr()) != af || Sc && or(new Sc()) != of) && (or = function(e) {
  var t = Tr(e), n = t == XC ? e.constructor : void 0, r = n ? Mr(n) : "";
  if (r)
    switch (r) {
      case ZC:
        return lf;
      case KC:
        return rf;
      case QC:
        return sf;
      case JC:
        return af;
      case tA:
        return of;
    }
  return t;
});
const fi = or;
var eA = Object.prototype, nA = eA.hasOwnProperty;
function rA(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && nA.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var uo = tn.Uint8Array;
function th(e) {
  var t = new e.constructor(e.byteLength);
  return new uo(t).set(new uo(e)), t;
}
function iA(e, t) {
  var n = t ? th(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var sA = /\w*$/;
function aA(e) {
  var t = new e.constructor(e.source, sA.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var cf = Be ? Be.prototype : void 0, uf = cf ? cf.valueOf : void 0;
function oA(e) {
  return uf ? Object(uf.call(e)) : {};
}
function nv(e, t) {
  var n = t ? th(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var lA = "[object Boolean]", cA = "[object Date]", uA = "[object Map]", hA = "[object Number]", dA = "[object RegExp]", fA = "[object Set]", pA = "[object String]", mA = "[object Symbol]", gA = "[object ArrayBuffer]", vA = "[object DataView]", yA = "[object Float32Array]", xA = "[object Float64Array]", bA = "[object Int8Array]", EA = "[object Int16Array]", _A = "[object Int32Array]", wA = "[object Uint8Array]", SA = "[object Uint8ClampedArray]", OA = "[object Uint16Array]", TA = "[object Uint32Array]";
function MA(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case gA:
      return th(e);
    case lA:
    case cA:
      return new r(+e);
    case vA:
      return iA(e, n);
    case yA:
    case xA:
    case bA:
    case EA:
    case _A:
    case wA:
    case SA:
    case OA:
    case TA:
      return nv(e, n);
    case uA:
      return new r();
    case hA:
    case pA:
      return new r(e);
    case dA:
      return aA(e);
    case fA:
      return new r();
    case mA:
      return oA(e);
  }
}
function rv(e) {
  return typeof e.constructor == "function" && !Ho(e) ? DT(Qu(e)) : {};
}
var CA = "[object Map]";
function AA(e) {
  return dn(e) && fi(e) == CA;
}
var hf = di && di.isMap, $A = hf ? qu(hf) : AA, LA = "[object Set]";
function RA(e) {
  return dn(e) && fi(e) == LA;
}
var df = di && di.isSet, kA = df ? qu(df) : RA, DA = 1, IA = 2, NA = 4, iv = "[object Arguments]", PA = "[object Array]", UA = "[object Boolean]", BA = "[object Date]", HA = "[object Error]", sv = "[object Function]", VA = "[object GeneratorFunction]", FA = "[object Map]", zA = "[object Number]", av = "[object Object]", GA = "[object RegExp]", jA = "[object Set]", WA = "[object String]", qA = "[object Symbol]", YA = "[object WeakMap]", XA = "[object ArrayBuffer]", ZA = "[object DataView]", KA = "[object Float32Array]", QA = "[object Float64Array]", JA = "[object Int8Array]", t2 = "[object Int16Array]", e2 = "[object Int32Array]", n2 = "[object Uint8Array]", r2 = "[object Uint8ClampedArray]", i2 = "[object Uint16Array]", s2 = "[object Uint32Array]", Ut = {};
Ut[iv] = Ut[PA] = Ut[XA] = Ut[ZA] = Ut[UA] = Ut[BA] = Ut[KA] = Ut[QA] = Ut[JA] = Ut[t2] = Ut[e2] = Ut[FA] = Ut[zA] = Ut[av] = Ut[GA] = Ut[jA] = Ut[WA] = Ut[qA] = Ut[n2] = Ut[r2] = Ut[i2] = Ut[s2] = !0;
Ut[HA] = Ut[sv] = Ut[YA] = !1;
function ds(e, t, n, r, i, s) {
  var a, o = t & DA, l = t & IA, c = t & NA;
  if (n && (a = i ? n(e, r, i, s) : n(e)), a !== void 0)
    return a;
  if (!He(e))
    return e;
  var u = se(e);
  if (u) {
    if (a = rA(e), !o)
      return Pg(e, a);
  } else {
    var d = fi(e), h = d == sv || d == VA;
    if (hi(e))
      return Kg(e, o);
    if (d == av || d == iv || h && !i) {
      if (a = l || h ? {} : rv(e), !o)
        return l ? YC(e, VC(a, e)) : WC(e, HC(a, e));
    } else {
      if (!Ut[d])
        return i ? e : {};
      a = MA(e, d, o);
    }
  }
  s || (s = new Xe());
  var f = s.get(e);
  if (f)
    return f;
  s.set(e, a), kA(e) ? e.forEach(function(m) {
    a.add(ds(m, t, n, m, e, s));
  }) : $A(e) && e.forEach(function(m, y) {
    a.set(y, ds(m, t, n, y, e, s));
  });
  var p = c ? l ? ev : Oc : l ? Bs : Us, v = u ? void 0 : p(e);
  return GT(v || e, function(m, y) {
    v && (y = m, m = e[y]), Bg(a, y, ds(m, t, n, y, e, s));
  }), a;
}
var a2 = 1, o2 = 4;
function In(e) {
  return ds(e, a2 | o2);
}
var l2 = "__lodash_hash_undefined__";
function c2(e) {
  return this.__data__.set(e, l2), this;
}
function u2(e) {
  return this.__data__.has(e);
}
function Ms(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Un(); ++t < n; )
    this.add(e[t]);
}
Ms.prototype.add = Ms.prototype.push = c2;
Ms.prototype.has = u2;
function ov(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function lv(e, t) {
  return e.has(t);
}
var h2 = 1, d2 = 2;
function cv(e, t, n, r, i, s) {
  var a = n & h2, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var d = -1, h = !0, f = n & d2 ? new Ms() : void 0;
  for (s.set(e, t), s.set(t, e); ++d < o; ) {
    var p = e[d], v = t[d];
    if (r)
      var m = a ? r(v, p, d, t, e, s) : r(p, v, d, e, t, s);
    if (m !== void 0) {
      if (m)
        continue;
      h = !1;
      break;
    }
    if (f) {
      if (!ov(t, function(y, g) {
        if (!lv(f, g) && (p === y || i(p, y, n, r, s)))
          return f.push(g);
      })) {
        h = !1;
        break;
      }
    } else if (!(p === v || i(p, v, n, r, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), h;
}
function f2(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function eh(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var p2 = 1, m2 = 2, g2 = "[object Boolean]", v2 = "[object Date]", y2 = "[object Error]", x2 = "[object Map]", b2 = "[object Number]", E2 = "[object RegExp]", _2 = "[object Set]", w2 = "[object String]", S2 = "[object Symbol]", O2 = "[object ArrayBuffer]", T2 = "[object DataView]", ff = Be ? Be.prototype : void 0, Rl = ff ? ff.valueOf : void 0;
function M2(e, t, n, r, i, s, a) {
  switch (n) {
    case T2:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case O2:
      return !(e.byteLength != t.byteLength || !s(new uo(e), new uo(t)));
    case g2:
    case v2:
    case b2:
      return Ps(+e, +t);
    case y2:
      return e.name == t.name && e.message == t.message;
    case E2:
    case w2:
      return e == t + "";
    case x2:
      var o = f2;
    case _2:
      var l = r & p2;
      if (o || (o = eh), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= m2, a.set(e, t);
      var u = cv(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case S2:
      if (Rl)
        return Rl.call(e) == Rl.call(t);
  }
  return !1;
}
var C2 = 1, A2 = Object.prototype, $2 = A2.hasOwnProperty;
function L2(e, t, n, r, i, s) {
  var a = n & C2, o = Oc(e), l = o.length, c = Oc(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var d = l; d--; ) {
    var h = o[d];
    if (!(a ? h in t : $2.call(t, h)))
      return !1;
  }
  var f = s.get(e), p = s.get(t);
  if (f && p)
    return f == t && p == e;
  var v = !0;
  s.set(e, t), s.set(t, e);
  for (var m = a; ++d < l; ) {
    h = o[d];
    var y = e[h], g = t[h];
    if (r)
      var b = a ? r(g, y, h, t, e, s) : r(y, g, h, e, t, s);
    if (!(b === void 0 ? y === g || i(y, g, n, r, s) : b)) {
      v = !1;
      break;
    }
    m || (m = h == "constructor");
  }
  if (v && !m) {
    var w = e.constructor, _ = t.constructor;
    w != _ && "constructor" in e && "constructor" in t && !(typeof w == "function" && w instanceof w && typeof _ == "function" && _ instanceof _) && (v = !1);
  }
  return s.delete(e), s.delete(t), v;
}
var R2 = 1, pf = "[object Arguments]", mf = "[object Array]", la = "[object Object]", k2 = Object.prototype, gf = k2.hasOwnProperty;
function D2(e, t, n, r, i, s) {
  var a = se(e), o = se(t), l = a ? mf : fi(e), c = o ? mf : fi(t);
  l = l == pf ? la : l, c = c == pf ? la : c;
  var u = l == la, d = c == la, h = l == c;
  if (h && hi(e)) {
    if (!hi(t))
      return !1;
    a = !0, u = !1;
  }
  if (h && !u)
    return s || (s = new Xe()), a || Vo(e) ? cv(e, t, n, r, i, s) : M2(e, t, l, n, r, i, s);
  if (!(n & R2)) {
    var f = u && gf.call(e, "__wrapped__"), p = d && gf.call(t, "__wrapped__");
    if (f || p) {
      var v = f ? e.value() : e, m = p ? t.value() : t;
      return s || (s = new Xe()), i(v, m, n, r, s);
    }
  }
  return h ? (s || (s = new Xe()), L2(e, t, n, r, i, s)) : !1;
}
function Wo(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !dn(e) && !dn(t) ? e !== e && t !== t : D2(e, t, n, r, Wo, i);
}
var I2 = 1, N2 = 2;
function P2(e, t, n, r) {
  var i = n.length, s = i, a = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var o = n[i];
    if (a && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    o = n[i];
    var l = o[0], c = e[l], u = o[1];
    if (a && o[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var d = new Xe();
      if (r)
        var h = r(c, u, l, e, t, d);
      if (!(h === void 0 ? Wo(u, c, I2 | N2, r, d) : h))
        return !1;
    }
  }
  return !0;
}
function uv(e) {
  return e === e && !He(e);
}
function U2(e) {
  for (var t = Us(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, uv(i)];
  }
  return t;
}
function hv(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function B2(e) {
  var t = U2(e);
  return t.length == 1 && t[0][2] ? hv(t[0][0], t[0][1]) : function(n) {
    return n === e || P2(n, e, t);
  };
}
function H2(e, t) {
  return e != null && t in Object(e);
}
function V2(e, t, n) {
  t = Go(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var a = Vs(t[r]);
    if (!(s = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && Wu(i) && Gu(a, i) && (se(e) || ui(e)));
}
function F2(e, t) {
  return e != null && V2(e, t, H2);
}
var z2 = 1, G2 = 2;
function j2(e, t) {
  return Yu(e) && uv(t) ? hv(Vs(e), t) : function(n) {
    var r = _t(n, e);
    return r === void 0 && r === t ? F2(n, e) : Wo(t, r, z2 | G2);
  };
}
function W2(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function q2(e) {
  return function(t) {
    return Zu(t, e);
  };
}
function Y2(e) {
  return Yu(e) ? W2(Vs(e)) : q2(e);
}
function qo(e) {
  return typeof e == "function" ? e : e == null ? Fu : typeof e == "object" ? se(e) ? j2(e[0], e[1]) : B2(e) : Y2(e);
}
function X2(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {
      var l = a[e ? o : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var dv = X2();
function Cc(e, t, n) {
  (n !== void 0 && !Ps(e[t], n) || n === void 0 && !(t in e)) && Bo(e, t, n);
}
function Ac(e) {
  return dn(e) && Ar(e);
}
function $c(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function Z2(e) {
  return vi(e, Bs(e));
}
function K2(e, t, n, r, i, s, a) {
  var o = $c(e, n), l = $c(t, n), c = a.get(l);
  if (c) {
    Cc(e, n, c);
    return;
  }
  var u = s ? s(o, l, n + "", e, t, a) : void 0, d = u === void 0;
  if (d) {
    var h = se(l), f = !h && hi(l), p = !h && !f && Vo(l);
    u = l, h || f || p ? se(o) ? u = o : Ac(o) ? u = Pg(o) : f ? (d = !1, u = Kg(l, !0)) : p ? (d = !1, u = nv(l, !0)) : u = [] : Xg(l) || ui(l) ? (u = o, ui(o) ? u = Z2(o) : (!He(o) || zu(o)) && (u = rv(l))) : d = !1;
  }
  d && (a.set(l, u), i(u, l, r, s, a), a.delete(l)), Cc(e, n, u);
}
function fv(e, t, n, r, i) {
  e !== t && dv(t, function(s, a) {
    if (i || (i = new Xe()), He(s))
      K2(e, t, a, n, fv, r, i);
    else {
      var o = r ? r($c(e, a), s, a + "", e, t, i) : void 0;
      o === void 0 && (o = s), Cc(e, a, o);
    }
  }, Bs);
}
function Q2(e, t, n) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (n(t, e[r]))
      return !0;
  return !1;
}
function pv(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var J2 = "[object Map]", t$ = "[object Set]", e$ = Object.prototype, n$ = e$.hasOwnProperty;
function We(e) {
  if (e == null)
    return !0;
  if (Ar(e) && (se(e) || typeof e == "string" || typeof e.splice == "function" || hi(e) || Vo(e) || ui(e)))
    return !e.length;
  var t = fi(e);
  if (t == J2 || t == t$)
    return !e.size;
  if (Ho(e))
    return !qg(e).length;
  for (var n in e)
    if (n$.call(e, n))
      return !1;
  return !0;
}
var r$ = eM(function(e, t, n) {
  fv(e, t, n);
});
const ct = r$;
var i$ = 1 / 0, s$ = Jr && 1 / eh(new Jr([, -0]))[1] == i$ ? function(e) {
  return new Jr(e);
} : NT, a$ = 200;
function mv(e, t, n) {
  var r = -1, i = XT, s = e.length, a = !0, o = [], l = o;
  if (n)
    a = !1, i = Q2;
  else if (s >= a$) {
    var c = t ? null : s$(e);
    if (c)
      return eh(c);
    a = !1, i = lv, l = new Ms();
  } else
    l = t ? [] : o;
  t:
    for (; ++r < s; ) {
      var u = e[r], d = t ? t(u) : u;
      if (u = n || u !== 0 ? u : 0, a && d === d) {
        for (var h = l.length; h--; )
          if (l[h] === d)
            continue t;
        t && l.push(d), o.push(u);
      } else
        i(l, d, n) || (l !== o && l.push(d), o.push(u));
    }
  return o;
}
var o$ = ju(function(e) {
  var t = pv(e);
  return Ac(t) && (t = void 0), mv(jo(e, 1, Ac, !0), qo(t));
});
function Cs(e) {
  return e && e.length ? mv(e) : [];
}
const ve = "cds", On = {
  opacity: {
    unselected: 0.05,
    selected: 0.4
  }
}, Xn = {
  ticks: {
    number: 7,
    rotateIfSmallerThan: 30,
    verticalSpaceRatio: 2.5,
    horizontalSpaceRatio: 3.5
  },
  ratio: {
    reference: "value",
    compareTo: "marker"
  },
  paddingRatio: 0.1,
  hover: {
    rectanglePadding: 4
  }
}, Zr = {
  duration: 1e3,
  ease: Cm,
  zoomLevel: 3
}, Fr = {
  circles: {
    fillOpacity: 0.3,
    hover: {
      stroke: "#FFF"
    }
  },
  padding: {
    mainGroup: 4,
    children: 2
  },
  hierarchyLevel: 2
}, gv = {
  pairingOptions: {
    "1-color": 4,
    "2-color": 5,
    "3-color": 5,
    "4-color": 3,
    "5-color": 2,
    "14-color": 1
  }
}, De = {
  circle: {
    radius: 4,
    opacity: {
      hovered: 1,
      default: 0.3
    }
  },
  box: {
    opacity: {
      hovered: 0.5,
      default: 0.3
    }
  },
  strokeWidth: {
    default: 1,
    thicker: 2
  }
}, l$ = {
  defaultBins: 10
}, qt = {
  items: {
    status: {
      ACTIVE: 1,
      DISABLED: 0
    },
    horizontalSpace: 12,
    verticalSpace: 24,
    textYOffset: 8,
    spaceAfter: 4
  },
  checkbox: {
    radius: 6.5
  },
  radius: {
    iconData: [
      { cx: 7, cy: 7, r: 6.5 },
      { cx: 7, cy: 10, r: 3.5 }
    ],
    fill: null,
    stroke: "#8c8c8c"
  },
  line: {
    yPosition: 6,
    width: 24,
    strokeWidth: 1.4,
    fill: null,
    stroke: "#999999"
  },
  area: {
    width: 24,
    height: 14,
    fill: "#6f6f6f",
    stroke: null
  },
  size: {
    iconData: [
      { width: 23, height: 12 },
      { width: 13, height: 6 }
    ],
    fill: null,
    stroke: "#8D8D8D"
  },
  quartile: {
    iconData: [
      { x: 0, y: 0, width: 24, height: 13 },
      { x: 11, y: 4, width: 1, height: 4 }
    ]
  },
  zoom: {
    iconData: [{ x: 0, y: 0, width: 12, height: 12 }],
    color: "#8D8D8D"
  },
  color: {
    barWidth: 300,
    barHeight: 8,
    axisYTranslation: 10
  }
}, wn = {
  opacity: {
    unselected: 0.3,
    selected: 1
  },
  weight: {
    selected: 2,
    unselected: 1
  }
}, ie = {
  statusBar: {
    paddingRight: 5
  },
  status: {
    indicatorSize: 16,
    paddingLeft: 15
  },
  total: {
    paddingLeft: 36,
    paddingRight: 24
  },
  height: {
    default: 8,
    proportional: 16
  },
  dividerWidth: 2
}, Bt = {
  radiusOffset: -15,
  innerRadius: 2,
  padAngle: 7e-3,
  hoverArc: {
    outerRadiusOffset: 3
  },
  xOffset: 30,
  yOffset: 20,
  yOffsetCallout: 10,
  callout: {
    minSliceDegree: 5,
    offsetX: 15,
    offsetY: 12,
    horizontalLineLength: 8,
    textMargin: 2
  }
}, sr = {
  opacity: {
    unselected: 0.1,
    selected: 0.3
  },
  xLabelPadding: 10,
  yLabelPadding: 8,
  yTicksNumber: 4,
  minRange: 10,
  xAxisRectHeight: 50,
  dotsRadius: 5
}, ze = {
  nodeWidth: 4,
  nodeHoveredWidth: 8,
  minNodePadding: 24,
  opacity: {
    unfocus: 0.3,
    default: 0.8,
    selected: 1
  }
}, vf = {
  minCellDividerDimension: 16,
  // Ensures axes lines are displayed with or without stroke disabled
  chartPadding: 0.5
}, yf = {
  default: {
    size: 24
  }
}, c$ = {
  defaultOffset: 4,
  horizontalOffset: 10
}, xf = {
  default: {
    duration: 300
  },
  pie_slice_mouseover: {
    duration: 100
  },
  pie_slice_mouseout: {
    duration: 100
  },
  pie_chart_titles: {
    duration: 375
  },
  graph_element_mouseover_fill_update: {
    duration: 100
  },
  graph_element_mouseout_fill_update: {
    duration: 100
  }
}, Te = {
  height: {
    [an.GRAPH_VIEW]: 32,
    [an.SLIDER_VIEW]: 10
  },
  spacerHeight: 8,
  handleWidth: 5,
  handleBarWidth: 1,
  handleBarHeight: 12
}, u$ = [
  {
    type: Qt.RADIUS,
    name: "Radius"
  },
  {
    type: Qt.AREA,
    name: "Poor area"
  },
  {
    type: Qt.AREA,
    name: "Satisfactory area"
  },
  {
    type: Qt.AREA,
    name: "Great area"
  },
  {
    type: Qt.QUARTILE,
    name: "Quartiles"
  }
], Kr = {
  type: qe.END_LINE,
  threshold: 16,
  numCharacter: 14
}, h$ = {
  code: typeof navigator < "u" && (navigator == null ? void 0 : navigator.language) || "en-US",
  // read from browser's navigator.language
  number: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US") => e.toLocaleString(t),
  // based on code property if specified
  date: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US", n = {}, r = null) => r || e.toLocaleDateString(t, n),
  // based on code property if specified
  time: (e, t = (navigator == null ? void 0 : navigator.language) || "en-US", n = {}, r = null) => r || e.toLocaleTimeString(t, n),
  // based on code property if specified
  optionsObject: {
    "15seconds": {
      primary: {
        "MMM d, pp": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
          hourCycle: "h12"
        },
        "MMM d, h:mm:ss.SSS a": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          fractionalSecondDigits: 3,
          hourCycle: "h12"
        }
      },
      secondary: {
        pp: {
          hour: "numeric",
          minute: "2-digit",
          second: "2-digit",
          hourCycle: "h12"
        },
        "h:mm:ss.SSS a": {
          hour: "numeric",
          minute: "2-digit",
          fractionalSecondDigits: 3,
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    minute: {
      primary: {
        "MMM d, p": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        p: {
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    "30minutes": {
      primary: {
        "MMM d, p": {
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        p: {
          hour: "numeric",
          minute: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    hourly: {
      primary: {
        "MMM d, hh a": {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          hourCycle: "h12"
        }
      },
      secondary: {
        "hh a": {
          hour: "2-digit",
          hourCycle: "h12"
        }
      },
      type: "time"
    },
    daily: {
      primary: {
        "MMM d": {
          month: "short",
          day: "numeric"
        }
      },
      secondary: {
        d: {
          day: "numeric"
        }
      },
      type: "date"
    },
    weekly: {
      primary: {
        "eee, MMM d": {
          weekday: "short",
          month: "short",
          day: "numeric"
        }
      },
      secondary: {
        eee: {
          weekday: "short"
        }
      },
      type: "date"
    },
    monthly: {
      primary: {
        "MMM yyyy": {
          month: "short",
          year: "numeric"
        }
      },
      secondary: {
        MMM: {
          month: "short"
        }
      },
      type: "date"
    },
    quarterly: {
      primary: {},
      secondary: {},
      type: "date"
    },
    yearly: {
      primary: {
        yyyy: {
          year: "numeric"
        }
      },
      secondary: {
        yyyy: {
          year: "numeric"
        }
      },
      type: "date"
    }
  },
  translations: {
    group: "Group",
    total: "Total",
    meter: {
      title: ""
      //default is emply string as meter title is dataset label
    },
    tabularRep: {
      title: "Tabular representation",
      downloadAsCSV: "Download as CSV"
    },
    toolbar: {
      exportAsCSV: "Export to CSV",
      exportAsJPG: "Export to JPG",
      exportAsPNG: "Export to PNG",
      zoomIn: "Zoom in",
      zoomOut: "Zoom out",
      resetZoom: "Reset zoom",
      moreOptions: "More options",
      makeFullScreen: "Make fullscreen",
      exitFullScreen: "Exit fullscreen",
      showAsTable: "Show as table"
    }
  }
}, d$ = {
  enabled: !0,
  position: ss.BOTTOM,
  clickable: !0,
  truncation: Kr,
  alignment: ee.LEFT,
  order: null,
  additionalItems: []
}, f$ = {
  x: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 15,
    alignWithAxisTicks: !1
  },
  y: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 5,
    alignWithAxisTicks: !1
  }
}, p$ = {
  // enable or disable ruler
  enabled: !0
}, vv = {
  enabled: !0,
  showTotal: !0,
  truncation: Kr,
  groupLabel: "Group"
}, yv = {
  top: {
    visible: !0,
    includeZero: !0,
    truncation: Kr
  },
  bottom: {
    visible: !0,
    includeZero: !0,
    truncation: Kr
  },
  left: {
    visible: !0,
    includeZero: !0,
    truncation: Kr
  },
  right: {
    visible: !0,
    includeZero: !0,
    truncation: Kr
  }
}, Yo = {
  addSpaceOnEdges: 1,
  showDayName: !1,
  localeObject: kg,
  timeIntervalFormats: {
    "15seconds": { primary: "MMM d, pp", secondary: "pp" },
    minute: { primary: "MMM d, p", secondary: "p" },
    "30minutes": { primary: "MMM d, p", secondary: "p" },
    hourly: { primary: "MMM d, hh a", secondary: "hh a" },
    daily: { primary: "MMM d", secondary: "d" },
    weekly: { primary: "eee, MMM d", secondary: "eee" },
    monthly: { primary: "MMM yyyy", secondary: "MMM" },
    quarterly: { primary: "QQQ ''yy", secondary: "QQQ" },
    yearly: { primary: "yyyy", secondary: "yyyy" }
  }
};
let xv = !1;
try {
  xv = typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
} catch (e) {
  console.warn("Fullscreen capabilities check failed: ", e.message);
}
const ue = {
  width: null,
  height: null,
  resizable: !0,
  theme: Kp.WHITE,
  tooltip: vv,
  legend: d$,
  locale: h$,
  style: {
    prefix: "cc"
  },
  data: {
    groupMapsTo: "group",
    loading: !1,
    selectedGroups: []
  },
  color: {
    scale: null,
    pairing: {
      numberOfVariants: null,
      option: 1
    },
    gradient: {
      enabled: !1
    }
  },
  toolbar: {
    enabled: !0,
    numberOfIcons: 3,
    controls: [
      {
        type: $t.SHOW_AS_DATATABLE
      },
      ...xv ? [
        {
          type: $t.MAKE_FULLSCREEN
        }
      ] : [],
      {
        type: $t.EXPORT_CSV
      },
      {
        type: $t.EXPORT_PNG
      },
      {
        type: $t.EXPORT_JPG
      }
    ]
  }
}, bv = ct({}, ue, {
  thematic: {
    projection: _n.geoNaturalEarth1
  }
}), Fs = ct({}, ue, {
  axes: yv,
  timeScale: Yo,
  grid: f$,
  ruler: p$,
  zoomBar: {
    zoomRatio: 0.4,
    minZoomRatio: 0.01,
    top: {
      enabled: !1,
      type: an.GRAPH_VIEW
    }
  }
}), wr = ct({}, Fs, {
  bars: {
    maxWidth: 16,
    spacingFactor: 0.25
  },
  timeScale: ct(Yo, {
    addSpaceOnEdges: 1
  })
}), m$ = ct({}, wr, {}), g$ = ct({}, wr, {}), v$ = ct({}, wr, {
  bars: ct({}, wr.bars, {
    dividerSize: 1.5
  })
}), y$ = ct({}, wr, {}), nh = ct({}, Fs, {
  points: {
    // default point radius to 4
    radius: 4,
    fillOpacity: 0.3,
    filled: !0,
    enabled: !0
  }
}), x$ = nh, Ev = ct({}, nh, {
  points: {
    // default point radius to 3
    radius: 3,
    filled: !1,
    enabled: !0
  }
}), _v = ct({}, Ev, {
  timeScale: ct(Yo, {
    addSpaceOnEdges: 0
  })
}), b$ = _v, E$ = ct({}, Fs, {
  bubble: {
    radiusMapsTo: "radius",
    radiusLabel: "Radius",
    radiusRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 3 / 400, t * 25 / 400];
    },
    fillOpacity: 0.2,
    enabled: !0
  },
  points: {
    filled: !0
  },
  legend: {
    additionalItems: [
      {
        type: Qt.RADIUS,
        name: "Radius"
      }
    ]
  }
}), _$ = ct({}, Fs, {
  bullet: {
    performanceAreaTitles: ["Poor", "Satisfactory", "Great"]
  },
  grid: {
    x: {
      enabled: !1
    },
    y: {
      enabled: !1
    }
  },
  legend: {
    additionalItems: [
      {
        type: Qt.AREA,
        name: "Poor area"
      },
      {
        type: Qt.AREA,
        name: "Satisfactory area"
      },
      {
        type: Qt.AREA,
        name: "Great area"
      },
      {
        type: Qt.QUARTILE,
        name: "Quartiles"
      }
    ]
  }
}), w$ = ct({}, wr, {
  bars: {
    dividerSize: 1.5
  },
  timeScale: ct(Yo, {
    addSpaceOnEdges: 0
  })
}), S$ = ct({}, ue, {
  tooltip: ct({}, vv, {
    wordLabel: "Word",
    valueLabel: "Value"
  }),
  wordCloud: {
    fontSizeMapsTo: "value",
    fontSizeRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 20 / 400, t * 75 / 400];
    },
    wordMapsTo: "word"
  }
}), wv = ct({}, ue, {
  pie: {
    labels: {
      formatter: null,
      enabled: !0
    },
    alignment: ee.LEFT,
    sortFunction: null,
    valueMapsTo: "value"
  }
}), O$ = ct({}, ue, {
  legend: {
    enabled: !1
  },
  gauge: {
    type: jr.SEMI,
    arcWidth: 16,
    deltaArrow: {
      size: (e) => e / 8,
      enabled: !0
    },
    showPercentageSymbol: !0,
    status: null,
    numberSpacing: 10,
    deltaFontSize: (e) => e / 8,
    valueFontSize: (e) => e / 2.5,
    alignment: ee.LEFT
  }
}), T$ = ct({}, wv, {
  donut: {
    center: {
      numberFontSize: (e) => `${Math.min(e / 100 * 24, 24)}px`,
      titleFontSize: (e) => `${Math.min(e / 100 * 15, 15)}px`,
      titleYPosition: (e) => Math.min(e / 80 * 20, 20)
    },
    alignment: ee.LEFT
  }
}), Sv = ct({}, ue, {
  legend: {
    enabled: !1,
    clickable: !1
  },
  meter: {
    showLabels: !0,
    proportional: null,
    statusBar: {
      percentageIndicator: {
        enabled: !0
      }
    }
  }
}), M$ = ct({}, Sv, {
  legend: {
    enabled: !0
  }
}), C$ = ct({}, ue, {
  radar: {
    axes: {
      angle: "key",
      value: "value"
    },
    alignment: ee.LEFT
  },
  tooltip: {
    gridline: {
      enabled: !0
    }
  }
}), A$ = ct({}, wr, {
  comboChartTypes: []
}), $$ = ct(
  {
    tree: {
      type: lu.TREE
    }
  },
  ue,
  {}
), L$ = ct({}, ue, {
  data: ct(ue.data, {
    groupMapsTo: "name"
  })
}), R$ = ct({}, ue, Fr, {
  data: ct(ue.data, {
    groupMapsTo: "name"
  })
}), k$ = ct({}, ue, {
  alluvial: {
    data: ct(ue.data, {
      groupMapsTo: "source"
    }),
    nodeAlignment: ee.CENTER,
    nodePadding: 24,
    monochrome: !1,
    nodes: []
  }
}), D$ = ct({}, ue, {
  axes: yv,
  heatmap: {
    divider: {
      state: as.AUTO
    },
    colorLegend: {
      type: "linear"
    }
  }
}), I$ = ct({}, bv, {
  choropleth: {
    colorLegend: {
      type: "linear"
    }
  }
}), Nt = {
  alluvialChart: k$,
  areaChart: _v,
  axisChart: Fs,
  boxplotChart: y$,
  bubbleChart: E$,
  bulletChart: _$,
  chart: ue,
  circlePackChart: R$,
  choroplethChart: I$,
  comboChart: A$,
  donutChart: T$,
  gaugeChart: O$,
  groupedBarChart: g$,
  heatmapChart: D$,
  histogramChart: w$,
  lineChart: Ev,
  lollipopChart: x$,
  meterChart: Sv,
  pieChart: wv,
  proportionalMeterChart: M$,
  radarChart: C$,
  scatterChart: nh,
  simpleBarChart: m$,
  stackedAreaChart: b$,
  stackedBarChart: v$,
  thematicChart: bv,
  treeChart: $$,
  treemapChart: L$,
  wordCloudChart: S$
};
function N$(e, t, n) {
  let r = null;
  return function(...i) {
    const s = this;
    s.mousePosition = vr(i[0], n), clearTimeout(r), r = setTimeout(function() {
      e.apply(s, i);
    }, t);
  };
}
function Wt(e, t) {
  var n;
  const r = In(e), i = Object.keys(t.axes || {});
  (n = t == null ? void 0 : t.toolbar) != null && n.controls && delete r.toolbar.controls, i.length === 0 && delete r.axes;
  for (const s in r.axes)
    if (i.includes(s)) {
      const a = t.axes[s];
      if ((a.primary || a.secondary) && console.warn(
        "`primary` & `secondary` are no longer needed for axis configurations. Read more here https://charts.carbondesignsystem.com/?path=/story/docs-tutorials--tabular-data-format"
      ), a.mapsTo == null) {
        const l = a.scaleType;
        l == null ? a.mapsTo = "value" : l === et.TIME ? a.mapsTo = "date" : l === et.LABELS && (a.mapsTo = "key");
      }
    } else
      delete r.axes[s];
  return rh(r, t), ct(r, t);
}
function En(e) {
  if (!e)
    return;
  const t = /translate\([0-9]+\.?[0-9]*,[0-9]+\.?[0-9]*\)/, n = e.getAttribute("transform").match(t);
  if (!n)
    return null;
  if (n[0]) {
    const r = n[0].replace(/translate\(/, "").replace(/\)/, "").split(",");
    return {
      tx: r[0],
      ty: r[1]
    };
  }
  return null;
}
function es(e) {
  const t = /\(([^)]+)\)/.exec(e);
  if (t && t.length > 1) {
    const n = t[1].split(",");
    if (n.length > 1)
      return {
        x: parseFloat(n[0]),
        y: parseFloat(n[1])
      };
  }
  return { x: 0, y: 0 };
}
function kl(e, t, n = "value", r = !1) {
  const i = e / t.reduce((s, a) => s + a[n], 0) * 100;
  return r ? i : i % 1 !== 0 ? parseFloat(i.toFixed(1)) : i;
}
function As(e, t, n) {
  if (n > e.length)
    return e;
  if (t === qe.MID_LINE)
    return e.substr(0, n / 2) + "..." + e.substr(-n / 2);
  if (t === qe.FRONT_LINE)
    return "..." + e.substr(-n);
  if (t === qe.END_LINE)
    return e.substr(0, n) + "...";
}
function rh(e, t) {
  const n = x(e, "legend", "additionalItems"), r = x(t, "legend", "additionalItems");
  if (n && r) {
    const i = r.map((o) => o.type), s = n.map((o) => o.type), a = u$.filter(
      (o) => s.includes(o.type) && !i.includes(o.type)
    );
    e.legend.additionalItems = a, t.legend.additionalItems = o$(
      a,
      r,
      "name"
    );
  }
}
const x = (e, ...t) => {
  let n = e;
  if (n) {
    for (const r of t)
      if (n[r] !== null && n[r] !== void 0)
        n = n[r];
      else
        return null;
    return n;
  }
  return null;
}, Ov = (e, t) => t === te.HORIZONTAL ? {
  y0: e.x0,
  y1: e.x1,
  x0: e.y0,
  x1: e.y1
} : e, de = (e, t) => {
  const { x0: n, x1: r, y0: i, y1: s } = Ov(e, t);
  return `M${n},${i}L${n},${s}L${r},${s}L${r},${i}L${n},${i}`;
};
function Cn(e, t, n) {
  return n === te.VERTICAL ? [e, t] : [t, e];
}
const Tv = 6048e5, P$ = 864e5, Mv = 6e4, Cv = 36e5;
function bf(e) {
  const t = St(e);
  return t.setHours(0, 0, 0, 0), t;
}
function Ef(e) {
  const t = St(e), n = new Date(
    Date.UTC(
      t.getFullYear(),
      t.getMonth(),
      t.getDate(),
      t.getHours(),
      t.getMinutes(),
      t.getSeconds(),
      t.getMilliseconds()
    )
  );
  return n.setUTCFullYear(t.getFullYear()), +e - +n;
}
function Av(e, t) {
  const n = bf(e), r = bf(t), i = +n - Ef(n), s = +r - Ef(r);
  return Math.round((i - s) / P$);
}
function Qe(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t);
}
function U$(e) {
  const t = St(e), n = Qe(e, 0);
  return n.setFullYear(t.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function B$(e) {
  const t = St(e);
  return Av(t, U$(t)) + 1;
}
function ho(e) {
  return Ss(e, { weekStartsOn: 1 });
}
function $v(e) {
  const t = St(e), n = t.getFullYear(), r = Qe(e, 0);
  r.setFullYear(n + 1, 0, 4), r.setHours(0, 0, 0, 0);
  const i = ho(r), s = Qe(e, 0);
  s.setFullYear(n, 0, 4), s.setHours(0, 0, 0, 0);
  const a = ho(s);
  return t.getTime() >= i.getTime() ? n + 1 : t.getTime() >= a.getTime() ? n : n - 1;
}
function H$(e) {
  const t = $v(e), n = Qe(e, 0);
  return n.setFullYear(t, 0, 4), n.setHours(0, 0, 0, 0), ho(n);
}
function V$(e) {
  const t = St(e), n = +ho(t) - +H$(t);
  return Math.round(n / Tv) + 1;
}
function Lv(e, t) {
  var n, r, i, s;
  const a = St(e), o = a.getFullYear(), l = Po(), c = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.firstWeekContainsDate) ?? l.firstWeekContainsDate ?? ((s = (i = l.locale) == null ? void 0 : i.options) == null ? void 0 : s.firstWeekContainsDate) ?? 1, u = Qe(e, 0);
  u.setFullYear(o + 1, 0, c), u.setHours(0, 0, 0, 0);
  const d = Ss(u, t), h = Qe(e, 0);
  h.setFullYear(o, 0, c), h.setHours(0, 0, 0, 0);
  const f = Ss(h, t);
  return a.getTime() >= d.getTime() ? o + 1 : a.getTime() >= f.getTime() ? o : o - 1;
}
function F$(e, t) {
  var n, r, i, s;
  const a = Po(), o = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((r = (n = t == null ? void 0 : t.locale) == null ? void 0 : n.options) == null ? void 0 : r.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((s = (i = a.locale) == null ? void 0 : i.options) == null ? void 0 : s.firstWeekContainsDate) ?? 1, l = Lv(e, t), c = Qe(e, 0);
  return c.setFullYear(l, 0, o), c.setHours(0, 0, 0, 0), Ss(c, t);
}
function z$(e, t) {
  const n = St(e), r = +Ss(n, t) - +F$(n, t);
  return Math.round(r / Tv) + 1;
}
function Lt(e, t) {
  const n = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0");
  return n + r;
}
const Gn = {
  // Year
  y(e, t) {
    const n = e.getFullYear(), r = n > 0 ? n : 1 - n;
    return Lt(t === "yy" ? r % 100 : r, t.length);
  },
  // Month
  M(e, t) {
    const n = e.getMonth();
    return t === "M" ? String(n + 1) : Lt(n + 1, 2);
  },
  // Day of the month
  d(e, t) {
    return Lt(e.getDate(), t.length);
  },
  // AM or PM
  a(e, t) {
    const n = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(e, t) {
    return Lt(e.getHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H(e, t) {
    return Lt(e.getHours(), t.length);
  },
  // Minute
  m(e, t) {
    return Lt(e.getMinutes(), t.length);
  },
  // Second
  s(e, t) {
    return Lt(e.getSeconds(), t.length);
  },
  // Fraction of second
  S(e, t) {
    const n = t.length, r = e.getMilliseconds(), i = Math.trunc(
      r * Math.pow(10, n - 3)
    );
    return Lt(i, t.length);
  }
}, Nr = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, _f = {
  // Era
  G: function(e, t, n) {
    const r = e.getFullYear() > 0 ? 1 : 0;
    switch (t) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, { width: "abbreviated" });
      case "GGGGG":
        return n.era(r, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(r, { width: "wide" });
    }
  },
  // Year
  y: function(e, t, n) {
    if (t === "yo") {
      const r = e.getFullYear(), i = r > 0 ? r : 1 - r;
      return n.ordinalNumber(i, { unit: "year" });
    }
    return Gn.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, n, r) {
    const i = Lv(e, r), s = i > 0 ? i : 1 - i;
    if (t === "YY") {
      const a = s % 100;
      return Lt(a, 2);
    }
    return t === "Yo" ? n.ordinalNumber(s, { unit: "year" }) : Lt(s, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    const n = $v(e);
    return Lt(n, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    const n = e.getFullYear();
    return Lt(n, t.length);
  },
  // Quarter
  Q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "Q":
        return String(r);
      case "QQ":
        return Lt(r, 2);
      case "Qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, n) {
    const r = Math.ceil((e.getMonth() + 1) / 3);
    switch (t) {
      case "q":
        return String(r);
      case "qq":
        return Lt(r, 2);
      case "qo":
        return n.ordinalNumber(r, { unit: "quarter" });
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      case "M":
      case "MM":
        return Gn.M(e, t);
      case "Mo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(r, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(e, t, n) {
    const r = e.getMonth();
    switch (t) {
      case "L":
        return String(r + 1);
      case "LL":
        return Lt(r + 1, 2);
      case "Lo":
        return n.ordinalNumber(r + 1, { unit: "month" });
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(r, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(e, t, n, r) {
    const i = z$(e, r);
    return t === "wo" ? n.ordinalNumber(i, { unit: "week" }) : Lt(i, t.length);
  },
  // ISO week of year
  I: function(e, t, n) {
    const r = V$(e);
    return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Lt(r, t.length);
  },
  // Day of the month
  d: function(e, t, n) {
    return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : Gn.d(e, t);
  },
  // Day of year
  D: function(e, t, n) {
    const r = B$(e);
    return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Lt(r, t.length);
  },
  // Day of week
  E: function(e, t, n) {
    const r = e.getDay();
    switch (t) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, n, r) {
    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "e":
        return String(s);
      case "ee":
        return Lt(s, 2);
      case "eo":
        return n.ordinalNumber(s, { unit: "day" });
      case "eee":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, n, r) {
    const i = e.getDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "c":
        return String(s);
      case "cc":
        return Lt(s, t.length);
      case "co":
        return n.ordinalNumber(s, { unit: "day" });
      case "ccc":
        return n.day(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(i, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(i, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, n) {
    const r = e.getDay(), i = r === 0 ? 7 : r;
    switch (t) {
      case "i":
        return String(i);
      case "ii":
        return Lt(i, t.length);
      case "io":
        return n.ordinalNumber(i, { unit: "day" });
      case "iii":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, n) {
    const r = e.getHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(r, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(r, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, n) {
    const r = e.getHours();
    let i;
    switch (r === 12 ? i = Nr.noon : r === 0 ? i = Nr.midnight : i = r / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, n) {
    const r = e.getHours();
    let i;
    switch (r >= 17 ? i = Nr.evening : r >= 12 ? i = Nr.afternoon : r >= 4 ? i = Nr.morning : i = Nr.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, n) {
    if (t === "ho") {
      let r = e.getHours() % 12;
      return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" });
    }
    return Gn.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, n) {
    return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : Gn.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, n) {
    const r = e.getHours() % 12;
    return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Lt(r, t.length);
  },
  // Hour [1-24]
  k: function(e, t, n) {
    let r = e.getHours();
    return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Lt(r, t.length);
  },
  // Minute
  m: function(e, t, n) {
    return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : Gn.m(e, t);
  },
  // Second
  s: function(e, t, n) {
    return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : Gn.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return Gn.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, n) {
    const r = e.getTimezoneOffset();
    if (r === 0)
      return "Z";
    switch (t) {
      case "X":
        return Sf(r);
      case "XXXX":
      case "XX":
        return lr(r);
      case "XXXXX":
      case "XXX":
      default:
        return lr(r, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      case "x":
        return Sf(r);
      case "xxxx":
      case "xx":
        return lr(r);
      case "xxxxx":
      case "xxx":
      default:
        return lr(r, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + wf(r, ":");
      case "OOOO":
      default:
        return "GMT" + lr(r, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, n) {
    const r = e.getTimezoneOffset();
    switch (t) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + wf(r, ":");
      case "zzzz":
      default:
        return "GMT" + lr(r, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, n) {
    const r = Math.trunc(e.getTime() / 1e3);
    return Lt(r, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, n) {
    const r = e.getTime();
    return Lt(r, t.length);
  }
};
function wf(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Math.trunc(r / 60), s = r % 60;
  return s === 0 ? n + String(i) : n + String(i) + t + Lt(s, 2);
}
function Sf(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + Lt(Math.abs(e) / 60, 2) : lr(e, t);
}
function lr(e, t = "") {
  const n = e > 0 ? "-" : "+", r = Math.abs(e), i = Lt(Math.trunc(r / 60), 2), s = Lt(r % 60, 2);
  return n + i + t + s;
}
const Of = (e, t) => {
  switch (e) {
    case "P":
      return t.date({ width: "short" });
    case "PP":
      return t.date({ width: "medium" });
    case "PPP":
      return t.date({ width: "long" });
    case "PPPP":
    default:
      return t.date({ width: "full" });
  }
}, Rv = (e, t) => {
  switch (e) {
    case "p":
      return t.time({ width: "short" });
    case "pp":
      return t.time({ width: "medium" });
    case "ppp":
      return t.time({ width: "long" });
    case "pppp":
    default:
      return t.time({ width: "full" });
  }
}, G$ = (e, t) => {
  const n = e.match(/(P+)(p+)?/) || [], r = n[1], i = n[2];
  if (!i)
    return Of(e, t);
  let s;
  switch (r) {
    case "P":
      s = t.dateTime({ width: "short" });
      break;
    case "PP":
      s = t.dateTime({ width: "medium" });
      break;
    case "PPP":
      s = t.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      s = t.dateTime({ width: "full" });
      break;
  }
  return s.replace("{{date}}", Of(r, t)).replace("{{time}}", Rv(i, t));
}, j$ = {
  p: Rv,
  P: G$
}, W$ = /^D+$/, q$ = /^Y+$/, Y$ = ["D", "DD", "YY", "YYYY"];
function X$(e) {
  return W$.test(e);
}
function Z$(e) {
  return q$.test(e);
}
function K$(e, t, n) {
  const r = Q$(e, t, n);
  if (console.warn(r), Y$.includes(e))
    throw new RangeError(r);
}
function Q$(e, t, n) {
  const r = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
function J$(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function tL(e) {
  if (!J$(e) && typeof e != "number")
    return !1;
  const t = St(e);
  return !isNaN(Number(t));
}
const eL = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, nL = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, rL = /^'([^]*?)'?$/, iL = /''/g, sL = /[a-zA-Z]/;
function Lc(e, t, n) {
  var r, i, s, a, o, l, c, u;
  const d = Po(), h = (n == null ? void 0 : n.locale) ?? d.locale ?? kg, f = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((i = (r = n == null ? void 0 : n.locale) == null ? void 0 : r.options) == null ? void 0 : i.firstWeekContainsDate) ?? d.firstWeekContainsDate ?? ((a = (s = d.locale) == null ? void 0 : s.options) == null ? void 0 : a.firstWeekContainsDate) ?? 1, p = (n == null ? void 0 : n.weekStartsOn) ?? ((l = (o = n == null ? void 0 : n.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? d.weekStartsOn ?? ((u = (c = d.locale) == null ? void 0 : c.options) == null ? void 0 : u.weekStartsOn) ?? 0, v = St(e);
  if (!tL(v))
    throw new RangeError("Invalid time value");
  let m = t.match(nL).map((g) => {
    const b = g[0];
    if (b === "p" || b === "P") {
      const w = j$[b];
      return w(g, h.formatLong);
    }
    return g;
  }).join("").match(eL).map((g) => {
    if (g === "''")
      return { isToken: !1, value: "'" };
    const b = g[0];
    if (b === "'")
      return { isToken: !1, value: aL(g) };
    if (_f[b])
      return { isToken: !0, value: g };
    if (b.match(sL))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + b + "`"
      );
    return { isToken: !1, value: g };
  });
  h.localize.preprocessor && (m = h.localize.preprocessor(v, m));
  const y = {
    firstWeekContainsDate: f,
    weekStartsOn: p,
    locale: h
  };
  return m.map((g) => {
    if (!g.isToken)
      return g.value;
    const b = g.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && Z$(b) || !(n != null && n.useAdditionalDayOfYearTokens) && X$(b)) && K$(b, t, String(e));
    const w = _f[b[0]];
    return w(v, b, h.localize, y);
  }).join("");
}
function aL(e) {
  const t = e.match(rL);
  return t ? t[1].replace(iL, "'") : e;
}
var kv = /* @__PURE__ */ ((e) => (e["15seconds"] = "15seconds", e.minute = "minute", e["30minutes"] = "30minutes", e.hourly = "hourly", e.daily = "daily", e.weekly = "weekly", e.monthly = "monthly", e.quarterly = "quarterly", e.yearly = "yearly", e))(kv || {});
const Dl = [
  ["15seconds", 15 * 1e3],
  ["minute", 60 * 1e3],
  ["30minutes", 30 * 60 * 1e3],
  ["hourly", 60 * 60 * 1e3],
  ["daily", 24 * 60 * 60 * 1e3],
  ["monthly", 30 * 24 * 60 * 60 * 1e3],
  ["quarterly", 3 * 30 * 24 * 60 * 60 * 1e3],
  ["yearly", 12 * 30 * 24 * 60 * 60 * 1e3]
];
function Dv(e, t, n, r, i) {
  const s = t === 0, a = Number(Lc(new Date(e), "c")) === 2, o = Number(Lc(new Date(e), "q")) === 1, l = t !== 0 ? n[t - 1] : null;
  switch (r) {
    case "15seconds":
      return s || ca(e) || Bi(e, l) || jn(e);
    case "minute":
      return s || ca(e) || Bi(e, l) || jn(e);
    case "30minutes":
      return s || ca(e) || Bi(e, l) || jn(e);
    case "hourly":
      return s || ca(e) || Bi(e, l) || jn(e);
    case "daily":
      return i ? s || a || jn(e) : s || Bi(e, l) || jn(e);
    case "weekly":
      return s || a || jn(e);
    case "monthly":
      return s || jn(e);
    case "quarterly":
      return s || o;
    case "yearly":
      return !1;
    default:
      throw new Error(`${r} is not a valid time interval.`);
  }
}
function Rc(e, t, n, r, i, s) {
  const a = i.showDayName, o = r === "daily" && a ? "weekly" : r, l = new Date(e), c = x(i, "timeIntervalFormats")[o], u = x(c, "primary"), d = x(c, "secondary"), h = Dv(e, t, n, r, a);
  let f = h ? u : d;
  r === "15seconds" && l.getMilliseconds() !== 0 && (f = f.replace("pp", "h:mm:ss.SSS a"));
  const p = i.localeObject, { code: v, optionsObject: m } = s, y = m[r].type, g = m[r][h ? "primary" : "secondary"][f];
  if (r === "quarterly" || !g) {
    const b = Lc(l, f, { locale: p }).split("").map((w) => {
      let _ = Number(w);
      return w !== " " && !Number.isNaN(_) ? _.toLocaleString(v) : w;
    });
    return s[y](l, v, {}, b.join(""));
  } else
    return s[y](l, v, g);
}
function fo(e) {
  const t = new Date(e);
  return {
    M: t.getMonth() + 1,
    // month: 1-12
    d: t.getDate(),
    // day of the month: 1-31
    H: t.getHours(),
    // 24-hour clock: 0-23
    m: t.getMinutes(),
    // minute: 0-59
    s: t.getSeconds()
    // seconds: 0-59
  };
}
function oL(e) {
  if (e)
    return e.slice(1).map((t, n) => t - e[n]);
}
function lL(e) {
  const t = Dl.reduce((n, [, r], i) => {
    const s = Dl[n][1], a = Math.abs(s - e), o = Math.abs(r - e);
    return a < o ? n : i;
  }, 0);
  return Dl[t][0];
}
function kc(e, t) {
  if (kv[t])
    return t;
  if (e.length === 1)
    return "15seconds";
  const n = oL(e), r = Zn(n);
  return lL(r);
}
function ca(e) {
  const { s: t, m: n, H: r } = fo(e);
  return r === 0 && n === 0 && t === 0;
}
function Bi(e, t) {
  const n = fo(e).M, r = fo(t).M;
  return n !== r;
}
function jn(e) {
  const { M: t, d: n, s: r, m: i, H: s } = fo(e);
  return t === 1 && n === 1 && s === 0 && i === 0 && r === 0;
}
function Tf(e) {
  return e === void 0 ? "" : e.toISOString();
}
function Iv(e) {
  const t = Ye(e, (r) => r.value), n = Ke().domain(t).nice().domain();
  if (n[0] > 0)
    n[0] = 0;
  else if (n[0] === 0 && n[1] === 0)
    return [0, 1];
  return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
}
function Nv(e, t) {
  const n = x(t, "gradient", "colors"), r = !We(n);
  let i = x(t, "pairing", "option");
  const s = Iv(e), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
  (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
  const o = r ? n : [];
  if (!r) {
    const l = a === "diverge" ? 17 : 11;
    for (let c = 1; c < l + 1; c++)
      o.push(`fill-${a}-${i}-${c}`);
  }
  return Cu().domain(s).range(o);
}
var ht = /* @__PURE__ */ ((e) => (e.GRAPHICS_DOCUMENT = "graphics-document", e.GRAPHICS_OBJECT = "graphics-object", e.GRAPHICS_SYMBOL = "graphics-symbol", e.GROUP = "group", e.DOCUMENT = "document", e.CHECKBOX = "checkbox", e.BUTTON = "button", e.MENU = "menu", e.MENU_ITEM = "menuitem", e.IMG = "img", e))(ht || {});
function cL(e, t) {
  return e && dv(e, t, Us);
}
function uL(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!Ar(n))
      return e(n, r);
    for (var i = n.length, s = t ? i : -1, a = Object(n); (t ? s-- : ++s < i) && r(a[s], s, a) !== !1; )
      ;
    return n;
  };
}
var ih = uL(cL);
function hL(e, t, n, r) {
  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {
    var a = e[i];
    t(r, a, n(a), e);
  }
  return r;
}
function dL(e, t, n, r) {
  return ih(e, function(i, s, a) {
    t(r, i, n(i), a);
  }), r;
}
function fL(e, t) {
  return function(n, r) {
    var i = se(n) ? hL : dL, s = t ? t() : {};
    return i(n, e, qo(r), s);
  };
}
function pL(e) {
  for (var t = -1, n = e == null ? 0 : e.length, r = {}; ++t < n; ) {
    var i = e[t];
    r[i[0]] = i[1];
  }
  return r;
}
var mL = Object.prototype, gL = mL.hasOwnProperty, vL = fL(function(e, t, n) {
  gL.call(e, n) ? e[n].push(t) : Bo(e, n, [t]);
});
function yL(e) {
  const t = e.trim();
  return ["=", "+", "-", "@", "	", "\r"].includes(t.charAt(0)) ? ` ${t}` : /[,\"\n]/.test(t) ? `"${t}"` : t;
}
let pn = class {
  constructor(t) {
    this.state = {
      options: {}
    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;
  }
  formatTable({ headers: t, cells: n }) {
    const r = this.getOptions(), {
      code: i,
      date: s,
      number: a
    } = x(r, "locale"), o = x(r, "tabularRepModal", "tableHeadingFormatter"), l = x(r, "tabularRepModal", "tableCellFormatter"), { cartesianScales: c } = this.services, u = c == null ? void 0 : c.getDomainAxisScaleType();
    let d;
    return u === et.TIME && (d = (h) => s(h, i, { month: "short", day: "numeric", year: "numeric" })), [
      typeof o == "function" ? o(t) : t,
      ...typeof l == "function" ? l(n) : n.map((h) => {
        d && (h[1] = d(h[1]));
        for (let f in h) {
          let p = h[f];
          typeof p == "number" && (h[f] = a(p, i));
        }
        return h;
      })
    ];
  }
  getAllDataFromDomain(t) {
    if (!this.getData())
      return null;
    const n = this.getOptions();
    let r = this.getData();
    const i = this.getDataGroups(), { groupMapsTo: s } = x(n, "data"), a = x(n, "axes");
    return t && (r = r.filter((o) => t.includes(o[s]))), a && Object.keys(a).forEach((o) => {
      const l = a[o].mapsTo, c = a[o].scaleType;
      if ((c === et.LINEAR || c === et.LOG) && (r = r.map((u) => ({
        ...u,
        [l]: u[l] === null ? u[l] : Number(u[l])
      }))), l && a[o].domain)
        if (c === et.LABELS)
          r = r.filter(
            (u) => a[o].domain.includes(u[l])
          );
        else {
          const [u, d] = a[o].domain;
          r = r.filter(
            (h) => !(l in h) || h[l] >= u && h[l] <= d
          );
        }
    }), r.filter((o) => i.find((l) => l.name === o[s]));
  }
  /**
   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart
   * @param groups the included datasets for the particular chart
   */
  getDisplayData(t) {
    if (!this.get("data"))
      return null;
    const { ACTIVE: n } = qt.items.status, r = this.getDataGroups(t), { groupMapsTo: i } = this.getOptions().data;
    return this.getAllDataFromDomain(t).filter((s) => r.find(
      (a) => a.name === s[i] && a.status === n
    ));
  }
  getData() {
    return this.get("data");
  }
  isDataEmpty() {
    return !this.getData().length;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const n = this.sanitize(In(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), n;
  }
  getDataGroups(t) {
    return x(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((n) => t.includes(n.name)) : this.get("dataGroups");
  }
  getActiveDataGroups(t) {
    const { ACTIVE: n } = qt.items.status;
    return this.getDataGroups(t).filter((r) => r.status === n);
  }
  getDataGroupNames(t) {
    return this.getDataGroups(t).map((n) => n.name);
  }
  getActiveDataGroupNames(t) {
    return this.getActiveDataGroups(t).map((n) => n.name);
  }
  aggregateBinDataByGroup(t) {
    return vL(t, "group");
  }
  getBinConfigurations() {
    const t = this.getDisplayData(), n = this.getOptions(), r = this.services.cartesianScales.getMainXAxisPosition(), i = this.services.cartesianScales.getDomainIdentifier(), s = n.axes[r], { groupMapsTo: a } = n.data, { bins: o = l$.defaultBins } = s, l = Array.isArray(o), c = xy().value((f) => f[i]).thresholds(o)(t);
    if (l)
      c[c.length - 1].x1 = o[o.length - 1];
    else {
      const f = c[0].x1 - c[0].x0;
      c[c.length - 1].x1 = +c[c.length - 1].x0 + f;
    }
    const u = l ? [o[0], o[o.length - 1]] : [c[0].x0, c[c.length - 1].x1], d = Array.from(new Set(t.map((f) => f[a]))), h = [];
    return c.forEach((f) => {
      const p = `${f.x0}-${f.x1}`, v = this.aggregateBinDataByGroup(f);
      d.forEach((m) => {
        h.push({
          group: m,
          key: p,
          value: v[m] || 0,
          bin: f.x0
        });
      });
    }), {
      bins: c,
      binsDomain: u
    };
  }
  getBinnedStackedData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getActiveDataGroupNames(), { bins: i } = this.getBinConfigurations(), s = this.getDataValuesGroupedByKeys({
      bins: i
    });
    return Cl().keys(r)(s).map((a, o) => Object.keys(a).filter((l) => !isNaN(l)).map((l) => {
      const c = a[l];
      return c[n] = r[o], c;
    }));
  }
  getGroupedData(t) {
    const n = this.getDisplayData(t), r = {}, { groupMapsTo: i } = this.getOptions().data;
    return n.map((s) => {
      const a = s[i];
      r[a] !== null && r[a] !== void 0 ? r[a].push(s) : r[a] = [s];
    }), Object.keys(r).map((s) => ({
      name: s,
      data: r[s]
    }));
  }
  getStackKeys({ bins: t = null, groups: n = null } = { bins: null, groups: null }) {
    const r = this.getOptions(), i = this.getDisplayData(n);
    let s;
    t ? s = t.map((l) => `${l.x0}:${l.x1}`) : s = Cs(
      i.map((l) => {
        const c = this.services.cartesianScales.getDomainIdentifier(l);
        return l[c] instanceof Date ? Tf(l[c]) : l[c] && typeof l[c].toString == "function" ? l[c].toString() : l[c];
      })
    );
    const a = this.services.cartesianScales.domainAxisPosition, o = r.axes[a].scaleType;
    return o === et.TIME ? s.sort((l, c) => {
      const u = new Date(l), d = new Date(c);
      return u - d;
    }) : (o === et.LOG || o === et.LINEAR) && s.sort((l, c) => l - c), s;
  }
  getDataValuesGroupedByKeys({ bins: t = null, groups: n = null }) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.getDisplayData(n), a = this.getDataGroupNames(), o = this.getStackKeys({ bins: t, groups: n });
    return t ? o.map((l) => {
      const [c, u] = l.split(":"), d = { x0: c, x1: u }, h = t.find((f) => f.x0.toString() === c.toString());
      return a.forEach((f) => {
        d[f] = h.filter(
          (p) => p[i] === f
        ).length;
      }), d;
    }) : o.map((l) => {
      const c = { sharedStackKey: l };
      return a.forEach((u) => {
        const d = s.find((f) => {
          const p = this.services.cartesianScales.getDomainIdentifier(f);
          return f[i] === u && Object.prototype.hasOwnProperty.call(f, p) && (f[p] instanceof Date ? Tf(f[p]) === l : f[p].toString() === l);
        }), h = this.services.cartesianScales.getRangeIdentifier(c);
        c[u] = d ? d[h] : null;
      }), c;
    });
  }
  getStackedData({ percentage: t = !1, groups: n = null, divergent: r = !1 }) {
    const i = this.getOptions(), { groupMapsTo: s } = i.data, a = this.getActiveDataGroupNames(n), o = this.getDataValuesGroupedByKeys({
      groups: n
    });
    if (t) {
      const l = pL(o.map((c) => [c.sharedStackKey, 0]));
      o.forEach((c) => {
        a.forEach((u) => {
          l[c.sharedStackKey] += c[u];
        });
      }), o.forEach((c) => {
        a.forEach((u) => {
          const d = l[c.sharedStackKey];
          l[c.sharedStackKey] ? c[u] = c[u] / d * 100 : c[u] = 0;
        });
      });
    }
    return (r ? Cl().offset(MO) : Cl()).keys(a)(o).map((l, c) => Object.keys(l).filter((u) => !isNaN(u)).map((u) => {
      const d = l[u];
      return d[s] = a[c], d;
    }));
  }
  /**
   * @return {Object} The chart's options
   */
  getOptions() {
    return this.state.options;
  }
  set(t, n) {
    this.state = Object.assign({}, this.state, t);
    const r = Object.assign(
      { skipUpdate: !1, animate: !0 },
      // default configs
      n
    );
    r.skipUpdate || this.update(r.animate);
  }
  get(t) {
    return t ? this.state[t] : this.state;
  }
  /**
   *
   * @param newOptions New options to be set
   */
  setOptions(t) {
    const n = this.getOptions();
    rh(n, t), this.set({
      options: ct(n, t)
    });
  }
  /**
   *
   * Updates miscellanous information within the model
   * such as the color scales, or the legend data labels
   */
  update(t = !0) {
    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(O.Model.UPDATE, { animate: t }));
  }
  /*
   * Data labels
   */
  toggleDataLabel(t) {
    const { ACTIVE: n, DISABLED: r } = qt.items.status, i = this.getDataGroups(), s = i.some((c) => c.status === r), a = i.filter((c) => c.status === n);
    if (s)
      if (a.length === 1 && a[0].name === t)
        i.forEach((c, u) => {
          i[u].status = n;
        });
      else {
        const c = i.findIndex((u) => u.name === t);
        i[c].status = i[c].status === r ? n : r;
      }
    else
      i.forEach((c, u) => {
        i[u].status = c.name === t ? n : r;
      });
    const o = i.filter((c) => c.status === n), l = this.getOptions();
    i.some((c) => c.status === r) ? l.data.selectedGroups = o.map((c) => c.name) : l.data.selectedGroups = [], this.services.events.dispatchEvent(O.Legend.ITEMS_UPDATE, {
      dataGroups: i
    }), this.set({
      dataGroups: i
    });
  }
  /**
   * Should the data point be filled?
   * @param group
   * @param key
   * @param data
   * @param defaultFilled the default for this chart
   */
  getIsFilled(t, n, r, i) {
    const s = this.getOptions();
    return s.getIsFilled ? s.getIsFilled(t, n, r, i) : i;
  }
  getFillColor(t, n, r) {
    const i = this.getOptions(), s = x(this.colorScale, t);
    return i.getFillColor ? i.getFillColor(t, n, r, s) : s;
  }
  getStrokeColor(t, n, r) {
    const i = this.getOptions(), s = x(this.colorScale, t);
    return i.getStrokeColor ? i.getStrokeColor(t, n, r, s) : s;
  }
  isUserProvidedColorScaleValid() {
    const t = x(this.getOptions(), "color", "scale"), n = this.getDataGroups();
    return t == null || Object.keys(t).length == 0 ? !1 : n.some(
      (r) => Object.keys(t).includes(r.name)
    );
  }
  getColorClassName(t) {
    const n = this.colorClassNames(t.dataGroupName);
    let r = t.originalClassName;
    return t.classNameTypes.forEach(
      (i) => r = t.originalClassName ? `${r} ${i}-${n}` : `${i}-${n}`
    ), r || "";
  }
  /**
   * For charts that might hold an associated status for their dataset
   */
  getStatus() {
    return null;
  }
  getAllDataGroupsNames() {
    return this.allDataGroups;
  }
  /**
   * Converts data provided in the older format to tabular
   *
   */
  transformToTabularData(t) {
    console.warn(
      "We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/?path=/story/docs-tutorials--tabular-data-format"
    );
    const n = [], { datasets: r, labels: i } = t;
    return r.forEach((s) => {
      s.data.forEach((a, o) => {
        let l;
        const c = x(s, "label");
        if (c === null) {
          const d = x(i, o);
          d ? l = d : l = "Ungrouped";
        } else
          l = c;
        const u = {
          group: l,
          key: i[o]
        };
        isNaN(a) ? (u.value = a.value, u.date = a.date) : u.value = a, n.push(u);
      });
    }), n;
  }
  getTabularDataArray() {
    return [];
  }
  exportToCSV() {
    const t = this.getTabularDataArray().map(
      (s) => s.map((a) => `"${(a === "&ndash;" ? "–" : a).split(/[,;'"`]/).map((o) => yL(o)).join("")}"`)
    ).map((s) => s.join(",")).join(`
`), n = this.getOptions();
    let r = "myChart";
    const i = x(n, "fileDownload", "fileName");
    typeof i == "function" ? r = i("csv") : typeof i == "string" && (r = i), this.services.files.downloadCSV(t, `${r}.csv`);
  }
  getTabularData(t) {
    return Array.isArray(t) ? t : this.transformToTabularData(t);
  }
  sanitize(t) {
    return t = this.getTabularData(t), t;
  }
  /*
   * Data groups
   */
  updateAllDataGroups() {
    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {
      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);
    }) : this.allDataGroups = this.getDataGroupNames();
  }
  generateDataGroups(t) {
    const { groupMapsTo: n } = this.getOptions().data, { ACTIVE: r, DISABLED: i } = qt.items.status, s = this.getOptions(), a = Cs(t.map((l) => l[n]));
    s.data.selectedGroups.length && (s.data.selectedGroups.every(
      (l) => a.includes(l)
    ) || (s.data.selectedGroups = []));
    const o = (l) => !s.data.selectedGroups.length || s.data.selectedGroups.includes(l) ? r : i;
    return a.map((l) => ({
      name: l,
      status: o(l)
    }));
  }
  /*
   * Fill scales
   */
  setCustomColorScale() {
    if (!this.isUserProvidedColorScaleValid())
      return;
    const t = this.getOptions(), n = x(t, "color", "scale");
    Object.keys(n).forEach((r) => {
      this.allDataGroups.includes(r) || console.warn(`"${r}" does not exist in data groups.`);
    }), this.allDataGroups.filter((r) => n[r]).forEach(
      (r) => this.colorScale[r] = n[r]
    );
  }
  /*
   * Color palette
   */
  setColorClassNames() {
    const t = x(this.getOptions(), "color", "pairing");
    let n = x(t, "numberOfVariants");
    (!n || n < this.allDataGroups.length) && (n = this.allDataGroups.length);
    let r = x(t, "option");
    const i = gv.pairingOptions, s = n > 5 ? 14 : n, a = `${s}-color`;
    r = r <= i[a] ? r : 1;
    const o = this.allDataGroups.map(
      (l, c) => `${s}-${r}-${c % 14 + 1}`
    );
    this.colorClassNames = $o().range(o).domain(this.allDataGroups);
  }
}, $r = class extends pn {
  // can't be protected as it's used by two-dimensional-axes.ts
  constructor(t) {
    super(t), this.axisFlavor = So.DEFAULT;
  }
  // get the scales information
  // needed for getTabularArray()
  assignRangeAndDomains() {
    const { cartesianScales: t } = this.services, n = this.getOptions(), r = t.isDualAxes(), i = {
      primaryDomain: t.domainAxisPosition,
      primaryRange: t.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    return r && (i.secondaryDomain = t.secondaryDomainAxisPosition, i.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(i).forEach(
      (s) => {
        const a = i[s];
        t.scales[a] ? i[s] = {
          position: a,
          label: t.getScaleLabel(a),
          identifier: x(n, "axes", a, "mapsTo")
        } : i[s] = null;
      }
    ), i;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { primaryDomain: i, primaryRange: s, secondaryDomain: a, secondaryRange: o } = this.assignRangeAndDomains(), { number: l, code: c } = x(this.getOptions(), "locale"), u = [
      "Group",
      i.label,
      s.label,
      ...a ? [a.label] : [],
      ...o ? [o.label] : []
    ], d = t.map((h) => [
      h[r],
      h[i.identifier] === null ? "&ndash;" : h[i.identifier],
      h[s.identifier] === null || isNaN(h[s.identifier]) ? "&ndash;" : l(h[s.identifier], c),
      ...a ? [
        h[a.identifier] === null ? "&ndash;" : h[a.identifier]
      ] : [],
      ...o ? [
        h[o.identifier] === null || isNaN(h[o.identifier]) ? "&ndash;" : h[o.identifier]
      ] : []
    ]);
    return super.formatTable({ headers: u, cells: d });
  }
  setData(t) {
    let n;
    if (t && (n = super.setData(t), x(this.getOptions(), "zoomBar", F.TOP, "enabled"))) {
      const r = x(
        this.getOptions(),
        "zoomBar",
        F.TOP,
        "data"
      );
      this.setZoomBarData(r);
    }
    return n;
  }
  /**
   * @param zoomBarData any special zoom bar data to use instead of the model data
   */
  setZoomBarData(t) {
    const n = t ? this.sanitize(In(t)) : this.getDisplayData();
    let r = n;
    const { cartesianScales: i } = this.services;
    if (n && i.domainAxisPosition && i.rangeAxisPosition) {
      const s = i.getDomainIdentifier(), a = i.getRangeIdentifier();
      let o = n.map((l) => l[s].getTime());
      o = Cs(o).sort(), r = o.map((l) => {
        let c = 0;
        const u = {};
        return n.forEach((d) => {
          d[s].getTime() === l && (c += d[a]);
        }), u[s] = new Date(l), u[a] = c, u;
      });
    }
    this.set({ zoomBarData: r });
  }
  getZoomBarData() {
    return this.get("zoomBarData");
  }
  sanitizeDateValues(t) {
    const n = this.getOptions();
    if (!n.axes)
      return t;
    const r = [];
    return Object.keys(F).forEach((i) => {
      const s = F[i], a = n.axes[s];
      if (a && a.scaleType === et.TIME) {
        const o = a.mapsTo;
        (o !== null || o !== void 0) && r.push(o);
      }
    }), r.length > 0 && t.forEach((i) => {
      r.forEach((s) => {
        x(i, s, "getTime") === null && (i[s] = new Date(i[s]));
      });
    }), t;
  }
  sanitize(t) {
    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;
  }
}, xL = class extends $r {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = x(this.getOptions(), "locale");
    t.sort((a, o) => a.source.localeCompare(o.source));
    const i = ["Source", "Target", "Value"], s = [
      ...t.map((a) => [
        a.source,
        a.target,
        a.value === null ? "&ndash;" : n(a.value, r)
      ])
    ];
    return super.formatTable({ headers: i, cells: s });
  }
}, bL = class extends $r {
  constructor(t) {
    super(t);
  }
  getBoxQuartiles(t) {
    return {
      q_25: sl(t, 0.25),
      q_50: sl(t, 0.5),
      q_75: sl(t, 0.75)
    };
  }
  getBoxplotData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getGroupedData(), i = [];
    for (const { name: s, data: a } of r) {
      const o = this.services.cartesianScales.getRangeIdentifier(), l = a.map((b) => b[o]).sort(fr), c = {
        [n]: s,
        counts: l,
        quartiles: this.getBoxQuartiles(l),
        outliers: null,
        whiskers: null
      }, u = c.quartiles.q_25, d = c.quartiles.q_75, h = (d - u) * 1.5, f = u - h, p = d + h, v = [], m = [];
      for (const b of l)
        b < f || b > p ? v.push(b) : m.push(b);
      c.outliers = v;
      const y = Zn(m), g = gr(m);
      c.whiskers = {
        min: y || Zn([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75]),
        max: g || gr([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75])
      }, i.push(c);
    }
    return i;
  }
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getBoxplotData(), { number: i, code: s } = x(t, "locale"), a = ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"], o = [
      ...r.map((l) => {
        let c = x(l, "outliers");
        return (c === null || c.length === 0) && (c = ["&ndash;"]), [
          l[n],
          x(l, "whiskers", "min") !== null ? i(x(l, "whiskers", "min"), s) : "&ndash;",
          x(l, "quartiles", "q_25") !== null ? i(x(l, "quartiles", "q_25"), s) : "&ndash;",
          x(l, "quartiles", "q_50") !== null ? i(x(l, "quartiles", "q_50"), s) : "&ndash;",
          x(l, "quartiles", "q_75") !== null ? i(x(l, "quartiles", "q_75"), s) : "&ndash;",
          x(l, "whiskers", "max") !== null ? i(x(l, "whiskers", "max"), s) : "&ndash;",
          x(l, "quartiles", "q_75") !== null && x(l, "quartiles", "q_25") !== null ? (i(
            x(l, "quartiles", "q_75") - x(l, "quartiles", "q_25")
          ), s) : "&ndash;",
          c.map((u) => i(u, s)).join(",")
        ];
      })
    ];
    return super.formatTable({ headers: a, cells: o });
  }
  setColorClassNames() {
    const t = x(this.getOptions(), "color", "pairing");
    let n = x(t, "option");
    const r = gv.pairingOptions;
    n = n <= r["1-color"] ? n : 1;
    const i = this.allDataGroups.map(() => `1-${n}-1`);
    this.colorClassNames = $o().range(i).domain(this.allDataGroups);
  }
}, EL = class extends $r {
  constructor(t) {
    super(t);
  }
  /**
   * Determines the index of the performance area titles to use
   * @param datum
   * @returns number
   */
  getMatchingRangeIndexForDatapoint(t) {
    let n;
    for (let r = t.ranges.length - 1; r > 0; r--) {
      const i = t.ranges[r];
      if (t.value >= i)
        return n = r, n;
    }
    return 0;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { number: s, code: a } = x(n, "locale"), o = x(n, "bullet", "performanceAreaTitles"), l = ["Title", "Group", "Value", "Target", "Percentage", "Performance"], c = [
      ...t.map((u) => [
        u.title,
        u[r],
        u.value === null ? "&ndash;" : s(u.value, a),
        x(u, "marker") === null ? "&ndash;" : s(u.marker, a),
        x(u, "marker") === null ? "&ndash;" : `${s(Math.floor(u[i] / u.marker * 100), a)}%`,
        o[this.getMatchingRangeIndexForDatapoint(u)]
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
}, _L = class extends pn {
  constructor(t) {
    super(t), this._colorScale = void 0, this._matrix = {};
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Helper function that will generate a dictionary
   */
  getCombinedData() {
    if (We(this._matrix)) {
      const t = this.getOptions(), n = this.getDisplayData();
      !We(n) && !We(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((r) => {
        this._matrix[r.properties.NAME] = r;
      }), n.forEach((r) => {
        this._matrix[r.name] ? this._matrix[r.name].value = r.value || null : console.warn(`Data point ${r} is missing geographical data.`);
      }));
    }
    return this._matrix;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = x(this.getOptions(), "locale"), i = ["Country ID", "Country Name", "Value"], s = [
      ...t.map((a) => [
        a.id === null ? "&ndash;" : a.id,
        a.name,
        a.value === null ? "&ndash;" : n(a.value, r)
      ])
    ];
    return super.formatTable({ headers: i, cells: s });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = x(this.getOptions(), "color");
    this._colorScale = Nv(this.getDisplayData(), t);
  }
}, wL = class extends pn {
  constructor(t) {
    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });
  }
  setData(t) {
    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();
  }
  setOptions(t) {
    const n = this.getOptions(), r = ct({}, t, this.getZoomOptions(t));
    rh(n, r);
    const i = this.getHierarchyLevel(), s = x(n, "circlePack", "hierarchyLevel");
    this.set({
      options: ct(n, r),
      depth: s && s < 4 ? s : i
    });
  }
  getZoomOptions(t) {
    if (!this.getDisplayData())
      return {};
    const n = this.getDisplayData(), r = t || this.getOptions(), i = n.length === 1 && x(n, 0, "children") ? x(n, 0, "children") : n;
    let s = this.getHierarchyLevel();
    return i.some((a) => {
      if (a.children && a.children.some((o) => o.children))
        return s = 3, !1;
    }), x(r, "canvasZoom", "enabled") === !0 && s > 2 ? {
      legend: {
        additionalItems: [
          {
            type: Qt.ZOOM,
            name: "Click to zoom"
          }
        ]
      }
    } : null;
  }
  setZoom(t) {
    this.setOptions(this.getZoomOptions(t));
  }
  // update the hierarchy level
  updateHierarchyLevel(t) {
    this.set({ depth: t });
  }
  getHierarchyLevel() {
    return this.get("depth");
  }
  hasParentNode() {
    return this.parentNode;
  }
  // set the datagroup name on the items that are it's children
  setDataGroups() {
    const t = this.getData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = t.map((s) => {
      const a = s[r];
      return this.setChildrenDataGroup(s, a);
    });
    this.set(
      {
        data: i
      },
      { skipUpdate: !0 }
    );
  }
  // sets name recursively down the node tree
  setChildrenDataGroup(t, n) {
    return t.children ? {
      ...t,
      dataGroupName: n,
      children: t.children.map((r) => this.setChildrenDataGroup(r, n))
    } : { ...t, dataGroupName: n };
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = x(this.getOptions(), "locale"), i = ["Child", "Parent", "Value"], s = [];
    return t.forEach((a) => {
      let o = a.value ? a.value : 0;
      a.children && (o += this.getChildrenDatums(a.children, a.name, s, 0)), s.push(["&ndash;", a.name, n(o, r)]);
    }), super.formatTable({ headers: i, cells: s });
  }
  /**
   * Recursively determine the relationship between all the nested elements in the child
   * @param children: Object
   * @param parent: String
   * @param result: Array<Object>
   * @param totalSum: number
   * @returns: number
   */
  getChildrenDatums(t, n, r = [], i = 0) {
    const s = n, { number: a, code: o } = x(this.getOptions(), "locale");
    return t.forEach((l) => {
      const c = l.name;
      let u = 0;
      if (l.children)
        l.children.length > 0 && (typeof l.value == "number" && (i += l.value), u += this.getChildrenDatums(l.children, c, r, u), r.push([c, s, a(u, o)]), i += u);
      else {
        let d = 0;
        typeof l.value == "number" && (d = l.value, i += l.value), r.push([l.name, s, a(d, o)]);
      }
    }), i;
  }
}, SL = class extends pn {
  constructor(t) {
    super(t);
  }
  getTabularData(t) {
    const n = super.getTabularData(t);
    return t !== n && n.forEach((r) => {
      r.key && r.key !== r.group && (r.group = r.key);
    }), n;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { valueMapsTo: i } = n.pie, { number: s, code: a } = x(n, "locale"), o = ["Group", "Value"], l = [
      ...t.map((c) => [
        c[r],
        c[i] === null ? "&ndash;" : s(c[i], a)
      ])
    ];
    return super.formatTable({ headers: o, cells: l });
  }
  sanitize(t) {
    return this.getTabularData(t).sort((n, r) => r.value - n.value);
  }
}, OL = class extends pn {
  constructor(t) {
    super(t);
  }
  getDataGroups() {
    return super.getDataGroups().filter((t) => t.name !== "delta");
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { number: i, code: s } = x(this.getOptions(), "locale"), a = ["Group", "Value"], o = [
      ...t.map((l) => [
        l[r],
        l.value === null ? "&ndash;" : i(l.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
}, TL = class extends $r {
  constructor(t) {
    super(t), this.axisFlavor = So.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};
    const n = x(this.getOptions(), "axes");
    if (x(n, "left", "scaleType") && x(n, "left", "scaleType") !== et.LABELS || x(n, "right", "scaleType") && x(n, "right", "scaleType") !== et.LABELS || x(n, "top", "scaleType") && x(n, "top", "scaleType") !== et.LABELS || x(n, "bottom", "scaleType") && x(n, "bottom", "scaleType") !== et.LABELS)
      throw Error("Heatmap only supports label scaletypes.");
  }
  /**
   * Get min and maximum value of the display data
   * @returns Array consisting of smallest and largest values in  data
   */
  getValueDomain() {
    const t = Ye(this.getDisplayData(), (r) => r.value), n = Ke().domain(t).nice().domain();
    if (n[0] > 0)
      n[0] = 0;
    else if (n[0] === 0 && n[1] === 0)
      return [0, 1];
    return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Generate a list of all unique domains
   * @returns String[]
   */
  getUniqueDomain() {
    if (We(this._domains)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getDomainIdentifier(), i = n.getMainXAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._domains = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._domains;
  }
  /**
   * Generates a list of all unique ranges
   * @returns String[]
   */
  getUniqueRanges() {
    if (We(this._ranges)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getRangeIdentifier(), i = n.getMainYAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._ranges = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._ranges;
  }
  /**
   * Generates a matrix (If doesn't exist) and returns it
   * @returns Object
   */
  getMatrix() {
    if (We(this._matrix)) {
      const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = {};
      n.forEach((a) => {
        s[a] = {
          value: null,
          index: -1
        };
      }), t.forEach((a) => {
        this._matrix[a] = In(s);
      }), this.getDisplayData().forEach((a, o) => {
        this._matrix[a[r]][a[i]] = {
          value: a.value,
          index: o
        };
      });
    }
    return this._matrix;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const n = this.sanitize(In(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), this._domains = [], this._ranges = [], this._matrix = {}, n;
  }
  /**
   * Converts Object matrix into a single array
   * @returns object[]
   */
  getMatrixAsArray() {
    We(this._matrix) && this.getMatrix();
    const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = [];
    return t.forEach((a) => {
      n.forEach((o) => {
        const l = {
          value: this._matrix[a][o].value,
          index: this._matrix[a][o].index
        };
        l[r] = a, l[i] = o, s.push(l);
      });
    }), s;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { primaryDomain: n, primaryRange: r } = this.assignRangeAndDomains(), { number: i, code: s } = x(this.getOptions(), "locale"), a = [n.label, r.label, "Value"], o = [
      ...t.map((l) => [
        l[n.identifier] === null ? "&ndash;" : l[n.identifier],
        l[r.identifier] === null ? "&ndash;" : l[r.identifier],
        l.value === null ? "&ndash;" : i(l.value, s)
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = this.getOptions(), n = x(t, "color", "gradient", "colors"), r = !We(n);
    let i = x(t, "color", "pairing", "option");
    const s = this.getValueDomain(), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
    (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
    const o = r ? n : [];
    if (!r) {
      const c = a === "diverge" ? 17 : 11;
      for (let u = 1; u < c + 1; u++)
        o.push(`fill-${a}-${i}-${u}`);
    }
    this._colorScale = Cu().domain(s).range(o);
    const l = x(this.getOptions(), "color");
    this._colorScale = Nv(this.getDisplayData(), l);
  }
}, ML = class extends $r {
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, { number: r, code: i } = x(this.getOptions(), "locale"), s = this.getBinnedStackedData(), a = [
      _t(t, "bins.rangeLabel") || "Range",
      ...s.map((l) => _t(l, `0.${n}`))
    ], o = [
      ..._t(s, 0).map((l, c) => [
        `${r(Number(_t(l, "data.x0")), i)} – ${r(
          Number(_t(l, "data.x1")),
          i
        )}`,
        ...s.map(
          (u) => r(_t(u[c], `data.${_t(u[c], n)}`), i)
        )
      ])
    ];
    return super.formatTable({ headers: a, cells: o });
  }
}, CL = class extends pn {
  constructor(t) {
    super(t);
  }
  getMaximumDomain(t) {
    return t.reduce((n, r) => n + r.value, 0);
  }
  /**
   * Use a provided color for the bar or default to carbon color if no status provided.
   * Defaults to carbon color otherwise.
   * @param group dataset group label
   */
  getFillColor(t) {
    const n = this.getOptions(), r = x(n, "color", "scale"), i = this.getStatus();
    return r || !i ? super.getFillColor(t) : null;
  }
  /**
   * Get the associated status for the data by checking the ranges
   */
  getStatus() {
    const t = this.getOptions(), n = x(this.getDisplayData()), r = (n == null ? void 0 : n.reduce((a, o) => a + o.value, 0)) ?? 0, i = x(t, "meter", "proportional") ? r : r > 100 ? 100 : r, s = x(t, "meter", "status", "ranges");
    if (s) {
      const a = s.filter(
        (o) => o.range[0] <= i && i <= o.range[1]
      );
      if (a.length > 0)
        return a[0].status;
    }
    return null;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getStatus(), s = x(n, "meter", "proportional"), { number: a, code: o } = x(this.getOptions(), "locale");
    let l = [], c = [], u;
    if (s === null) {
      u = 100;
      const d = t[0];
      l = ["Group", "Value", ...i ? ["Status"] : []], c = [
        [
          d[r],
          d.value === null ? "&ndash;" : a(d.value, o),
          ...i ? [i] : []
        ]
      ];
    } else
      u = x(s, "total") || this.getMaximumDomain(t), l = ["Group", "Value", "Percentage of total"], c = [
        ...t.map((h) => {
          let f;
          h.value !== null && h.value !== void 0 ? f = Number(h.value) : f = 0;
          let p = Number((h.value / u * 100).toFixed(2));
          return [
            h[r],
            h.value === null ? "&ndash;" : a(f, o),
            a(p, o) + " %"
          ];
        })
      ];
    return super.formatTable({ headers: l, cells: c });
  }
}, AL = class extends $r {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getOptions(), n = this.getGroupedData(), { angle: r, value: i } = x(t, "radar", "axes"), { number: s, code: a } = x(t, "locale"), o = x(n, "0", "data").map((u) => u[r]), l = ["Group", ...o], c = [
      ...n.map((u) => [
        u.name,
        ...o.map(
          (d, h) => x(u, "data", h, i) !== null ? s(x(u, "data", h, i), a) : "&ndash;"
        )
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
}, $L = class extends pn {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = ["Child", "Parent"], r = [];
    return t.forEach((i) => {
      this.getChildrenDatums(i, r), r.push([i.name, "&ndash;"]);
    }), super.formatTable({ headers: n, cells: r });
  }
  /**
   * Determine the child parent relationship in nested data
   * @param datum: Object
   * @param result: Array<Object>
   */
  getChildrenDatums(t, n = []) {
    t.children && t.children.length > 0 && t.children.forEach((r) => {
      this.getChildrenDatums(r, n), n.push([r.name, t.name]);
    });
  }
}, LL = class extends pn {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), { number: n, code: r } = x(this.getOptions(), "locale"), i = ["Child", "Group", "Value"], s = [];
    return t.forEach((a) => {
      Array.isArray(a.children) ? a.children.forEach((o) => {
        s.push([
          o.name,
          a.name,
          o.value === null ? "&ndash;" : n(o.value, r)
        ]);
      }) : x(a.name) !== null && x(a.value) && s.push(["–", a.name, n(a.value, r)]);
    }), super.formatTable({ headers: i, cells: s });
  }
}, RL = class extends pn {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: i } = n.wordCloud, { groupMapsTo: s } = n.data, { code: a, number: o } = x(n, "locale"), l = [n.tooltip.wordLabel, "Group", n.tooltip.valueLabel], c = [
      ...t.map((u) => [
        u[i],
        u[s],
        o(u[r], a)
      ])
    ];
    return super.formatTable({ headers: l, cells: c });
  }
};
var kL = /\s/;
function DL(e) {
  for (var t = e.length; t-- && kL.test(e.charAt(t)); )
    ;
  return t;
}
var IL = /^\s+/;
function NL(e) {
  return e && e.slice(0, DL(e) + 1).replace(IL, "");
}
var Mf = NaN, PL = /^[-+]0x[0-9a-f]+$/i, UL = /^0b[01]+$/i, BL = /^0o[0-7]+$/i, HL = parseInt;
function ti(e) {
  if (typeof e == "number")
    return e;
  if (Uo(e))
    return Mf;
  if (He(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = He(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = NL(e);
  var n = UL.test(e);
  return n || BL.test(e) ? HL(e.slice(2), n ? 2 : 8) : PL.test(e) ? Mf : +e;
}
var Il = function() {
  return tn.Date.now();
}, VL = "Expected a function", FL = Math.max, zL = Math.min;
function po(e, t, n) {
  var r, i, s, a, o, l, c = 0, u = !1, d = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(VL);
  t = ti(t) || 0, He(n) && (u = !!n.leading, d = "maxWait" in n, s = d ? FL(ti(n.maxWait) || 0, t) : s, h = "trailing" in n ? !!n.trailing : h);
  function f(S) {
    var L = r, D = i;
    return r = i = void 0, c = S, a = e.apply(D, L), a;
  }
  function p(S) {
    return c = S, o = setTimeout(y, t), u ? f(S) : a;
  }
  function v(S) {
    var L = S - l, D = S - c, k = t - L;
    return d ? zL(k, s - D) : k;
  }
  function m(S) {
    var L = S - l, D = S - c;
    return l === void 0 || L >= t || L < 0 || d && D >= s;
  }
  function y() {
    var S = Il();
    if (m(S))
      return g(S);
    o = setTimeout(y, v(S));
  }
  function g(S) {
    return o = void 0, h && r ? f(S) : (r = i = void 0, a);
  }
  function b() {
    o !== void 0 && clearTimeout(o), c = 0, r = l = i = o = void 0;
  }
  function w() {
    return o === void 0 ? a : g(Il());
  }
  function _() {
    var S = Il(), L = m(S);
    if (r = arguments, i = this, l = S, L) {
      if (o === void 0)
        return p(l);
      if (d)
        return clearTimeout(o), o = setTimeout(y, t), f(l);
    }
    return o === void 0 && (o = setTimeout(y, t)), a;
  }
  return _.cancel = b, _.flush = w, _;
}
function GL(e, t) {
  if (e.match(/^[a-z]+:\/\//i))
    return e;
  if (e.match(/^\/\//))
    return window.location.protocol + e;
  if (e.match(/^[a-z]+:/i))
    return e;
  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(i), t && (r.href = t), i.href = e, i.href;
}
const jL = /* @__PURE__ */ (() => {
  let e = 0;
  const t = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (e += 1, `u${t()}${e}`);
})();
function An(e) {
  const t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t.push(e[n]);
  return t;
}
function mo(e, t) {
  const n = (e.ownerDocument.defaultView || window).getComputedStyle(e).getPropertyValue(t);
  return n ? parseFloat(n.replace("px", "")) : 0;
}
function WL(e) {
  const t = mo(e, "border-left-width"), n = mo(e, "border-right-width");
  return e.clientWidth + t + n;
}
function qL(e) {
  const t = mo(e, "border-top-width"), n = mo(e, "border-bottom-width");
  return e.clientHeight + t + n;
}
function Pv(e, t = {}) {
  const n = t.width || WL(e), r = t.height || qL(e);
  return { width: n, height: r };
}
function YL() {
  let e, t;
  try {
    t = process;
  } catch {
  }
  const n = t && t.env ? t.env.devicePixelRatio : null;
  return n && (e = parseInt(n, 10), Number.isNaN(e) && (e = 1)), e || window.devicePixelRatio || 1;
}
const Oe = 16384;
function XL(e) {
  (e.width > Oe || e.height > Oe) && (e.width > Oe && e.height > Oe ? e.width > e.height ? (e.height *= Oe / e.width, e.width = Oe) : (e.width *= Oe / e.height, e.height = Oe) : e.width > Oe ? (e.height *= Oe / e.width, e.width = Oe) : (e.width *= Oe / e.height, e.height = Oe));
}
function go(e) {
  return new Promise((t, n) => {
    const r = new Image();
    r.decode = () => t(r), r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = e;
  });
}
async function ZL(e) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(e)).then(encodeURIComponent).then((t) => `data:image/svg+xml;charset=utf-8,${t}`);
}
async function KL(e, t, n) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), s = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${t}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${t} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(e), ZL(i);
}
const be = (e, t) => {
  if (e instanceof t)
    return !0;
  const n = Object.getPrototypeOf(e);
  return n === null ? !1 : n.constructor.name === t.name || be(n, t);
};
function QL(e) {
  const t = e.getPropertyValue("content");
  return `${e.cssText} content: '${t.replace(/'|"/g, "")}';`;
}
function JL(e) {
  return An(e).map((t) => {
    const n = e.getPropertyValue(t), r = e.getPropertyPriority(t);
    return `${t}: ${n}${r ? " !important" : ""};`;
  }).join(" ");
}
function tR(e, t, n) {
  const r = `.${e}:${t}`, i = n.cssText ? QL(n) : JL(n);
  return document.createTextNode(`${r}{${i}}`);
}
function Cf(e, t, n) {
  const r = window.getComputedStyle(e, n), i = r.getPropertyValue("content");
  if (i === "" || i === "none")
    return;
  const s = jL();
  try {
    t.className = `${t.className} ${s}`;
  } catch {
    return;
  }
  const a = document.createElement("style");
  a.appendChild(tR(s, n, r)), t.appendChild(a);
}
function eR(e, t) {
  Cf(e, t, ":before"), Cf(e, t, ":after");
}
const Af = "application/font-woff", $f = "image/jpeg", nR = {
  woff: Af,
  woff2: Af,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: $f,
  jpeg: $f,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function rR(e) {
  const t = /\.([^./]*?)$/g.exec(e);
  return t ? t[1] : "";
}
function sh(e) {
  const t = rR(e).toLowerCase();
  return nR[t] || "";
}
function iR(e) {
  return e.split(/,/)[1];
}
function Dc(e) {
  return e.search(/^(data:)/) !== -1;
}
function Uv(e, t) {
  return `data:${t};base64,${e}`;
}
async function Bv(e, t, n) {
  const r = await fetch(e, t);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((s, a) => {
    const o = new FileReader();
    o.onerror = a, o.onloadend = () => {
      try {
        s(n({ res: r, result: o.result }));
      } catch (l) {
        a(l);
      }
    }, o.readAsDataURL(i);
  });
}
const Nl = {};
function sR(e, t, n) {
  let r = e.replace(/\?.*/, "");
  return n && (r = e), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), t ? `[${t}]${r}` : r;
}
async function ah(e, t, n) {
  const r = sR(e, t, n.includeQueryParams);
  if (Nl[r] != null)
    return Nl[r];
  n.cacheBust && (e += (/\?/.test(e) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const s = await Bv(e, n.fetchRequestInit, ({ res: a, result: o }) => (t || (t = a.headers.get("Content-Type") || ""), iR(o)));
    i = Uv(s, t);
  } catch (s) {
    i = n.imagePlaceholder || "";
    let a = `Failed to fetch resource: ${e}`;
    s && (a = typeof s == "string" ? s : s.message), a && console.warn(a);
  }
  return Nl[r] = i, i;
}
async function aR(e) {
  const t = e.toDataURL();
  return t === "data:," ? e.cloneNode(!1) : go(t);
}
async function oR(e, t) {
  if (e.currentSrc) {
    const s = document.createElement("canvas"), a = s.getContext("2d");
    s.width = e.clientWidth, s.height = e.clientHeight, a == null || a.drawImage(e, 0, 0, s.width, s.height);
    const o = s.toDataURL();
    return go(o);
  }
  const n = e.poster, r = sh(n), i = await ah(n, r, t);
  return go(i);
}
async function lR(e) {
  var t;
  try {
    if (!((t = e == null ? void 0 : e.contentDocument) === null || t === void 0) && t.body)
      return await Xo(e.contentDocument.body, {}, !0);
  } catch {
  }
  return e.cloneNode(!1);
}
async function cR(e, t) {
  return be(e, HTMLCanvasElement) ? aR(e) : be(e, HTMLVideoElement) ? oR(e, t) : be(e, HTMLIFrameElement) ? lR(e) : e.cloneNode(!1);
}
const uR = (e) => e.tagName != null && e.tagName.toUpperCase() === "SLOT";
async function hR(e, t, n) {
  var r, i;
  let s = [];
  return uR(e) && e.assignedNodes ? s = An(e.assignedNodes()) : be(e, HTMLIFrameElement) && !((r = e.contentDocument) === null || r === void 0) && r.body ? s = An(e.contentDocument.body.childNodes) : s = An(((i = e.shadowRoot) !== null && i !== void 0 ? i : e).childNodes), s.length === 0 || be(e, HTMLVideoElement) || await s.reduce((a, o) => a.then(() => Xo(o, n)).then((l) => {
    l && t.appendChild(l);
  }), Promise.resolve()), t;
}
function dR(e, t) {
  const n = t.style;
  if (!n)
    return;
  const r = window.getComputedStyle(e);
  r.cssText ? (n.cssText = r.cssText, n.transformOrigin = r.transformOrigin) : An(r).forEach((i) => {
    let s = r.getPropertyValue(i);
    i === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), be(e, HTMLIFrameElement) && i === "display" && s === "inline" && (s = "block"), i === "d" && t.getAttribute("d") && (s = `path(${t.getAttribute("d")})`), n.setProperty(i, s, r.getPropertyPriority(i));
  });
}
function fR(e, t) {
  be(e, HTMLTextAreaElement) && (t.innerHTML = e.value), be(e, HTMLInputElement) && t.setAttribute("value", e.value);
}
function pR(e, t) {
  if (be(e, HTMLSelectElement)) {
    const n = t, r = Array.from(n.children).find((i) => e.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function mR(e, t) {
  return be(t, Element) && (dR(e, t), eR(e, t), fR(e, t), pR(e, t)), t;
}
async function gR(e, t) {
  const n = e.querySelectorAll ? e.querySelectorAll("use") : [];
  if (n.length === 0)
    return e;
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const a = n[s].getAttribute("xlink:href");
    if (a) {
      const o = e.querySelector(a), l = document.querySelector(a);
      !o && l && !r[a] && (r[a] = await Xo(l, t, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const s = "http://www.w3.org/1999/xhtml", a = document.createElementNS(s, "svg");
    a.setAttribute("xmlns", s), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";
    const o = document.createElementNS(s, "defs");
    a.appendChild(o);
    for (let l = 0; l < i.length; l++)
      o.appendChild(i[l]);
    e.appendChild(a);
  }
  return e;
}
async function Xo(e, t, n) {
  return !n && t.filter && !t.filter(e) ? null : Promise.resolve(e).then((r) => cR(r, t)).then((r) => hR(e, r, t)).then((r) => mR(e, r)).then((r) => gR(r, t));
}
const Hv = /url\((['"]?)([^'"]+?)\1\)/g, vR = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, yR = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function xR(e) {
  const t = e.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${t})(['"]?\\))`, "g");
}
function bR(e) {
  const t = [];
  return e.replace(Hv, (n, r, i) => (t.push(i), n)), t.filter((n) => !Dc(n));
}
async function ER(e, t, n, r, i) {
  try {
    const s = n ? GL(t, n) : t, a = sh(t);
    let o;
    if (i) {
      const l = await i(s);
      o = Uv(l, a);
    } else
      o = await ah(s, a, r);
    return e.replace(xR(t), `$1${o}$3`);
  } catch {
  }
  return e;
}
function _R(e, { preferredFontFormat: t }) {
  return t ? e.replace(yR, (n) => {
    for (; ; ) {
      const [r, , i] = vR.exec(n) || [];
      if (!i)
        return "";
      if (i === t)
        return `src: ${r};`;
    }
  }) : e;
}
function Vv(e) {
  return e.search(Hv) !== -1;
}
async function Fv(e, t, n) {
  if (!Vv(e))
    return e;
  const r = _R(e, n);
  return bR(r).reduce((i, s) => i.then((a) => ER(a, s, t, n)), Promise.resolve(r));
}
async function ua(e, t, n) {
  var r;
  const i = (r = t.style) === null || r === void 0 ? void 0 : r.getPropertyValue(e);
  if (i) {
    const s = await Fv(i, null, n);
    return t.style.setProperty(e, s, t.style.getPropertyPriority(e)), !0;
  }
  return !1;
}
async function wR(e, t) {
  await ua("background", e, t) || await ua("background-image", e, t), await ua("mask", e, t) || await ua("mask-image", e, t);
}
async function SR(e, t) {
  const n = be(e, HTMLImageElement);
  if (!(n && !Dc(e.src)) && !(be(e, SVGImageElement) && !Dc(e.href.baseVal)))
    return;
  const r = n ? e.src : e.href.baseVal, i = await ah(r, sh(r), t);
  await new Promise((s, a) => {
    e.onload = s, e.onerror = a;
    const o = e;
    o.decode && (o.decode = s), o.loading === "lazy" && (o.loading = "eager"), n ? (e.srcset = "", e.src = i) : e.href.baseVal = i;
  });
}
async function OR(e, t) {
  const n = An(e.childNodes).map((r) => zv(r, t));
  await Promise.all(n).then(() => e);
}
async function zv(e, t) {
  be(e, Element) && (await wR(e, t), await SR(e, t), await OR(e, t));
}
function TR(e, t) {
  const { style: n } = e;
  t.backgroundColor && (n.backgroundColor = t.backgroundColor), t.width && (n.width = `${t.width}px`), t.height && (n.height = `${t.height}px`);
  const r = t.style;
  return r != null && Object.keys(r).forEach((i) => {
    n[i] = r[i];
  }), e;
}
const Lf = {};
async function Rf(e) {
  let t = Lf[e];
  if (t != null)
    return t;
  const n = await (await fetch(e)).text();
  return t = { url: e, cssText: n }, Lf[e] = t, t;
}
async function kf(e, t) {
  let n = e.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, i = (n.match(/url\([^)]+\)/g) || []).map(async (s) => {
    let a = s.replace(r, "$1");
    return a.startsWith("https://") || (a = new URL(a, e.url).href), Bv(a, t.fetchRequestInit, ({ result: o }) => (n = n.replace(s, `url(${o})`), [s, o]));
  });
  return Promise.all(i).then(() => n);
}
function Df(e) {
  if (e == null)
    return [];
  const t = [], n = /(\/\*[\s\S]*?\*\/)/gi;
  let r = e.replace(n, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const l = i.exec(r);
    if (l === null)
      break;
    t.push(l[0]);
  }
  r = r.replace(i, "");
  const s = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", o = new RegExp(a, "gi");
  for (; ; ) {
    let l = s.exec(r);
    if (l === null) {
      if (l = o.exec(r), l === null)
        break;
      s.lastIndex = o.lastIndex;
    } else
      o.lastIndex = s.lastIndex;
    t.push(l[0]);
  }
  return t;
}
async function MR(e, t) {
  const n = [], r = [];
  return e.forEach((i) => {
    if ("cssRules" in i)
      try {
        An(i.cssRules || []).forEach((s, a) => {
          if (s.type === CSSRule.IMPORT_RULE) {
            let o = a + 1;
            const l = s.href, c = Rf(l).then((u) => kf(u, t)).then((u) => Df(u).forEach((d) => {
              try {
                i.insertRule(d, d.startsWith("@import") ? o += 1 : i.cssRules.length);
              } catch (h) {
                console.error("Error inserting rule from remote css", {
                  rule: d,
                  error: h
                });
              }
            })).catch((u) => {
              console.error("Error loading remote css", u.toString());
            });
            r.push(c);
          }
        });
      } catch (s) {
        const a = e.find((o) => o.href == null) || document.styleSheets[0];
        i.href != null && r.push(Rf(i.href).then((o) => kf(o, t)).then((o) => Df(o).forEach((l) => {
          a.insertRule(l, i.cssRules.length);
        })).catch((o) => {
          console.error("Error loading remote stylesheet", o);
        })), console.error("Error inlining remote css file", s);
      }
  }), Promise.all(r).then(() => (e.forEach((i) => {
    if ("cssRules" in i)
      try {
        An(i.cssRules || []).forEach((s) => {
          n.push(s);
        });
      } catch (s) {
        console.error(`Error while reading CSS rules from ${i.href}`, s);
      }
  }), n));
}
function CR(e) {
  return e.filter((t) => t.type === CSSRule.FONT_FACE_RULE).filter((t) => Vv(t.style.getPropertyValue("src")));
}
async function AR(e, t) {
  if (e.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const n = An(e.ownerDocument.styleSheets), r = await MR(n, t);
  return CR(r);
}
async function $R(e, t) {
  const n = await AR(e, t);
  return (await Promise.all(n.map((r) => {
    const i = r.parentStyleSheet ? r.parentStyleSheet.href : null;
    return Fv(r.cssText, i, t);
  }))).join(`
`);
}
async function LR(e, t) {
  const n = t.fontEmbedCSS != null ? t.fontEmbedCSS : t.skipFonts ? null : await $R(e, t);
  if (n) {
    const r = document.createElement("style"), i = document.createTextNode(n);
    r.appendChild(i), e.firstChild ? e.insertBefore(r, e.firstChild) : e.appendChild(r);
  }
}
async function RR(e, t = {}) {
  const { width: n, height: r } = Pv(e, t), i = await Xo(e, t, !0);
  return await LR(i, t), await zv(i, t), TR(i, t), await KL(i, n, r);
}
async function Gv(e, t = {}) {
  const { width: n, height: r } = Pv(e, t), i = await RR(e, t), s = await go(i), a = document.createElement("canvas"), o = a.getContext("2d"), l = t.pixelRatio || YL(), c = t.canvasWidth || n, u = t.canvasHeight || r;
  return a.width = c * l, a.height = u * l, t.skipAutoScale || XL(a), a.style.width = `${c}`, a.style.height = `${u}`, t.backgroundColor && (o.fillStyle = t.backgroundColor, o.fillRect(0, 0, a.width, a.height)), o.drawImage(s, 0, 0, a.width, a.height), a;
}
async function kR(e, t = {}) {
  return (await Gv(e, t)).toDataURL();
}
async function DR(e, t = {}) {
  return (await Gv(e, t)).toDataURL("image/jpeg", t.quality || 1);
}
class Bn {
  constructor(t, n) {
    this.model = t, this.services = n, this.init();
  }
  init() {
  }
  update() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down services to the components
  setServices(t) {
    this.services = t;
  }
}
const IR = "DONT_STYLE_ME_css_styles_verifier";
let N = class Ic extends Bn {
  // initialized in initializeID() called by init()
  constructor(t, n) {
    super(t, n);
  }
  static getHTMLElementSize(t) {
    return {
      width: t.clientWidth,
      height: t.clientHeight
    };
  }
  static getSVGElementSize(t, n = {
    useAttrs: !1,
    useClientDimensions: !1,
    useBBox: !1,
    useBoundingRect: !1
  }) {
    t.attr || (t = I(t));
    const r = {
      width: 0,
      height: 0
    }, i = (h) => {
      h && Object.keys(r).forEach((f) => {
        if (h[f]) {
          const p = h[f], v = parseFloat(p);
          p && v > r[f] && ("" + p).indexOf("%") === -1 && (r[f] = v);
        }
      });
    }, s = {
      width: t.attr("width"),
      height: t.attr("height")
    }, a = t.node();
    let o, l, c, u;
    try {
      typeof a.getBBox == "function" && (o = a.getBBox(), l = {
        width: o.width,
        height: o.height
      });
    } catch (h) {
      console.error(h);
    }
    try {
      typeof (a == null ? void 0 : a.getBoundingClientRect) == "function" && (c = a.getBoundingClientRect(), u = {
        width: c.width,
        height: c.height
      });
    } catch (h) {
      console.error(h);
    }
    let d;
    if (a instanceof SVGSVGElement && (d = {
      width: a.clientWidth,
      height: a.clientHeight
    }), n) {
      if (n.useAttrs && (i(s), r.width > 0 && r.height > 0))
        return r;
      if (n.useClientDimensions && (i(d), r.width > 0 && r.height > 0))
        return d;
      if (n.useBBox && (i(l), r.width > 0 && r.height > 0))
        return l;
      if (n.useBoundingRect && (i(u), r.width > 0 && r.height > 0))
        return u;
    }
    try {
      const h = {
        width: x(t.node(), "width", "baseVal", "value"),
        height: x(t.node(), "height", "baseVal", "value")
      };
      i(h);
    } catch {
      i(d), i(l), i(s);
    }
    return r;
  }
  static appendOrSelect(t, n) {
    const r = t.select(`${n}`);
    if (r.empty()) {
      let i = n.split("#"), s, a;
      return i.length === 2 ? (s = i[0], i = i[1].split("."), a = i[0]) : (i = n.split("."), s = i[0]), t.append(s).attr("id", a).attr("class", i.slice(1).join(" "));
    }
    return r;
  }
  init() {
    this.initializeID(), this.styleHolderElement(), this.addMainContainer(), this.model.getOptions().resizable && this.addResizeListener(), this.addHolderListeners(), this.handleFullscreenChange();
  }
  getChartID() {
    return this.chartID;
  }
  getElementOffset(t, n = !1) {
    const r = { left: 0, top: 0 }, i = t.getBoundingClientRect(), s = n ? { left: 0, top: 0 } : this.getHolder().getBoundingClientRect();
    try {
      r.left = i.left - s.left, r.top = i.top - s.top;
    } catch (a) {
      console.error(a);
    }
    return r;
  }
  generateElementIDString(t) {
    return `chart-${this.chartID}-${t}`;
  }
  initializeID() {
    this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
  }
  addMainContainer() {
    const t = this.model.getOptions(), n = x(t, "style", "prefix"), r = I(this.getHolder()).append("div").classed(`${ve}--${n}--chart-wrapper`, !0).attr("id", `chart-${this.getChartID()}`).style("height", "100%").style("width", "100%");
    r.append("g").attr("class", IR), this.mainContainer = r.node();
  }
  update() {
    this.styleHolderElement();
  }
  styleHolderElement() {
    const t = this.getHolder(), { width: n, height: r, theme: i } = this.model.getOptions();
    n !== this.width && (t.style.width = n, this.width = n), r !== this.height && (t.style.height = r, this.height = r), I(this.getHolder()).classed(`${ve}--chart-holder`, !0).attr("data-carbon-theme", i);
  }
  getHolder() {
    return this.model.get("holder");
  }
  exportToJPG() {
    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);
    i.classed("filled", !0), DR(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      var a;
      let o = "myChart";
      const l = x(n, "fileDownload", "fileName");
      typeof l == "function" ? o = l("jpg") : typeof l == "string" && (o = l), (a = t.services.files) == null || a.downloadImage(s, `${o}.jpg`), i.classed("filled", !1);
    });
  }
  exportToPNG() {
    const t = this, n = this.model.getOptions(), r = this.getHolder(), i = I(r);
    i.classed("filled", !0), kR(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (s) => !(s.classList && s.classList.contains("cds--cc--toolbar"))
    }).then(function(s) {
      var a;
      let o = "myChart";
      const l = x(n, "fileDownload", "fileName");
      typeof l == "function" ? o = l("png") : typeof l == "string" && (o = l), (a = t.services.files) == null || a.downloadImage(s, `${o}.png`), i.classed("filled", !1);
    }).catch(function(s) {
      console.error("oops, something went wrong!", s);
    });
  }
  isFullScreenMode() {
    return I(this.getHolder()).classed("fullscreen");
  }
  toggleFullscreen() {
    const t = this.getHolder();
    I(t).classed("fullscreen") && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen() : t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen();
  }
  handleFullscreenChange() {
    document.addEventListener("fullscreenchange", () => {
      const t = I(this.getHolder()), n = t.classed("fullscreen");
      t.classed("fullscreen", !n);
    });
  }
  setSVGMaxHeight() {
    if (!this.model.getOptions().height) {
      const { height: t } = Ic.getSVGElementSize(
        I(this.mainContainer),
        {
          useBBox: !0
        }
      ), n = I(this.mainContainer).attr("class"), r = I(this.mainContainer).selectAll(`.${n} > svg`);
      let i = 0;
      r.nodes().forEach(function(s) {
        i += Number(
          Ic.getSVGElementSize(I(s), {
            useBBox: !0
          }).height
        );
      }), i <= t ? I(this.mainContainer).attr("height", i) : I(this.mainContainer).attr("height", "100%");
    }
  }
  getMainContainer() {
    return this.mainContainer;
  }
  addHolderListeners() {
    const t = this.getHolder();
    t && I(t).on("mouseover", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(O.Chart.MOUSEOVER);
    }).on("mouseout", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(O.Chart.MOUSEOUT);
    });
  }
  addResizeListener() {
    const t = this.getHolder();
    if (!t)
      return;
    let n = t.clientWidth, r = t.clientHeight;
    const i = po(() => {
      var s;
      t && (Math.abs(n - t.clientWidth) > 1 || Math.abs(r - t.clientHeight) > 1) && (n = t.clientWidth, r = t.clientHeight, (s = this.services.events) == null || s.dispatchEvent(O.Chart.RESIZE));
    }, 12.5);
    new ResizeObserver(i).observe(t);
  }
}, Nc = class jv extends Bn {
  static appendOrUpdateLinearGradient(t) {
    let n = t.svg.select(`defs linearGradient#${t.id}`);
    n.empty() && (n = t.svg.append("defs").append("linearGradient").attr("id", t.id).attr("x1", t.x1).attr("x2", t.x2).attr("y1", t.y1).attr("y2", t.y2)), n.selectAll("stop").remove(), n.selectAll("stop").data(t.stops).enter().append("stop").attr("offset", (r) => r.offset).style("stop-color", (r) => r.color).style("stop-opacity", (r) => r.opacity);
  }
  static getOffsetRatio(t) {
    return (Math.abs(t[1]) * 100 / Math.abs(t[0] - t[1])).toFixed(2) + "%";
  }
  static getStops(t, n) {
    const r = t[0] < 0 && t[1] > 0;
    let i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: "80%",
        color: n,
        opacity: "0"
      }
    ];
    return r && (i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: jv.getOffsetRatio(t),
        color: n,
        opacity: "0"
      },
      {
        offset: "100%",
        color: n,
        opacity: "0.6"
      }
    ]), i;
  }
};
function If(e) {
  const t = NR(Wv(e), 360);
  return Wn(t, [0, 10]) || Wn(t, [350, 0]) ? {
    textAnchor: xn.START,
    dominantBaseline: bn.MIDDLE
  } : Wn(t, [10, 80]) ? {
    textAnchor: xn.START,
    dominantBaseline: bn.HANGING
  } : Wn(t, [80, 100]) ? {
    textAnchor: xn.MIDDLE,
    dominantBaseline: bn.HANGING
  } : Wn(t, [100, 170]) ? {
    textAnchor: xn.END,
    dominantBaseline: bn.HANGING
  } : Wn(t, [170, 190]) ? {
    textAnchor: xn.END,
    dominantBaseline: bn.MIDDLE
  } : Wn(t, [190, 260]) ? {
    textAnchor: xn.END,
    dominantBaseline: bn.BASELINE
  } : Wn(t, [260, 280]) ? {
    textAnchor: xn.MIDDLE,
    dominantBaseline: bn.BASELINE
  } : {
    textAnchor: xn.START,
    dominantBaseline: bn.BASELINE
  };
}
function NR(e, t) {
  return (e % t + t) % t;
}
function Wn(e, [t, n]) {
  return e >= t && e <= n;
}
function Wv(e) {
  return e * (180 / Math.PI);
}
function Yt(e, t, n = { x: 0, y: 0 }) {
  const r = t * Math.cos(e) + n.x, i = t * Math.sin(e) + n.y;
  return { x: isNaN(r) ? 0 : r, y: isNaN(i) ? 0 : i };
}
function PR(e, t) {
  return t * Math.sin(e - Math.PI / 2);
}
function Nf(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function UR(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Pl(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function BR(e) {
  return e.depth;
}
function HR(e, t) {
  return t - 1 - e.height;
}
function qv(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function ha(e) {
  return function() {
    return e;
  };
}
function Pf(e, t) {
  return vo(e.source, t.source) || e.index - t.index;
}
function Uf(e, t) {
  return vo(e.target, t.target) || e.index - t.index;
}
function vo(e, t) {
  return e.y0 - t.y0;
}
function Ul(e) {
  return e.value;
}
function VR(e) {
  return e.index;
}
function FR(e) {
  return e.nodes;
}
function zR(e) {
  return e.links;
}
function Bf(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function Hf({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function GR() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, s = 8, a, o = VR, l = qv, c, u, d = FR, h = zR, f = 6;
  function p() {
    const E = { nodes: d.apply(null, arguments), links: h.apply(null, arguments) };
    return v(E), m(E), y(E), g(E), _(E), Hf(E), E;
  }
  p.update = function(E) {
    return Hf(E), E;
  }, p.nodeId = function(E) {
    return arguments.length ? (o = typeof E == "function" ? E : ha(E), p) : o;
  }, p.nodeAlign = function(E) {
    return arguments.length ? (l = typeof E == "function" ? E : ha(E), p) : l;
  }, p.nodeSort = function(E) {
    return arguments.length ? (c = E, p) : c;
  }, p.nodeWidth = function(E) {
    return arguments.length ? (i = +E, p) : i;
  }, p.nodePadding = function(E) {
    return arguments.length ? (s = a = +E, p) : s;
  }, p.nodes = function(E) {
    return arguments.length ? (d = typeof E == "function" ? E : ha(E), p) : d;
  }, p.links = function(E) {
    return arguments.length ? (h = typeof E == "function" ? E : ha(E), p) : h;
  }, p.linkSort = function(E) {
    return arguments.length ? (u = E, p) : u;
  }, p.size = function(E) {
    return arguments.length ? (e = t = 0, n = +E[0], r = +E[1], p) : [n - e, r - t];
  }, p.extent = function(E) {
    return arguments.length ? (e = +E[0][0], n = +E[1][0], t = +E[0][1], r = +E[1][1], p) : [[e, t], [n, r]];
  }, p.iterations = function(E) {
    return arguments.length ? (f = +E, p) : f;
  };
  function v({ nodes: E, links: A }) {
    for (const [U, B] of E.entries())
      B.index = U, B.sourceLinks = [], B.targetLinks = [];
    const $ = new Map(E.map((U, B) => [o(U, B, E), U]));
    for (const [U, B] of A.entries()) {
      B.index = U;
      let { source: W, target: K } = B;
      typeof W != "object" && (W = B.source = Bf($, W)), typeof K != "object" && (K = B.target = Bf($, K)), W.sourceLinks.push(B), K.targetLinks.push(B);
    }
    if (u != null)
      for (const { sourceLinks: U, targetLinks: B } of E)
        U.sort(u), B.sort(u);
  }
  function m({ nodes: E }) {
    for (const A of E)
      A.value = A.fixedValue === void 0 ? Math.max(Pl(A.sourceLinks, Ul), Pl(A.targetLinks, Ul)) : A.fixedValue;
  }
  function y({ nodes: E }) {
    const A = E.length;
    let $ = new Set(E), U = /* @__PURE__ */ new Set(), B = 0;
    for (; $.size; ) {
      for (const W of $) {
        W.depth = B;
        for (const { target: K } of W.sourceLinks)
          U.add(K);
      }
      if (++B > A)
        throw new Error("circular link");
      $ = U, U = /* @__PURE__ */ new Set();
    }
  }
  function g({ nodes: E }) {
    const A = E.length;
    let $ = new Set(E), U = /* @__PURE__ */ new Set(), B = 0;
    for (; $.size; ) {
      for (const W of $) {
        W.height = B;
        for (const { source: K } of W.targetLinks)
          U.add(K);
      }
      if (++B > A)
        throw new Error("circular link");
      $ = U, U = /* @__PURE__ */ new Set();
    }
  }
  function b({ nodes: E }) {
    const A = Nf(E, (B) => B.depth) + 1, $ = (n - e - i) / (A - 1), U = new Array(A);
    for (const B of E) {
      const W = Math.max(0, Math.min(A - 1, Math.floor(l.call(null, B, A))));
      B.layer = W, B.x0 = e + W * $, B.x1 = B.x0 + i, U[W] ? U[W].push(B) : U[W] = [B];
    }
    if (c)
      for (const B of U)
        B.sort(c);
    return U;
  }
  function w(E) {
    const A = UR(E, ($) => (r - t - ($.length - 1) * a) / Pl($, Ul));
    for (const $ of E) {
      let U = t;
      for (const B of $) {
        B.y0 = U, B.y1 = U + B.value * A, U = B.y1 + a;
        for (const W of B.sourceLinks)
          W.width = W.value * A;
      }
      U = (r - U + a) / ($.length + 1);
      for (let B = 0; B < $.length; ++B) {
        const W = $[B];
        W.y0 += U * (B + 1), W.y1 += U * (B + 1);
      }
      V($);
    }
  }
  function _(E) {
    const A = b(E);
    a = Math.min(s, (r - t) / (Nf(A, ($) => $.length) - 1)), w(A);
    for (let $ = 0; $ < f; ++$) {
      const U = Math.pow(0.99, $), B = Math.max(1 - U, ($ + 1) / f);
      L(A, U, B), S(A, U, B);
    }
  }
  function S(E, A, $) {
    for (let U = 1, B = E.length; U < B; ++U) {
      const W = E[U];
      for (const K of W) {
        let Q = 0, dt = 0;
        for (const { source: pt, value: Z } of K.targetLinks) {
          let tt = Z * (K.layer - pt.layer);
          Q += P(pt, K) * tt, dt += tt;
        }
        if (!(dt > 0))
          continue;
        let it = (Q / dt - K.y0) * A;
        K.y0 += it, K.y1 += it, M(K);
      }
      c === void 0 && W.sort(vo), D(W, $);
    }
  }
  function L(E, A, $) {
    for (let U = E.length, B = U - 2; B >= 0; --B) {
      const W = E[B];
      for (const K of W) {
        let Q = 0, dt = 0;
        for (const { target: pt, value: Z } of K.sourceLinks) {
          let tt = Z * (pt.layer - K.layer);
          Q += H(K, pt) * tt, dt += tt;
        }
        if (!(dt > 0))
          continue;
        let it = (Q / dt - K.y0) * A;
        K.y0 += it, K.y1 += it, M(K);
      }
      c === void 0 && W.sort(vo), D(W, $);
    }
  }
  function D(E, A) {
    const $ = E.length >> 1, U = E[$];
    R(E, U.y0 - a, $ - 1, A), k(E, U.y1 + a, $ + 1, A), R(E, r, E.length - 1, A), k(E, t, 0, A);
  }
  function k(E, A, $, U) {
    for (; $ < E.length; ++$) {
      const B = E[$], W = (A - B.y0) * U;
      W > 1e-6 && (B.y0 += W, B.y1 += W), A = B.y1 + a;
    }
  }
  function R(E, A, $, U) {
    for (; $ >= 0; --$) {
      const B = E[$], W = (B.y1 - A) * U;
      W > 1e-6 && (B.y0 -= W, B.y1 -= W), A = B.y0 - a;
    }
  }
  function M({ sourceLinks: E, targetLinks: A }) {
    if (u === void 0) {
      for (const { source: { sourceLinks: $ } } of A)
        $.sort(Uf);
      for (const { target: { targetLinks: $ } } of E)
        $.sort(Pf);
    }
  }
  function V(E) {
    if (u === void 0)
      for (const { sourceLinks: A, targetLinks: $ } of E)
        A.sort(Uf), $.sort(Pf);
  }
  function P(E, A) {
    let $ = E.y0 - (E.sourceLinks.length - 1) * a / 2;
    for (const { target: U, width: B } of E.sourceLinks) {
      if (U === A)
        break;
      $ += B + a;
    }
    for (const { source: U, width: B } of A.targetLinks) {
      if (U === E)
        break;
      $ -= B;
    }
    return $;
  }
  function H(E, A) {
    let $ = A.y0 - (A.targetLinks.length - 1) * a / 2;
    for (const { source: U, width: B } of A.targetLinks) {
      if (U === E)
        break;
      $ += B + a;
    }
    for (const { target: U, width: B } of E.sourceLinks) {
      if (U === A)
        break;
      $ -= B;
    }
    return $;
  }
  return p;
}
var Pc = Math.PI, Uc = 2 * Pc, cr = 1e-6, jR = Uc - cr;
function Bc() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Yv() {
  return new Bc();
}
Bc.prototype = Yv.prototype = {
  constructor: Bc,
  moveTo: function(e, t) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(e, t) {
    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(e, t, n, r) {
    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +n) + "," + (this._y1 = +r);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._ += "C" + +e + "," + +t + "," + +n + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +s);
  },
  arcTo: function(e, t, n, r, i) {
    e = +e, t = +t, n = +n, r = +r, i = +i;
    var s = this._x1, a = this._y1, o = n - e, l = r - t, c = s - e, u = a - t, d = c * c + u * u;
    if (i < 0)
      throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
    else if (d > cr)
      if (!(Math.abs(u * o - l * c) > cr) || !i)
        this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
      else {
        var h = n - s, f = r - a, p = o * o + l * l, v = h * h + f * f, m = Math.sqrt(p), y = Math.sqrt(d), g = i * Math.tan((Pc - Math.acos((p + d - v) / (2 * m * y))) / 2), b = g / y, w = g / m;
        Math.abs(b - 1) > cr && (this._ += "L" + (e + b * c) + "," + (t + b * u)), this._ += "A" + i + "," + i + ",0,0," + +(u * h > c * f) + "," + (this._x1 = e + w * o) + "," + (this._y1 = t + w * l);
      }
  },
  arc: function(e, t, n, r, i, s) {
    e = +e, t = +t, n = +n, s = !!s;
    var a = n * Math.cos(r), o = n * Math.sin(r), l = e + a, c = t + o, u = 1 ^ s, d = s ? r - i : i - r;
    if (n < 0)
      throw new Error("negative radius: " + n);
    this._x1 === null ? this._ += "M" + l + "," + c : (Math.abs(this._x1 - l) > cr || Math.abs(this._y1 - c) > cr) && (this._ += "L" + l + "," + c), n && (d < 0 && (d = d % Uc + Uc), d > jR ? this._ += "A" + n + "," + n + ",0,1," + u + "," + (e - a) + "," + (t - o) + "A" + n + "," + n + ",0,1," + u + "," + (this._x1 = l) + "," + (this._y1 = c) : d > cr && (this._ += "A" + n + "," + n + ",0," + +(d >= Pc) + "," + u + "," + (this._x1 = e + n * Math.cos(i)) + "," + (this._y1 = t + n * Math.sin(i))));
  },
  rect: function(e, t, n, r) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +n + "v" + +r + "h" + -n + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Vf(e) {
  return function() {
    return e;
  };
}
function WR(e) {
  return e[0];
}
function qR(e) {
  return e[1];
}
var YR = Array.prototype.slice;
function XR(e) {
  return e.source;
}
function ZR(e) {
  return e.target;
}
function KR(e) {
  var t = XR, n = ZR, r = WR, i = qR, s = null;
  function a() {
    var o, l = YR.call(arguments), c = t.apply(this, l), u = n.apply(this, l);
    if (s || (s = o = Yv()), e(s, +r.apply(this, (l[0] = c, l)), +i.apply(this, l), +r.apply(this, (l[0] = u, l)), +i.apply(this, l)), o)
      return s = null, o + "" || null;
  }
  return a.source = function(o) {
    return arguments.length ? (t = o, a) : t;
  }, a.target = function(o) {
    return arguments.length ? (n = o, a) : n;
  }, a.x = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : Vf(+o), a) : r;
  }, a.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : Vf(+o), a) : i;
  }, a.context = function(o) {
    return arguments.length ? (s = o ?? null, a) : s;
  }, a;
}
function QR(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function JR() {
  return KR(QR);
}
function tk(e) {
  return [e.source.x1, e.y0];
}
function ek(e) {
  return [e.target.x0, e.y1];
}
function nk() {
  return JR().source(tk).target(ek);
}
function Xv(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function rk(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var ik = { value: function() {
} };
function Zv() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Aa(n);
}
function Aa(e) {
  this._ = e;
}
function sk(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Aa.prototype = Zv.prototype = {
  constructor: Aa,
  on: function(e, t) {
    var n = this._, r = sk(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((i = (e = r[s]).type) && (i = ak(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type)
        n[i] = Ff(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Ff(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Aa(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, s; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r)
      s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
      r[i].value.apply(t, n);
  }
};
function ak(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Ff(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = ik, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
const ok = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: Zv
}, Symbol.toStringTag, { value: "Module" })), lk = /* @__PURE__ */ rk(ok), ck = lk.dispatch, Bl = Math.PI / 180, uk = {
  archimedean: Kv,
  rectangular: Ek
}, ns = 64, $a = 2048;
var hk = function() {
  var e = [256, 256], t = dk, n = fk, r = pk, i = zf, s = zf, a = mk, o = gk, l = Kv, c = [], u = 1 / 0, d = ck("word", "end"), h = null, f = Math.random, p = {}, v = wk;
  p.canvas = function(g) {
    return arguments.length ? (v = qn(g), p) : v;
  }, p.start = function() {
    var g = m(v()), b = _k((e[0] >> 5) * e[1]), w = null, _ = c.length, S = -1, L = [], D = c.map(function(R, M) {
      return R.text = t.call(this, R, M), R.font = n.call(this, R, M), R.style = i.call(this, R, M), R.weight = s.call(this, R, M), R.rotate = a.call(this, R, M), R.size = ~~r.call(this, R, M), R.padding = o.call(this, R, M), R;
    }).sort(function(R, M) {
      return M.size - R.size;
    });
    return h && clearInterval(h), h = setInterval(k, 0), k(), p;
    function k() {
      for (var R = Date.now(); Date.now() - R < u && ++S < _ && h; ) {
        var M = D[S];
        M.x = e[0] * (f() + 0.5) >> 1, M.y = e[1] * (f() + 0.5) >> 1, vk(g, M, D, S), M.hasText && y(b, M, w) && (L.push(M), d.call("word", p, M), w ? xk(w, M) : w = [{ x: M.x + M.x0, y: M.y + M.y0 }, { x: M.x + M.x1, y: M.y + M.y1 }], M.x -= e[0] >> 1, M.y -= e[1] >> 1);
      }
      S >= _ && (p.stop(), d.call("end", p, L, w));
    }
  }, p.stop = function() {
    h && (clearInterval(h), h = null);
    for (const g of c)
      delete g.sprite;
    return p;
  };
  function m(g) {
    const b = g.getContext("2d", { willReadFrequently: !0 });
    g.width = g.height = 1;
    const w = Math.sqrt(b.getImageData(0, 0, 1, 1).data.length >> 2);
    return g.width = (ns << 5) / w, g.height = $a / w, b.fillStyle = b.strokeStyle = "red", { context: b, ratio: w };
  }
  function y(g, b, w) {
    e[0], e[1];
    for (var _ = b.x, S = b.y, L = Math.sqrt(e[0] * e[0] + e[1] * e[1]), D = l(e), k = f() < 0.5 ? 1 : -1, R = -k, M, V, P; (M = D(R += k)) && (V = ~~M[0], P = ~~M[1], !(Math.min(Math.abs(V), Math.abs(P)) >= L)); )
      if (b.x = _ + V, b.y = S + P, !(b.x + b.x0 < 0 || b.y + b.y0 < 0 || b.x + b.x1 > e[0] || b.y + b.y1 > e[1]) && (!w || bk(b, w)) && !yk(b, g, e[0])) {
        for (var H = b.sprite, E = b.width >> 5, A = e[0] >> 5, $ = b.x - (E << 4), U = $ & 127, B = 32 - U, W = b.y1 - b.y0, K = (b.y + b.y0) * A + ($ >> 5), Q, dt = 0; dt < W; dt++) {
          Q = 0;
          for (var it = 0; it <= E; it++)
            g[K + it] |= Q << B | (it < E ? (Q = H[dt * E + it]) >>> U : 0);
          K += A;
        }
        return !0;
      }
    return !1;
  }
  return p.timeInterval = function(g) {
    return arguments.length ? (u = g ?? 1 / 0, p) : u;
  }, p.words = function(g) {
    return arguments.length ? (c = g, p) : c;
  }, p.size = function(g) {
    return arguments.length ? (e = [+g[0], +g[1]], p) : e;
  }, p.font = function(g) {
    return arguments.length ? (n = qn(g), p) : n;
  }, p.fontStyle = function(g) {
    return arguments.length ? (i = qn(g), p) : i;
  }, p.fontWeight = function(g) {
    return arguments.length ? (s = qn(g), p) : s;
  }, p.rotate = function(g) {
    return arguments.length ? (a = qn(g), p) : a;
  }, p.text = function(g) {
    return arguments.length ? (t = qn(g), p) : t;
  }, p.spiral = function(g) {
    return arguments.length ? (l = uk[g] || g, p) : l;
  }, p.fontSize = function(g) {
    return arguments.length ? (r = qn(g), p) : r;
  }, p.padding = function(g) {
    return arguments.length ? (o = qn(g), p) : o;
  }, p.random = function(g) {
    return arguments.length ? (f = g, p) : f;
  }, p.on = function() {
    var g = d.on.apply(d, arguments);
    return g === d ? p : g;
  }, p;
};
function dk(e) {
  return e.text;
}
function fk() {
  return "serif";
}
function zf() {
  return "normal";
}
function pk(e) {
  return Math.sqrt(e.value);
}
function mk() {
  return (~~(random() * 6) - 3) * 30;
}
function gk() {
  return 1;
}
function vk(e, t, n, r) {
  if (!t.sprite) {
    var i = e.context, s = e.ratio;
    i.clearRect(0, 0, (ns << 5) / s, $a / s);
    var a = 0, o = 0, l = 0, c = n.length;
    for (--r; ++r < c; ) {
      t = n[r], i.save(), i.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font;
      const M = i.measureText(t.text), V = -Math.floor(M.width / 2);
      let P = (M.width + 1) * s, H = t.size << 1;
      if (t.rotate) {
        var u = Math.sin(t.rotate * Bl), d = Math.cos(t.rotate * Bl), h = P * d, f = P * u, p = H * d, v = H * u;
        P = Math.max(Math.abs(h + v), Math.abs(h - v)) + 31 >> 5 << 5, H = ~~Math.max(Math.abs(f + p), Math.abs(f - p));
      } else
        P = P + 31 >> 5 << 5;
      if (H > l && (l = H), a + P >= ns << 5 && (a = 0, o += l, l = 0), o + H >= $a)
        break;
      i.translate((a + (P >> 1)) / s, (o + (H >> 1)) / s), t.rotate && i.rotate(t.rotate * Bl), i.fillText(t.text, V, 0), t.padding && (i.lineWidth = 2 * t.padding, i.strokeText(t.text, V, 0)), i.restore(), t.width = P, t.height = H, t.xoff = a, t.yoff = o, t.x1 = P >> 1, t.y1 = H >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += P;
    }
    for (var m = i.getImageData(0, 0, (ns << 5) / s, $a / s).data, y = []; --r >= 0; )
      if (t = n[r], !!t.hasText) {
        for (var g = t.width, b = g >> 5, w = t.y1 - t.y0, _ = 0; _ < w * b; _++)
          y[_] = 0;
        if (a = t.xoff, a == null)
          return;
        o = t.yoff;
        for (var S = 0, L = -1, D = 0; D < w; D++) {
          for (var _ = 0; _ < g; _++) {
            var k = b * D + (_ >> 5), R = m[(o + D) * (ns << 5) + (a + _) << 2] ? 1 << 31 - _ % 32 : 0;
            y[k] |= R, S |= R;
          }
          S ? L = D : (t.y0++, w--, D--, o++);
        }
        t.y1 = t.y0 + L, t.sprite = y.slice(0, (t.y1 - t.y0) * b);
      }
  }
}
function yk(e, t, n) {
  n >>= 5;
  for (var r = e.sprite, i = e.width >> 5, s = e.x - (i << 4), a = s & 127, o = 32 - a, l = e.y1 - e.y0, c = (e.y + e.y0) * n + (s >> 5), u, d = 0; d < l; d++) {
    u = 0;
    for (var h = 0; h <= i; h++)
      if ((u << o | (h < i ? (u = r[d * i + h]) >>> a : 0)) & t[c + h])
        return !0;
    c += n;
  }
  return !1;
}
function xk(e, t) {
  var n = e[0], r = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > r.x && (r.x = t.x + t.x1), t.y + t.y1 > r.y && (r.y = t.y + t.y1);
}
function bk(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function Kv(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function Ek(e) {
  var t = 4, n = t * e[0] / e[1], r = 0, i = 0;
  return function(s) {
    var a = s < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * a * s) - a & 3) {
      case 0:
        r += n;
        break;
      case 1:
        i += t;
        break;
      case 2:
        r -= n;
        break;
      default:
        i -= t;
        break;
    }
    return [r, i];
  };
}
function _k(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function wk() {
  return document.createElement("canvas");
}
function qn(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Sk = /* @__PURE__ */ Xv(hk);
function Ok(e, t, n, r) {
  var i = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++i]); ++i < s; )
    n = t(n, e[i], i, e);
  return n;
}
function Tk(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var Mk = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, Ck = Tk(Mk);
const Ak = Ck;
var $k = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Lk = "\\u0300-\\u036f", Rk = "\\ufe20-\\ufe2f", kk = "\\u20d0-\\u20ff", Dk = Lk + Rk + kk, Ik = "[" + Dk + "]", Nk = RegExp(Ik, "g");
function Pk(e) {
  return e = Hs(e), e && e.replace($k, Ak).replace(Nk, "");
}
var Uk = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Bk(e) {
  return e.match(Uk) || [];
}
var Hk = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Vk(e) {
  return Hk.test(e);
}
var Qv = "\\ud800-\\udfff", Fk = "\\u0300-\\u036f", zk = "\\ufe20-\\ufe2f", Gk = "\\u20d0-\\u20ff", jk = Fk + zk + Gk, Jv = "\\u2700-\\u27bf", t0 = "a-z\\xdf-\\xf6\\xf8-\\xff", Wk = "\\xac\\xb1\\xd7\\xf7", qk = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Yk = "\\u2000-\\u206f", Xk = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", e0 = "A-Z\\xc0-\\xd6\\xd8-\\xde", Zk = "\\ufe0e\\ufe0f", n0 = Wk + qk + Yk + Xk, r0 = "['’]", Gf = "[" + n0 + "]", Kk = "[" + jk + "]", i0 = "\\d+", Qk = "[" + Jv + "]", s0 = "[" + t0 + "]", a0 = "[^" + Qv + n0 + i0 + Jv + t0 + e0 + "]", Jk = "\\ud83c[\\udffb-\\udfff]", tD = "(?:" + Kk + "|" + Jk + ")", eD = "[^" + Qv + "]", o0 = "(?:\\ud83c[\\udde6-\\uddff]){2}", l0 = "[\\ud800-\\udbff][\\udc00-\\udfff]", zr = "[" + e0 + "]", nD = "\\u200d", jf = "(?:" + s0 + "|" + a0 + ")", rD = "(?:" + zr + "|" + a0 + ")", Wf = "(?:" + r0 + "(?:d|ll|m|re|s|t|ve))?", qf = "(?:" + r0 + "(?:D|LL|M|RE|S|T|VE))?", c0 = tD + "?", u0 = "[" + Zk + "]?", iD = "(?:" + nD + "(?:" + [eD, o0, l0].join("|") + ")" + u0 + c0 + ")*", sD = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", aD = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", oD = u0 + c0 + iD, lD = "(?:" + [Qk, o0, l0].join("|") + ")" + oD, cD = RegExp([
  zr + "?" + s0 + "+" + Wf + "(?=" + [Gf, zr, "$"].join("|") + ")",
  rD + "+" + qf + "(?=" + [Gf, zr + jf, "$"].join("|") + ")",
  zr + "?" + jf + "+" + Wf,
  zr + "+" + qf,
  aD,
  sD,
  i0,
  lD
].join("|"), "g");
function uD(e) {
  return e.match(cD) || [];
}
function hD(e, t, n) {
  return e = Hs(e), t = n ? void 0 : t, t === void 0 ? Vk(e) ? uD(e) : Bk(e) : e.match(t) || [];
}
var dD = "['’]", fD = RegExp(dD, "g");
function h0(e) {
  return function(t) {
    return Ok(hD(Pk(t).replace(fD, "")), e, "");
  };
}
function pD(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
function d0(e, t, n) {
  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = ti(n), n = n === n ? n : 0), t !== void 0 && (t = ti(t), t = t === t ? t : 0), pD(ti(e), t, n);
}
var mD = "Expected a function";
function gD(e, t, n) {
  if (typeof e != "function")
    throw new TypeError(mD);
  return setTimeout(function() {
    e.apply(void 0, n);
  }, t);
}
var vD = ju(function(e, t, n) {
  return gD(e, ti(t) || 0, n);
});
function yD(e, t) {
  var n = -1, r = Ar(e) ? Array(e.length) : [];
  return ih(e, function(i, s, a) {
    r[++n] = t(i, s, a);
  }), r;
}
function xD(e, t) {
  var n = se(e) ? Vu : yD;
  return n(e, qo(t));
}
var bD = 1 / 0;
function ED(e, t) {
  return jo(xD(e, t), bD);
}
function f0(e, t) {
  return Wo(e, t);
}
var Pr = h0(function(e, t, n) {
  return e + (n ? "-" : "") + t.toLowerCase();
});
function _D(e, t) {
  var n;
  return ih(e, function(r, i, s) {
    return n = t(r, i, s), !n;
  }), !!n;
}
function wD(e, t, n) {
  var r = se(e) ? ov : _D;
  return n && Vg(e, t, n) && (t = void 0), r(e, qo(t));
}
class yt {
  constructor(t, n, r) {
    if (this.type = "", this.renderType = rt.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = n, r && (this.configs = r, this.configs.id)) {
      const i = x(this.model.getOptions(), "style", "prefix");
      this.id = `${i}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      I(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    var n;
    const r = this.parent;
    if (this.parent = t, !(r && r.node() === t.node()) && this.type) {
      const i = x(this.model.getOptions(), "style", "prefix");
      (n = this.parent) == null || n.classed(`${ve}--${i}--${this.type}`, !0), r && r.classed(`${ve}--${i}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { withinChartClip: !1 }) {
    if (this.type) {
      const n = x(this.model.getOptions(), "style", "prefix"), r = this.id ? `#${this.id}` : "", i = N.appendOrSelect(
        this.parent,
        `${this.renderType === rt.SVG ? "svg" : "div"}${r}.${ve}--${n}--${this.type}`
      );
      if (t.withinChartClip) {
        const s = this.model.get("chartClipId");
        if (s) {
          const a = I(`#${s}`).select("rect");
          a.size() !== 0 && parseFloat(a.attr("height")) > 0 && i.attr("clip-path", `url(#${s})`);
        }
      }
      return i.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? ct({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
/*! @license DOMPurify 3.1.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.0/LICENSE */
const {
  entries: p0,
  setPrototypeOf: Yf,
  isFrozen: SD,
  getPrototypeOf: OD,
  getOwnPropertyDescriptor: TD
} = Object;
let {
  freeze: fe,
  seal: Ve,
  create: m0
} = Object, {
  apply: Hc,
  construct: Vc
} = typeof Reflect < "u" && Reflect;
fe || (fe = function(e) {
  return e;
});
Ve || (Ve = function(e) {
  return e;
});
Hc || (Hc = function(e, t, n) {
  return e.apply(t, n);
});
Vc || (Vc = function(e, t) {
  return new e(...t);
});
const da = Le(Array.prototype.forEach), Xf = Le(Array.prototype.pop), Hi = Le(Array.prototype.push), La = Le(String.prototype.toLowerCase), Hl = Le(String.prototype.toString), Zf = Le(String.prototype.match), Vi = Le(String.prototype.replace), MD = Le(String.prototype.indexOf), CD = Le(String.prototype.trim), Ge = Le(Object.prototype.hasOwnProperty), ge = Le(RegExp.prototype.test), Fi = AD(TypeError);
function Le(e) {
  return function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    return Hc(e, t, r);
  };
}
function AD(e) {
  return function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return Vc(e, n);
  };
}
function gt(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : La;
  Yf && Yf(e, null);
  let r = t.length;
  for (; r--; ) {
    let i = t[r];
    if (typeof i == "string") {
      const s = n(i);
      s !== i && (SD(t) || (t[r] = s), i = s);
    }
    e[i] = !0;
  }
  return e;
}
function $D(e) {
  for (let t = 0; t < e.length; t++)
    Ge(e, t) || (e[t] = null);
  return e;
}
function ur(e) {
  const t = m0(null);
  for (const [n, r] of p0(e))
    Ge(e, n) && (Array.isArray(r) ? t[n] = $D(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = ur(r) : t[n] = r);
  return t;
}
function fa(e, t) {
  for (; e !== null; ) {
    const r = TD(e, t);
    if (r) {
      if (r.get)
        return Le(r.get);
      if (typeof r.value == "function")
        return Le(r.value);
    }
    e = OD(e);
  }
  function n() {
    return null;
  }
  return n;
}
const Kf = fe(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Vl = fe(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Fl = fe(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), LD = fe(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), zl = fe(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), RD = fe(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Qf = fe(["#text"]), Jf = fe(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), Gl = fe(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), tp = fe(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), pa = fe(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), kD = Ve(/\{\{[\w\W]*|[\w\W]*\}\}/gm), DD = Ve(/<%[\w\W]*|[\w\W]*%>/gm), ID = Ve(/\${[\w\W]*}/gm), ND = Ve(/^data-[\-\w.\u00B7-\uFFFF]/), PD = Ve(/^aria-[\-\w]+$/), g0 = Ve(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), UD = Ve(/^(?:\w+script|data):/i), BD = Ve(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), v0 = Ve(/^html$/i), HD = Ve(/^[a-z][.\w]*(-[.\w]+)+$/i);
var ep = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: kD,
  ERB_EXPR: DD,
  TMPLIT_EXPR: ID,
  DATA_ATTR: ND,
  ARIA_ATTR: PD,
  IS_ALLOWED_URI: g0,
  IS_SCRIPT_OR_DATA: UD,
  ATTR_WHITESPACE: BD,
  DOCTYPE_NAME: v0,
  CUSTOM_ELEMENT: HD
});
const VD = function() {
  return typeof window > "u" ? null : window;
}, FD = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const r = "data-tt-policy-suffix";
  t && t.hasAttribute(r) && (n = t.getAttribute(r));
  const i = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(i, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
};
function y0() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : VD();
  const t = (T) => y0(T);
  if (t.version = "3.1.0", t.removed = [], !e || !e.document || e.document.nodeType !== 9)
    return t.isSupported = !1, t;
  let {
    document: n
  } = e;
  const r = n, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: a,
    Node: o,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: u = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: h,
    trustedTypes: f
  } = e, p = l.prototype, v = fa(p, "cloneNode"), m = fa(p, "nextSibling"), y = fa(p, "childNodes"), g = fa(p, "parentNode");
  if (typeof a == "function") {
    const T = n.createElement("template");
    T.content && T.content.ownerDocument && (n = T.content.ownerDocument);
  }
  let b, w = "";
  const {
    implementation: _,
    createNodeIterator: S,
    createDocumentFragment: L,
    getElementsByTagName: D
  } = n, {
    importNode: k
  } = r;
  let R = {};
  t.isSupported = typeof p0 == "function" && typeof g == "function" && _ && _.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: M,
    ERB_EXPR: V,
    TMPLIT_EXPR: P,
    DATA_ATTR: H,
    ARIA_ATTR: E,
    IS_SCRIPT_OR_DATA: A,
    ATTR_WHITESPACE: $,
    CUSTOM_ELEMENT: U
  } = ep;
  let {
    IS_ALLOWED_URI: B
  } = ep, W = null;
  const K = gt({}, [...Kf, ...Vl, ...Fl, ...zl, ...Qf]);
  let Q = null;
  const dt = gt({}, [...Jf, ...Gl, ...tp, ...pa]);
  let it = Object.seal(m0(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), pt = null, Z = null, tt = !0, ft = !0, q = !1, J = !0, ot = !1, G = !0, wt = !1, bt = !1, Gt = !1, It = !1, nt = !1, Tt = !1, we = !0, Se = !1;
  const Jo = "user-content-";
  let er = !0, nr = !1, Hn = {}, mn = null;
  const bi = gt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Vn = null;
  const Gs = gt({}, ["audio", "video", "img", "source", "image", "track"]);
  let Lr = null;
  const Ei = gt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Fn = "http://www.w3.org/1998/Math/MathML", Rr = "http://www.w3.org/2000/svg", Fe = "http://www.w3.org/1999/xhtml";
  let zn = Fe, _i = !1, wi = null;
  const tl = gt({}, [Fn, Rr, Fe], Hl);
  let rr = null;
  const Si = ["application/xhtml+xml", "text/html"], js = "text/html";
  let Vt = null, nn = null;
  const Oi = n.createElement("form"), Ti = function(T) {
    return T instanceof RegExp || T instanceof Function;
  }, Mi = function() {
    let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(nn && nn === T)) {
      if ((!T || typeof T != "object") && (T = {}), T = ur(T), rr = // eslint-disable-next-line unicorn/prefer-includes
      Si.indexOf(T.PARSER_MEDIA_TYPE) === -1 ? js : T.PARSER_MEDIA_TYPE, Vt = rr === "application/xhtml+xml" ? Hl : La, W = Ge(T, "ALLOWED_TAGS") ? gt({}, T.ALLOWED_TAGS, Vt) : K, Q = Ge(T, "ALLOWED_ATTR") ? gt({}, T.ALLOWED_ATTR, Vt) : dt, wi = Ge(T, "ALLOWED_NAMESPACES") ? gt({}, T.ALLOWED_NAMESPACES, Hl) : tl, Lr = Ge(T, "ADD_URI_SAFE_ATTR") ? gt(
        ur(Ei),
        // eslint-disable-line indent
        T.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Vt
        // eslint-disable-line indent
      ) : Ei, Vn = Ge(T, "ADD_DATA_URI_TAGS") ? gt(
        ur(Gs),
        // eslint-disable-line indent
        T.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Vt
        // eslint-disable-line indent
      ) : Gs, mn = Ge(T, "FORBID_CONTENTS") ? gt({}, T.FORBID_CONTENTS, Vt) : bi, pt = Ge(T, "FORBID_TAGS") ? gt({}, T.FORBID_TAGS, Vt) : {}, Z = Ge(T, "FORBID_ATTR") ? gt({}, T.FORBID_ATTR, Vt) : {}, Hn = Ge(T, "USE_PROFILES") ? T.USE_PROFILES : !1, tt = T.ALLOW_ARIA_ATTR !== !1, ft = T.ALLOW_DATA_ATTR !== !1, q = T.ALLOW_UNKNOWN_PROTOCOLS || !1, J = T.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ot = T.SAFE_FOR_TEMPLATES || !1, G = T.SAFE_FOR_XML !== !1, wt = T.WHOLE_DOCUMENT || !1, It = T.RETURN_DOM || !1, nt = T.RETURN_DOM_FRAGMENT || !1, Tt = T.RETURN_TRUSTED_TYPE || !1, Gt = T.FORCE_BODY || !1, we = T.SANITIZE_DOM !== !1, Se = T.SANITIZE_NAMED_PROPS || !1, er = T.KEEP_CONTENT !== !1, nr = T.IN_PLACE || !1, B = T.ALLOWED_URI_REGEXP || g0, zn = T.NAMESPACE || Fe, it = T.CUSTOM_ELEMENT_HANDLING || {}, T.CUSTOM_ELEMENT_HANDLING && Ti(T.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (it.tagNameCheck = T.CUSTOM_ELEMENT_HANDLING.tagNameCheck), T.CUSTOM_ELEMENT_HANDLING && Ti(T.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (it.attributeNameCheck = T.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), T.CUSTOM_ELEMENT_HANDLING && typeof T.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (it.allowCustomizedBuiltInElements = T.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ot && (ft = !1), nt && (It = !0), Hn && (W = gt({}, Qf), Q = [], Hn.html === !0 && (gt(W, Kf), gt(Q, Jf)), Hn.svg === !0 && (gt(W, Vl), gt(Q, Gl), gt(Q, pa)), Hn.svgFilters === !0 && (gt(W, Fl), gt(Q, Gl), gt(Q, pa)), Hn.mathMl === !0 && (gt(W, zl), gt(Q, tp), gt(Q, pa))), T.ADD_TAGS && (W === K && (W = ur(W)), gt(W, T.ADD_TAGS, Vt)), T.ADD_ATTR && (Q === dt && (Q = ur(Q)), gt(Q, T.ADD_ATTR, Vt)), T.ADD_URI_SAFE_ATTR && gt(Lr, T.ADD_URI_SAFE_ATTR, Vt), T.FORBID_CONTENTS && (mn === bi && (mn = ur(mn)), gt(mn, T.FORBID_CONTENTS, Vt)), er && (W["#text"] = !0), wt && gt(W, ["html", "head", "body"]), W.table && (gt(W, ["tbody"]), delete pt.tbody), T.TRUSTED_TYPES_POLICY) {
        if (typeof T.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Fi('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof T.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Fi('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        b = T.TRUSTED_TYPES_POLICY, w = b.createHTML("");
      } else
        b === void 0 && (b = FD(f, i)), b !== null && typeof w == "string" && (w = b.createHTML(""));
      fe && fe(T), nn = T;
    }
  }, Ci = gt({}, ["mi", "mo", "mn", "ms", "mtext"]), Ws = gt({}, ["foreignobject", "desc", "title", "annotation-xml"]), qs = gt({}, ["title", "style", "font", "a", "script"]), Ai = gt({}, [...Vl, ...Fl, ...LD]), Ys = gt({}, [...zl, ...RD]), el = function(T) {
    let Y = g(T);
    (!Y || !Y.tagName) && (Y = {
      namespaceURI: zn,
      tagName: "template"
    });
    const j = La(T.tagName), at = La(Y.tagName);
    return wi[T.namespaceURI] ? T.namespaceURI === Rr ? Y.namespaceURI === Fe ? j === "svg" : Y.namespaceURI === Fn ? j === "svg" && (at === "annotation-xml" || Ci[at]) : !!Ai[j] : T.namespaceURI === Fn ? Y.namespaceURI === Fe ? j === "math" : Y.namespaceURI === Rr ? j === "math" && Ws[at] : !!Ys[j] : T.namespaceURI === Fe ? Y.namespaceURI === Rr && !Ws[at] || Y.namespaceURI === Fn && !Ci[at] ? !1 : !Ys[j] && (qs[j] || !Ai[j]) : !!(rr === "application/xhtml+xml" && wi[T.namespaceURI]) : !1;
  }, gn = function(T) {
    Hi(t.removed, {
      element: T
    });
    try {
      T.parentNode.removeChild(T);
    } catch {
      T.remove();
    }
  }, $i = function(T, Y) {
    try {
      Hi(t.removed, {
        attribute: Y.getAttributeNode(T),
        from: Y
      });
    } catch {
      Hi(t.removed, {
        attribute: null,
        from: Y
      });
    }
    if (Y.removeAttribute(T), T === "is" && !Q[T])
      if (It || nt)
        try {
          gn(Y);
        } catch {
        }
      else
        try {
          Y.setAttribute(T, "");
        } catch {
        }
  }, Xs = function(T) {
    let Y = null, j = null;
    if (Gt)
      T = "<remove></remove>" + T;
    else {
      const Pt = Zf(T, /^[\r\n\t ]+/);
      j = Pt && Pt[0];
    }
    rr === "application/xhtml+xml" && zn === Fe && (T = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + T + "</body></html>");
    const at = b ? b.createHTML(T) : T;
    if (zn === Fe)
      try {
        Y = new h().parseFromString(at, rr);
      } catch {
      }
    if (!Y || !Y.documentElement) {
      Y = _.createDocument(zn, "template", null);
      try {
        Y.documentElement.innerHTML = _i ? w : at;
      } catch {
      }
    }
    const Ct = Y.body || Y.documentElement;
    return T && j && Ct.insertBefore(n.createTextNode(j), Ct.childNodes[0] || null), zn === Fe ? D.call(Y, wt ? "html" : "body")[0] : wt ? Y.documentElement : Ct;
  }, Zs = function(T) {
    return S.call(
      T.ownerDocument || T,
      T,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, nl = function(T) {
    return T instanceof d && (typeof T.nodeName != "string" || typeof T.textContent != "string" || typeof T.removeChild != "function" || !(T.attributes instanceof u) || typeof T.removeAttribute != "function" || typeof T.setAttribute != "function" || typeof T.namespaceURI != "string" || typeof T.insertBefore != "function" || typeof T.hasChildNodes != "function");
  }, C = function(T) {
    return typeof o == "function" && T instanceof o;
  }, z = function(T, Y, j) {
    R[T] && da(R[T], (at) => {
      at.call(t, Y, j, nn);
    });
  }, X = function(T) {
    let Y = null;
    if (z("beforeSanitizeElements", T, null), nl(T))
      return gn(T), !0;
    const j = Vt(T.nodeName);
    if (z("uponSanitizeElement", T, {
      tagName: j,
      allowedTags: W
    }), T.hasChildNodes() && !C(T.firstElementChild) && ge(/<[/\w]/g, T.innerHTML) && ge(/<[/\w]/g, T.textContent) || T.nodeType === 7 || G && T.nodeType === 8 && ge(/<[/\w]/g, T.data))
      return gn(T), !0;
    if (!W[j] || pt[j]) {
      if (!pt[j] && Et(j) && (it.tagNameCheck instanceof RegExp && ge(it.tagNameCheck, j) || it.tagNameCheck instanceof Function && it.tagNameCheck(j)))
        return !1;
      if (er && !mn[j]) {
        const at = g(T) || T.parentNode, Ct = y(T) || T.childNodes;
        if (Ct && at) {
          const Pt = Ct.length;
          for (let ke = Pt - 1; ke >= 0; --ke)
            at.insertBefore(v(Ct[ke], !0), m(T));
        }
      }
      return gn(T), !0;
    }
    return T instanceof l && !el(T) || (j === "noscript" || j === "noembed" || j === "noframes") && ge(/<\/no(script|embed|frames)/i, T.innerHTML) ? (gn(T), !0) : (ot && T.nodeType === 3 && (Y = T.textContent, da([M, V, P], (at) => {
      Y = Vi(Y, at, " ");
    }), T.textContent !== Y && (Hi(t.removed, {
      element: T.cloneNode()
    }), T.textContent = Y)), z("afterSanitizeElements", T, null), !1);
  }, lt = function(T, Y, j) {
    if (we && (Y === "id" || Y === "name") && (j in n || j in Oi))
      return !1;
    if (!(ft && !Z[Y] && ge(H, Y)) && !(tt && ge(E, Y))) {
      if (!Q[Y] || Z[Y]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          !(Et(T) && (it.tagNameCheck instanceof RegExp && ge(it.tagNameCheck, T) || it.tagNameCheck instanceof Function && it.tagNameCheck(T)) && (it.attributeNameCheck instanceof RegExp && ge(it.attributeNameCheck, Y) || it.attributeNameCheck instanceof Function && it.attributeNameCheck(Y)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          Y === "is" && it.allowCustomizedBuiltInElements && (it.tagNameCheck instanceof RegExp && ge(it.tagNameCheck, j) || it.tagNameCheck instanceof Function && it.tagNameCheck(j)))
        )
          return !1;
      } else if (!Lr[Y] && !ge(B, Vi(j, $, "")) && !((Y === "src" || Y === "xlink:href" || Y === "href") && T !== "script" && MD(j, "data:") === 0 && Vn[T]) && !(q && !ge(A, Vi(j, $, ""))) && j)
        return !1;
    }
    return !0;
  }, Et = function(T) {
    return T !== "annotation-xml" && Zf(T, U);
  }, Mt = function(T) {
    z("beforeSanitizeAttributes", T, null);
    const {
      attributes: Y
    } = T;
    if (!Y)
      return;
    const j = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: Q
    };
    let at = Y.length;
    for (; at--; ) {
      const Ct = Y[at], {
        name: Pt,
        namespaceURI: ke,
        value: Kt
      } = Ct, rn = Vt(Pt);
      let me = Pt === "value" ? Kt : CD(Kt);
      if (j.attrName = rn, j.attrValue = me, j.keepAttr = !0, j.forceKeepAttr = void 0, z("uponSanitizeAttribute", T, j), me = j.attrValue, j.forceKeepAttr || ($i(Pt, T), !j.keepAttr))
        continue;
      if (!J && ge(/\/>/i, me)) {
        $i(Pt, T);
        continue;
      }
      ot && da([M, V, P], (K0) => {
        me = Vi(me, K0, " ");
      });
      const vh = Vt(T.nodeName);
      if (lt(vh, rn, me)) {
        if (Se && (rn === "id" || rn === "name") && ($i(Pt, T), me = Jo + me), b && typeof f == "object" && typeof f.getAttributeType == "function" && !ke)
          switch (f.getAttributeType(vh, rn)) {
            case "TrustedHTML": {
              me = b.createHTML(me);
              break;
            }
            case "TrustedScriptURL": {
              me = b.createScriptURL(me);
              break;
            }
          }
        try {
          ke ? T.setAttributeNS(ke, Pt, me) : T.setAttribute(Pt, me), Xf(t.removed);
        } catch {
        }
      }
    }
    z("afterSanitizeAttributes", T, null);
  }, xt = function T(Y) {
    let j = null;
    const at = Zs(Y);
    for (z("beforeSanitizeShadowDOM", Y, null); j = at.nextNode(); )
      z("uponSanitizeShadowNode", j, null), !X(j) && (j.content instanceof s && T(j.content), Mt(j));
    z("afterSanitizeShadowDOM", Y, null);
  };
  return t.sanitize = function(T) {
    let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, j = null, at = null, Ct = null, Pt = null;
    if (_i = !T, _i && (T = "<!-->"), typeof T != "string" && !C(T))
      if (typeof T.toString == "function") {
        if (T = T.toString(), typeof T != "string")
          throw Fi("dirty is not a string, aborting");
      } else
        throw Fi("toString is not a function");
    if (!t.isSupported)
      return T;
    if (bt || Mi(Y), t.removed = [], typeof T == "string" && (nr = !1), nr) {
      if (T.nodeName) {
        const rn = Vt(T.nodeName);
        if (!W[rn] || pt[rn])
          throw Fi("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (T instanceof o)
      j = Xs("<!---->"), at = j.ownerDocument.importNode(T, !0), at.nodeType === 1 && at.nodeName === "BODY" || at.nodeName === "HTML" ? j = at : j.appendChild(at);
    else {
      if (!It && !ot && !wt && // eslint-disable-next-line unicorn/prefer-includes
      T.indexOf("<") === -1)
        return b && Tt ? b.createHTML(T) : T;
      if (j = Xs(T), !j)
        return It ? null : Tt ? w : "";
    }
    j && Gt && gn(j.firstChild);
    const ke = Zs(nr ? T : j);
    for (; Ct = ke.nextNode(); )
      X(Ct) || (Ct.content instanceof s && xt(Ct.content), Mt(Ct));
    if (nr)
      return T;
    if (It) {
      if (nt)
        for (Pt = L.call(j.ownerDocument); j.firstChild; )
          Pt.appendChild(j.firstChild);
      else
        Pt = j;
      return (Q.shadowroot || Q.shadowrootmode) && (Pt = k.call(r, Pt, !0)), Pt;
    }
    let Kt = wt ? j.outerHTML : j.innerHTML;
    return wt && W["!doctype"] && j.ownerDocument && j.ownerDocument.doctype && j.ownerDocument.doctype.name && ge(v0, j.ownerDocument.doctype.name) && (Kt = "<!DOCTYPE " + j.ownerDocument.doctype.name + `>
` + Kt), ot && da([M, V, P], (rn) => {
      Kt = Vi(Kt, rn, " ");
    }), b && Tt ? b.createHTML(Kt) : Kt;
  }, t.setConfig = function() {
    let T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Mi(T), bt = !0;
  }, t.clearConfig = function() {
    nn = null, bt = !1;
  }, t.isValidAttribute = function(T, Y, j) {
    nn || Mi({});
    const at = Vt(T), Ct = Vt(Y);
    return lt(at, Ct, j);
  }, t.addHook = function(T, Y) {
    typeof Y == "function" && (R[T] = R[T] || [], Hi(R[T], Y));
  }, t.removeHook = function(T) {
    if (R[T])
      return Xf(R[T]);
  }, t.removeHooks = function(T) {
    R[T] && (R[T] = []);
  }, t.removeAllHooks = function() {
    R = {};
  }, t;
}
var oh = y0();
const ma = (e) => oh.sanitize(e, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), zD = (e) => oh.sanitize(e, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), un = (e) => oh.sanitize(e, { ALLOWED_TAGS: [] }), x0 = class b0 extends yt {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = rt.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(O.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(O.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer().attr("role", "toolbar").attr("aria-label", "chart toolbar");
    if (x(this.getOptions(), "data", "loading"))
      n.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = n.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: r, overflowMenuItemList: i } = this.getControlConfigs();
      i && r.push(this.getOverflowButtonConfig());
      const s = n.selectAll("div.toolbar-control").data(r, (l) => l.id);
      s.exit().remove();
      const a = s.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), o = this;
      a.merge(s).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `
			<button
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${un(l.id)}`
      )}" aria-label="${un(l.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${zD(l.iconSVG.content)}
				</svg>
			</button>`).each(function(l, c) {
        I(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), I(this).select("button").on("mouseover focus", function(u) {
          const d = I(this);
          d.classed("hovered", !0), o.services.events.dispatchEvent(O.Toolbar.SHOW_TOOLTIP, {
            event: u,
            hoveredElement: d,
            content: l.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          o.services.events.dispatchEvent(O.Toolbar.HIDE_TOOLTIP);
        }).on("click", (u) => {
          l.shouldBeDisabled() || o.triggerFunctionAndEvent(l, u, this);
        }).on("keydown", (u) => {
          u.key && u.key === "Enter" || u.key === " " ? (u.preventDefault(), o.triggerFunctionAndEvent(l, u, this)) : u.key && u.key === "ArrowLeft" ? o.focusOnPreviousEnabledToolbarItem(c) : u.key && u.key === "ArrowRight" && o.focusOnNextEnabledToolbarItem(c);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), n = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (i) => x(i, "id"));
    n.exit().remove();
    const r = n.enter().append("li").attr("id", (i) => this.services.domUtils.generateElementIDString(`control-${i.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    r.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), r.merge(n).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).attr("aria-disabled", (i) => i.shouldBeDisabled()).selectAll("button").text((i) => i.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), I(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(O.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(O.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = I(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = I(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = I(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = I(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const n = this;
      this.getOverflowMenuItems().forEach((r, i) => {
        const s = I(
          `#${this.services.domUtils.generateElementIDString(`control-${r.id}`)}`
        );
        s !== null && (s.on("click", () => {
          n.triggerFunctionAndEvent(r, t, s.node()), n.updateOverflowMenu(!1);
        }), s.on("keydown", (a) => {
          a && a.key === "Enter" ? n.triggerFunctionAndEvent(r, t, s.node()) : a && a.key === "ArrowUp" ? n.focusOnPreviousEnabledMenuItem(i) : a && a.key === "ArrowDown" ? n.focusOnNextEnabledMenuItem(i) : a && a.key === "Escape" && n.updateOverflowMenu(!1), a.preventDefault();
        }));
      }), n.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, n, r) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(n), this.services.events.dispatchEvent(O.Toolbar.BUTTON_CLICK, {
      control: t,
      event: n,
      element: r
    }));
  }
  getControlConfigs() {
    const t = x(this.getOptions(), "toolbar", "numberOfIcons") - 1, n = x(this.getOptions(), "toolbar", "controls"), r = [], i = [], s = [];
    return n.forEach((a) => {
      let o = null;
      if (a.type === $t.CUSTOM)
        x(a, "id") === null && (a.id = `toolbar-button-${b0.buttonID++}`), x(a, "shouldBeDisabled") === null && (a.shouldBeDisabled = () => !1), o = a;
      else {
        const l = this.services.domUtils.isFullScreenMode();
        a.type === $t.MAKE_FULLSCREEN && l ? a.type = $t.EXIT_FULLSCREEN : a.type === $t.EXIT_FULLSCREEN && !l && (a.type = $t.MAKE_FULLSCREEN), o = this.getControlConfigByType(a.type);
      }
      o && (o.text = a.text ? a.text : a.type, o.id.indexOf("toolbar-export") !== -1 ? r.push(o) : i.length < t ? x(o, "iconSVG", "content") === null ? s.push(o) : i.push(o) : s.push(o));
    }), s.push(...r), s.length ? {
      buttonList: i,
      overflowMenuItemList: s
    } : {
      buttonList: i
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: n } = this.getControlConfigs();
    return n && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: t } = x(this.model.getOptions(), "locale", "translations", "toolbar");
    return {
      id: "toolbar-overflow-menu",
      title: t,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (n) => this.toggleOverflowMenu(n)
    };
  }
  getControlConfigByType(t) {
    const n = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), r = this.model.getDisplayData(), i = this.model.getOptions(), {
      exportAsCSV: s,
      exportAsJPG: a,
      exportAsPNG: o,
      zoomIn: l,
      zoomOut: c,
      resetZoom: u,
      makeFullScreen: d,
      exitFullScreen: h,
      showAsTable: f
    } = x(
      i,
      "locale",
      "translations",
      "toolbar"
    );
    let p;
    switch (t) {
      case $t.ZOOM_IN:
        n && (p = {
          id: "toolbar-zoomIn",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case $t.ZOOM_OUT:
        n && (p = {
          id: "toolbar-zoomOut",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case $t.RESET_ZOOM:
        n && (p = {
          id: "toolbar-resetZoom",
          title: u,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case $t.MAKE_FULLSCREEN:
        p = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: d,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case $t.EXIT_FULLSCREEN:
        p = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: h,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case $t.SHOW_AS_DATATABLE:
        p = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: f,
          shouldBeDisabled: () => r.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(O.Modal.SHOW)
        };
        break;
      case $t.EXPORT_CSV:
        p = {
          id: "toolbar-export-CSV",
          title: s,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case $t.EXPORT_PNG:
        p = {
          id: "toolbar-export-PNG",
          title: o,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case $t.EXPORT_JPG:
        p = {
          id: "toolbar-export-JPG",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return p;
  }
  getControlIconByType(t) {
    switch (t) {
      case $t.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case $t.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case $t.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case $t.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case $t.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case $t.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case $t.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case $t.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case $t.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
x0.buttonID = 0;
let Zo = x0;
const E0 = class _0 extends yt {
  constructor(t, n, r, i) {
    super(t, n, i), this.type = "layout", this.configs = i, this.children = r, this._instanceID = _0.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((n) => {
        n.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let n = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((r) => {
      const i = x(r, "growth");
      return i === ut.PREFERRED || i === ut.FIXED;
    }).each(function(r) {
      n += r.size;
    }), n;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => x(t, "growth") === ut.STRETCH).size();
  }
  render(t = !0) {
    const n = this.parent, { width: r, height: i } = N.getHTMLElementSize(n.node()), s = this.configs.direction === Ht.ROW || this.configs.direction === Ht.ROW_REVERSE, a = x(this.model.getOptions(), "style", "prefix"), o = n.classed(
      `${ve}--${a}--layout-row`,
      this.configs.direction === Ht.ROW
    ).classed(
      `${ve}--${a}--layout-row-reverse`,
      this.configs.direction === Ht.ROW_REVERSE
    ).classed(
      `${ve}--${a}--layout-column`,
      this.configs.direction === Ht.COLUMN
    ).classed(
      `${ve}--${a}--layout-column-reverse`,
      this.configs.direction === Ht.COLUMN_REVERSE
    ).classed(
      `${ve}--${a}--layout-alignitems-center`,
      this.configs.alignItems === mi.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (c) => c.id);
    o.enter().append("div").merge(n.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (c) => `layout-child layout-child-${this._instanceID} ${c.id}`).each(function(c) {
      c.components.forEach((u) => {
        const d = I(this), h = x(c, "renderType") === rt.SVG;
        u.setParent(
          h ? N.appendOrSelect(d, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : d
        );
        const f = x(c, "growth");
        (f === ut.PREFERRED || f === ut.FIXED) && u.render(t);
      });
    }), n.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(c) {
      const u = x(c, "growth"), d = x(c, "renderType") === rt.SVG ? N.getSVGElementSize(I(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : N.getHTMLElementSize(this);
      if (u === ut.PREFERRED) {
        const h = s ? d.width : d.height, f = s ? r : i;
        c.size = h / f * 100;
      }
    }), o.exit().remove(), this.children.filter((c) => x(c, "growth") === ut.STRETCH).forEach((c) => {
      c.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const l = n.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (c) => c.id);
    s ? l.style("width", (c) => `${c.size / 100 * r}px`).style("height", "100%") : l.style("height", (c) => `${c.size / 100 * i}px`).style("width", "100%"), l.each(function(c) {
      c.components.forEach((u) => {
        x(c, "growth") === ut.STRETCH && u.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((n) => n.destroy());
    });
  }
};
E0.instanceID = Math.floor(Math.random() * 99999999999);
let Ce = E0;
class Nn extends yt {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer().style("width", `${this.configs.size || yf.default.size}px`).style("height", `${this.configs.size || yf.default.size}px`).attr("opacity", 0);
  }
}
var GD = {
  prefix: "bx",
  selectorTabbable: `
    a[href], area[href], input:not([disabled]):not([tabindex='-1']),
    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
    textarea:not([disabled]):not([tabindex='-1']),
    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]
  `,
  selectorFocusable: `
    a[href], area[href], input:not([disabled]),
    button:not([disabled]),select:not([disabled]),
    textarea:not([disabled]),
    iframe, object, embed, *[tabindex], *[contenteditable=true]
  `
}, jl = GD;
function np(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function jD(e, t, n) {
  return t && np(e.prototype, t), n && np(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function WD(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function qD(e) {
  return KD(e) || ZD(e) || XD(e) || YD();
}
function YD() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function XD(e, t) {
  if (e) {
    if (typeof e == "string")
      return Fc(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Fc(e, t);
  }
}
function ZD(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function KD(e) {
  if (Array.isArray(e))
    return Fc(e);
}
function Fc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function w0(e) {
  return e.reduce(function(t, n) {
    return Array.isArray(n) ? t.push.apply(t, qD(w0(n))) : t.push(n), t;
  }, []);
}
function QD() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return w0(t).reduce(function(r, i) {
    return i(r);
  }, /* @__PURE__ */ function() {
    function r() {
      WD(this, r);
    }
    return jD(r);
  }());
}
function zc(e) {
  "@babel/helpers - typeof";
  return zc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zc(e);
}
function JD(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rp(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function tI(e, t, n) {
  return t && rp(e.prototype, t), n && rp(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function eI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Gc(e, t);
}
function Gc(e, t) {
  return Gc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Gc(e, t);
}
function nI(e) {
  var t = iI();
  return function() {
    var n = yo(e), r;
    if (t) {
      var i = yo(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return rI(this, r);
  };
}
function rI(e, t) {
  if (t && (zc(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return S0(e);
}
function S0(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function iI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function yo(e) {
  return yo = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, yo(e);
}
function sI(e) {
  var t = /* @__PURE__ */ function(n) {
    eI(i, n);
    var r = nI(i);
    function i(s) {
      var a, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (JD(this, i), a = r.call(this, s, o), a.children = [], !s || s.nodeType !== Node.ELEMENT_NODE)
        throw new TypeError("DOM element should be given to initialize this widget.");
      return a.element = s, a.options = Object.assign(Object.create(a.constructor.options), o), a.constructor.components.set(a.element, S0(a)), a;
    }
    return tI(i, [{
      key: "release",
      value: (
        /**
         * Releases this component's instance from the associated element.
         */
        function() {
          for (var s = this.children.pop(); s; s = this.children.pop())
            s.release();
          return this.constructor.components.delete(this.element), null;
        }
      )
    }], [{
      key: "create",
      value: function(s, a) {
        return this.components.get(s) || new this(s, a);
      }
    }]), i;
  }(e);
  return t;
}
function jc(e) {
  "@babel/helpers - typeof";
  return jc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jc(e);
}
function aI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ip(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function oI(e, t, n) {
  return t && ip(e.prototype, t), n && ip(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Ra() {
  return typeof Reflect < "u" && Reflect.get ? Ra = Reflect.get : Ra = function(e, t, n) {
    var r = lI(e, t);
    if (r) {
      var i = Object.getOwnPropertyDescriptor(r, t);
      return i.get ? i.get.call(arguments.length < 3 ? e : n) : i.value;
    }
  }, Ra.apply(this, arguments);
}
function lI(e, t) {
  for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = pi(e), e !== null); )
    ;
  return e;
}
function cI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Wc(e, t);
}
function Wc(e, t) {
  return Wc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Wc(e, t);
}
function uI(e) {
  var t = fI();
  return function() {
    var n = pi(e), r;
    if (t) {
      var i = pi(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return hI(this, r);
  };
}
function hI(e, t) {
  if (t && (jc(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return dI(e);
}
function dI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function fI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function pi(e) {
  return pi = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, pi(e);
}
function pI(e) {
  var t = /* @__PURE__ */ function(n) {
    cI(i, n);
    var r = uI(i);
    function i() {
      var s;
      aI(this, i);
      for (var a = arguments.length, o = new Array(a), l = 0; l < a; l++)
        o[l] = arguments[l];
      return s = r.call.apply(r, [this].concat(o)), s.handles = /* @__PURE__ */ new Set(), s;
    }
    return oI(i, [{
      key: "manage",
      value: (
        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        function(s) {
          return this.handles.add(s), s;
        }
      )
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */
    }, {
      key: "unmanage",
      value: function(s) {
        return this.handles.delete(s), s;
      }
    }, {
      key: "release",
      value: function() {
        var s = this;
        return this.handles.forEach(function(a) {
          a.release(), s.handles.delete(a);
        }), Ra(pi(i.prototype), "release", this).call(this);
      }
    }]), i;
  }(e);
  return t;
}
function rs(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return e.addEventListener.apply(e, n), {
    release: function() {
      return e.removeEventListener.apply(e, n), null;
    }
  };
}
function qc(e) {
  "@babel/helpers - typeof";
  return qc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qc(e);
}
function mI(e) {
  return xI(e) || yI(e) || vI(e) || gI();
}
function gI() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function vI(e, t) {
  if (e) {
    if (typeof e == "string")
      return Yc(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Yc(e, t);
  }
}
function yI(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function xI(e) {
  if (Array.isArray(e))
    return Yc(e);
}
function Yc(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function bI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sp(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function EI(e, t, n) {
  return t && sp(e.prototype, t), n && sp(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function _I(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Xc(e, t);
}
function Xc(e, t) {
  return Xc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Xc(e, t);
}
function wI(e) {
  var t = TI();
  return function() {
    var n = xo(e), r;
    if (t) {
      var i = xo(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return SI(this, r);
  };
}
function SI(e, t) {
  if (t && (qc(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return OI(e);
}
function OI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function TI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function xo(e) {
  return xo = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, xo(e);
}
function MI(e) {
  var t = /* @__PURE__ */ function(n) {
    _I(i, n);
    var r = wI(i);
    function i() {
      return bI(this, i), r.apply(this, arguments);
    }
    return EI(i, [{
      key: "_changeState",
      value: (
        /* eslint-disable jsdoc/check-param-names */
        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        function() {
          throw new Error("_changeState() should be overridden to perform actual change in state.");
        }
      )
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */
    }, {
      key: "changeState",
      value: function() {
        for (var s = this, a = arguments.length, o = new Array(a), l = 0; l < a; l++)
          o[l] = arguments[l];
        var c = typeof o[0] == "string" ? o.shift() : void 0, u = Object(o[0]) === o[0] && typeof o[0] != "function" ? o.shift() : void 0, d = typeof o[0] == "function" ? o.shift() : void 0;
        if (typeof this.shouldStateBeChanged == "function" && !this.shouldStateBeChanged(c, u)) {
          d && d(null, !0);
          return;
        }
        var h = {
          group: u && u.group,
          state: c
        }, f = [h.group, c].filter(Boolean).join("-").split("-").map(function(b) {
          return b[0].toUpperCase() + b.substr(1);
        }).join(""), p = new CustomEvent(this.options["eventBefore".concat(f)], {
          bubbles: !0,
          cancelable: !0,
          detail: u
        }), v = u && u.delegatorNode || this.element, m = !v.dispatchEvent(p);
        if (m) {
          if (d) {
            var y = new Error("Changing state (".concat(JSON.stringify(h), ") has been canceled."));
            y.canceled = !0, d(y);
          }
        } else {
          var g = [c, u].filter(Boolean);
          this._changeState.apply(this, mI(g).concat([function() {
            v.dispatchEvent(new CustomEvent(s.options["eventAfter".concat(f)], {
              bubbles: !0,
              cancelable: !0,
              detail: u
            })), d && d();
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */
      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */
    }]), i;
  }(e);
  return t;
}
function Zc(e, t) {
  var n = e.target, r = e.currentTarget;
  if (typeof n.matches == "function") {
    if (n.matches(t))
      return n;
    if (n.matches("".concat(t, " *"))) {
      var i = n.closest(t);
      if ((r.nodeType === Node.DOCUMENT_NODE ? r.documentElement : r).contains(i))
        return i;
    }
  }
}
function ap(e) {
  if (!e || typeof e == "function")
    return {
      launchingElement: null,
      launchingEvent: null
    };
  var t = e.delegateTarget || e.currentTarget || e, n = e.currentTarget && e;
  if (t && !t.nodeType)
    throw new TypeError("DOM Node should be given for launching element.");
  if (n && !n.type)
    throw new TypeError("DOM event should be given for launching event.");
  return {
    launchingElement: t,
    launchingEvent: n
  };
}
function Kc(e) {
  "@babel/helpers - typeof";
  return Kc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kc(e);
}
function CI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function op(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function AI(e, t, n) {
  return t && op(e.prototype, t), n && op(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function $I(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Qc(e, t);
}
function Qc(e, t) {
  return Qc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Qc(e, t);
}
function LI(e) {
  var t = DI();
  return function() {
    var n = bo(e), r;
    if (t) {
      var i = bo(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return RI(this, r);
  };
}
function RI(e, t) {
  if (t && (Kc(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return kI(e);
}
function kI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function DI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function bo(e) {
  return bo = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, bo(e);
}
function II(e) {
  var t = /* @__PURE__ */ function(n) {
    $I(i, n);
    var r = LI(i);
    function i() {
      return CI(this, i), r.apply(this, arguments);
    }
    return AI(i, [{
      key: "show",
      value: (
        /**
         */
        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        function(s, a) {
          (!s || typeof s == "function") && (a = s), this.changeState("shown", ap(s), a);
        }
      )
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
    }, {
      key: "hide",
      value: function(s, a) {
        (!s || typeof s == "function") && (a = s), this.changeState("hidden", ap(s), a);
      }
    }]), i;
  }(e);
  return t;
}
var NI = [MI, II];
const PI = NI;
function UI(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var O0 = function() {
};
process.env.NODE_ENV !== "production" && (O0 = function(e, t, n) {
  var r = arguments.length;
  n = new Array(r > 2 ? r - 2 : 0);
  for (var i = 2; i < r; i++)
    n[i - 2] = arguments[i];
  if (t === void 0)
    throw new Error(
      "`warning(condition, format, ...args)` requires a warning message argument"
    );
  if (t.length < 10 || /^[s\W]*$/.test(t))
    throw new Error(
      "The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + t
    );
  if (!e) {
    var s = 0, a = "Warning: " + t.replace(/%s/g, function() {
      return n[s++];
    });
    typeof console < "u" && console.error(a);
    try {
      throw new Error(a);
    } catch {
    }
  }
});
var BI = O0;
const HI = /* @__PURE__ */ UI(BI);
function Jc(e) {
  "@babel/helpers - typeof";
  return Jc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jc(e);
}
function VI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lp(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function FI(e, t, n) {
  return t && lp(e.prototype, t), n && lp(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function zI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && tu(e, t);
}
function tu(e, t) {
  return tu = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, tu(e, t);
}
function GI(e) {
  var t = qI();
  return function() {
    var n = Eo(e), r;
    if (t) {
      var i = Eo(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return jI(this, r);
  };
}
function jI(e, t) {
  if (t && (Jc(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return WI(e);
}
function WI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function qI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Eo(e) {
  return Eo = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Eo(e);
}
function YI(e) {
  var t = /* @__PURE__ */ function(n) {
    zI(i, n);
    var r = GI(i);
    function i() {
      return VI(this, i), r.apply(this, arguments);
    }
    return FI(i, null, [{
      key: "init",
      value: (
        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */
        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        function() {
          var s = this, a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = Object.assign(Object.create(this.options), o);
          if (!a || a.nodeType !== Node.ELEMENT_NODE && a.nodeType !== Node.DOCUMENT_NODE)
            throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
          if (a.nodeType === Node.ELEMENT_NODE && a.matches(l.selectorInit))
            this.create(a, o);
          else {
            var c = l.initEventNames.map(function(u) {
              return rs(a, u, function(d) {
                var h = Zc(d, "[".concat(l.attribInitTarget, "]"));
                if (h) {
                  d.delegateTarget = h;
                  var f = h.ownerDocument.querySelectorAll(h.getAttribute(l.attribInitTarget));
                  if (f.length > 1)
                    throw new Error("Target widget must be unique.");
                  if (f.length === 1) {
                    h.tagName === "A" && d.preventDefault();
                    var p = s.create(f[0], o);
                    typeof p.createdByLauncher == "function" && p.createdByLauncher(d);
                  }
                }
              });
            });
            return {
              release: function() {
                for (var u = c.pop(); u; u = c.pop())
                  u.release();
              }
            };
          }
          return "";
        }
      )
    }]), i.forLazyInit = !0, i;
  }(e);
  return t;
}
function eu(e) {
  "@babel/helpers - typeof";
  return eu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, eu(e);
}
function XI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function cp(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function ZI(e, t, n) {
  return t && cp(e.prototype, t), n && cp(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function KI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && nu(e, t);
}
function nu(e, t) {
  return nu = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, nu(e, t);
}
function QI(e) {
  var t = eN();
  return function() {
    var n = _o(e), r;
    if (t) {
      var i = _o(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return JI(this, r);
  };
}
function JI(e, t) {
  if (t && (eu(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return tN(e);
}
function tN(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function eN() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _o(e) {
  return _o = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _o(e);
}
var nN = /* @__PURE__ */ function(e) {
  KI(n, e);
  var t = QI(n);
  function n(r, i) {
    var s;
    return XI(this, n), s = t.call(this, r, i), s._handleFocusinListener = void 0, s._handleKeydownListener = void 0, s._handleFocusin = function(a) {
      var o = s.element.querySelector(s.options.selectorModalContainer) || s.element;
      s.element.classList.contains(s.options.classVisible) && !o.contains(a.target) && s.options.selectorsFloatingMenus.every(function(l) {
        return !Zc(a, l);
      }) && s.element.querySelector(jl.selectorTabbable).focus();
    }, s._hookCloseActions(), s;
  }
  return ZI(n, [{
    key: "createdByLauncher",
    value: (
      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      function(r) {
        this.show(r);
      }
    )
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */
  }, {
    key: "shouldStateBeChanged",
    value: function(r) {
      return r === "shown" ? !this.element.classList.contains(this.options.classVisible) : this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */
  }, {
    key: "_changeState",
    value: function(r, i, s) {
      var a = this, o, l = function() {
        if (o && (o = a.unmanage(o).release()), r === "shown" && a.element.offsetWidth > 0 && a.element.offsetHeight > 0) {
          a.previouslyFocusedNode = a.element.ownerDocument.activeElement;
          var d = a.element.querySelector(a.options.selectorPrimaryFocus) || a.element.querySelector(jl.selectorTabbable);
          d.focus(), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && HI(d, "Modals need to contain a focusable element by either using " + "`".concat(a.options.selectorPrimaryFocus, "` or settings.selectorTabbable."));
        }
        s();
      };
      if (this._handleFocusinListener && (this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release()), r === "shown") {
        var c = "onfocusin" in this.element.ownerDocument.defaultView, u = c ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(rs(this.element.ownerDocument, u, this._handleFocusin, !c));
      }
      r === "hidden" ? (this.element.classList.toggle(this.options.classVisible, !1), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !1), (this.options.selectorFocusOnClose || this.previouslyFocusedNode) && (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus()) : r === "shown" && (this.element.classList.toggle(this.options.classVisible, !0), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !0)), o = this.manage(rs(this.element, "transitionend", l));
    }
  }, {
    key: "_hookCloseActions",
    value: function() {
      var r = this;
      this.manage(rs(this.element, "click", function(i) {
        var s = Zc(i, r.options.selectorModalClose);
        s && (i.delegateTarget = s), (s || i.target === r.element) && r.hide(i);
      })), this._handleKeydownListener && (this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release()), this._handleKeydownListener = this.manage(rs(this.element.ownerDocument.body, "keydown", function(i) {
        i.which === 27 && r.shouldStateBeChanged("hidden") && (i.stopPropagation(), r.hide(i));
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */
  }], [{
    key: "options",
    get: (
      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      function() {
        var r = jl.prefix;
        return {
          selectorInit: "[data-modal]",
          selectorModalClose: "[data-modal-close]",
          selectorPrimaryFocus: "[data-modal-primary-focus]",
          selectorsFloatingMenus: [".".concat(r, "--overflow-menu-options"), ".".concat(r, "--tooltip"), ".flatpickr-calendar"],
          selectorModalContainer: ".".concat(r, "--modal-container"),
          classVisible: "is-visible",
          classBody: "".concat(r, "--body--with-modal-open"),
          attribInitTarget: "data-modal-target",
          initEventNames: ["click"],
          eventBeforeShown: "modal-beingshown",
          eventAfterShown: "modal-shown",
          eventBeforeHidden: "modal-beinghidden",
          eventAfterHidden: "modal-hidden"
        };
      }
    )
  }]), n.components = /* @__PURE__ */ new WeakMap(), n;
}(QD(sI, YI, PI, pI));
class Ko extends yt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const i = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${i}__modal-title`).attr("aria-describedby", `${i}__modal-description`).attr("tabindex", -1), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), nN.create(this.modal.node()).show(), document.addEventListener("modal-hidden", this.handleHideModal);
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null), document.removeEventListener("modal-hidden", this.handleHideModal);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(O.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(O.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.services.domUtils.getChartID(), n = this.model.getOptions(), { title: r, downloadAsCSV: i } = x(n, "locale", "translations", "tabularRep"), s = x(n, "style", "prefix"), a = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="modal-title">${r}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${un(
      n.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${_t(a, 0).map(
      (o) => `<th scope="col">
								<div class="cds--table-header-label">${un(o)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${a.slice(1).map(
      (o) => `
							<tr>
								${o.map((l) => `<td>${un(l)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${ve}--${s}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${i}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const r = I(this.services.domUtils.getHolder()), i = x(n, "style", "prefix");
      this.modal = N.appendOrSelect(r, `div.${ve}--${i}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class zs extends yt {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = rt.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getComponentContainer(), r = x(this.getOptions(), "title"), i = n.selectAll("p.title").data([r]);
    if (i.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(i).html((s) => un(s)), i.node() && i.node().offsetWidth < i.node().scrollWidth) {
      const s = this;
      i.on("mouseover", function(a) {
        s.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: a,
          hoveredElement: i,
          content: i.text()
        });
      }).on("mousemove", function(a) {
        s.services.events.dispatchEvent(O.Tooltip.MOVE, {
          event: a
        });
      }).on("mouseout", function() {
        s.services.events.dispatchEvent(O.Tooltip.HIDE);
      });
    }
    i.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, n) {
    if (n <= 0)
      return;
    const r = t.text();
    if (t.node().getComputedTextLength() > n) {
      t.append("tspan").text("...");
      const i = N.appendOrSelect(t, "tspan").node().getComputedTextLength(), s = t.text(), a = this.getSubstringIndex(
        t.node(),
        0,
        s.length - 1,
        n - i
      );
      t.html(s.substring(0, a - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(l) {
        o.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: l,
          hoveredElement: t,
          content: r
        });
      }).on("mousemove", function(l) {
        o.services.events.dispatchEvent(O.Tooltip.MOVE, {
          event: l
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(O.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return N.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, n, r, i) {
    const s = Math.floor((r + n) / 2);
    return t.getSubStringLength(0, s) > i ? this.getSubstringIndex(t, n, s, i) : t.getSubStringLength(0, s) < i ? t.getSubStringLength(0, s + 1) > i ? s : this.getSubstringIndex(t, s, r, i) : s;
  }
}
class lh extends yt {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = rt.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = x(n, "legend"), i = x(r, "alignment"), s = x(n, "legend", "orientation");
    let a = this.model.getDataGroups();
    const { DISABLED: o } = qt.items.status, l = a.some((g) => g.status === o), c = x(r, "order"), u = this.getComponentContainer().classed("center-aligned", i === ee.CENTER).classed("right-aligned", i === ee.RIGHT).classed(s, !0).classed("has-deactivated-items", l).attr("role", ht.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    c && (a = this.sortDataGroups(a, c));
    const d = u.selectAll("div.legend-item").data(a, (g) => g.name), h = d.enter().append("div").attr("class", "legend-item");
    h.merge(u.selectAll("div.legend-item")).classed("active", function(g) {
      return g.status === qt.items.status.ACTIVE;
    });
    const f = x(this.getOptions(), "legend", "clickable");
    u.classed("clickable", f && a.length > 1);
    const p = qt.checkbox.radius, v = h.append("div").classed("checkbox", !0), m = v.merge(d.select("div.checkbox")).attr("role", ht.CHECKBOX).attr("tabindex", f ? 0 : -1).attr(
      "aria-labelledby",
      (g, b) => this.services.domUtils.generateElementIDString(`legend-datagroup-${b}-title`)
    ).attr("aria-checked", ({ status: g }) => g === qt.items.status.ACTIVE).attr("width", p * 2).attr("height", p * 2).attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [st.BACKGROUND],
        dataGroupName: g.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (g) => g.status === qt.items.status.ACTIVE ? this.model.getFillColor(g.name) || this.model.getStrokeColor(g.name) : null
    ).classed("active", function(g) {
      return g.status === qt.items.status.ACTIVE;
    });
    v.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), h.append("p").merge(d.select("p"));
    const y = x(n, "legend", "additionalItems");
    if (y && a.length) {
      const g = this, b = u.selectAll("div.additional-item").data(y);
      b.exit().remove();
      const w = b.enter().append("div").merge(b).classed("legend-item", !0).classed("additional", !0).attr(
        "aria-labelledby",
        (L, D) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${m.size() + D}-title`
        )
      );
      w.selectAll("*").remove();
      let _, S = 1;
      w.append("svg").classed("icon", !0).each(function(L) {
        const D = I(this);
        !_ || _ != L.type ? (_ = L.type, S = 1) : S++, g.addAdditionalItem(D, L, S);
      }), w.append("p").merge(w.select("p")), this.truncateLegendText();
    }
    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), f && h.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, n) {
    if (t.sort(
      (r, i) => n.indexOf(r.name) - n.indexOf(i.name)
    ), n.length < t.length) {
      const r = t.length - n.length;
      return t.slice(r).concat(t.slice(0, r));
    }
    return t;
  }
  addAdditionalItem(t, n, r) {
    const { width: i, height: s } = qt.area;
    if (n.type === Qt.RADIUS ? t.style("width", `${s}px`).style("height", `${s}px`) : t.style("width", `${i}px`).style("height", `${s}px`), n.type === Qt.RADIUS) {
      const { iconData: a, fill: o, stroke: l } = qt.radius;
      t.attr("fill", "none").selectAll("circle").data(a).enter().append("circle").classed("radius", !0).attr("role", ht.IMG).attr("aria-label", "radius").attr("cx", (c) => c.cx).attr("cy", (c) => c.cy).attr("r", (c) => c.r).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l);
    } else if (n.type === Qt.LINE) {
      const a = qt.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", a.yPosition).attr("x2", i).attr("y2", a.yPosition).style("stroke", n.stroke ? n.stroke : a.stroke).style("stroke-width", a.strokeWidth);
    } else if (n.type === Qt.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${r}`, !0).attr("role", ht.IMG).attr("aria-label", "area").attr("width", i).attr("height", s).style(
        "fill",
        r > 3 && !n.fill ? qt.area.fill : n.fill
      ).style("stroke", n.stroke);
    else if (n.type === Qt.SIZE) {
      const { iconData: a, fill: o, stroke: l } = qt.size;
      t.attr("fill", "none").attr("role", ht.IMG).attr("aria-label", "size").selectAll("rect").data(a).enter().append("rect").classed("size", !0).attr("width", (c) => c.width).attr("height", (c) => c.height).attr("y", () => 0).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l).style("stroke-width", 1);
    } else if (n.type === Qt.QUARTILE) {
      const { iconData: a } = qt.quartile;
      t.selectAll("rect").attr("role", ht.IMG).attr("aria-label", "quartile").data(a).enter().append("rect").attr("class", (o, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (o) => o.x).attr("y", (o) => o.y).attr("width", (o) => o.width).attr("height", (o) => o.height);
    } else if (n.type === Qt.ZOOM) {
      const { iconData: a, color: o } = x(qt, "zoom"), l = t.attr("role", ht.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(a).enter();
      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => n.color ? n.color : o), l.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => n.color ? n.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), n = x(this.getOptions(), "legend", "truncation"), r = x(n, "type"), i = x(n, "threshold"), s = x(n, "numCharacter"), a = t.selectAll("div.legend-item p");
    a.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), r !== qe.NONE ? a.html(function(o) {
      const l = un(o.name);
      return l.length > i && l.length !== s ? As(l, r, s) : l;
    }) : a.html((o) => un(o.name));
  }
  addEventListeners() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = x(r, "legend"), s = x(i, "truncation");
    n.selectAll("div.legend-item").on("mouseover", function(a) {
      t.services.events.dispatchEvent(O.Legend.ITEM_HOVER, {
        hoveredElement: I(this)
      });
      const o = I(this);
      o.select("div.checkbox").classed("hovered", !0);
      const l = o.datum();
      l.name.length > s.threshold && s.numCharacter < l.name.length && s.type !== qe.NONE && t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    }).on("mousemove", function(a) {
      I(this).datum().name.length > s.threshold && s.type !== qe.NONE && t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(O.Legend.ITEM_CLICK, {
        clickedElement: I(this)
      });
      const a = I(this).datum();
      t.model.toggleDataLabel(a.name);
    }).on("mouseout", function() {
      const a = I(this);
      a.select("div.checkbox").classed("hovered", !1), a.datum().name.length > s.threshold && s.type !== qe.NONE && t.services.events.dispatchEvent(O.Tooltip.HIDE), t.services.events.dispatchEvent(O.Legend.ITEM_MOUSEOUT, {
        hoveredElement: a
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keyup", function(a) {
      a.key && a.key === "Tab" && t.services.events.dispatchEvent(O.Legend.ITEM_HOVER, {
        hoveredElement: I(this)
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keydown", function(a, o) {
      a.key && a.key === " " ? (a.preventDefault(), t.model.toggleDataLabel(o.name)) : a.key && a.key === "Tab" && t.services.events.dispatchEvent(O.Legend.ITEM_MOUSEOUT, {
        hoveredElement: I(this)
      });
    }), n.selectAll("g.additional-item").on("mouseover", function(a) {
      const o = I(this), l = o.datum();
      l.name.length > s.threshold && t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    });
  }
}
class T0 extends yt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "chart-clip", this.renderType = rt.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Service cartesianScales was undefined");
    const r = n.getMainXScale(), i = n.getMainYScale(), [s, a] = r.range(), [o, l] = i.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = N.appendOrSelect(
      t,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const c = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    a - s > 0 && c.attr("x", s).attr("y", l).attr("width", a - s).attr("height", o - l), this.chartClipPath.merge(c).lower();
  }
}
class rN extends T0 {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: n, height: r } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = N.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const i = N.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i.attr("x", 0).attr("y", 0).attr("width", n).attr("height", r), this.chartClipPath.merge(i).lower();
  }
}
var Ur, Zt;
(function(e) {
  e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom";
})(Zt || (Zt = {}));
var up = (Ur = {}, Ur[Zt.LEFT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left - t.offsetWidth)
  };
}, Ur[Zt.RIGHT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left + n.width)
  };
}, Ur[Zt.TOP] = function(e, t, n) {
  return {
    top: Math.round(e.top - t.offsetHeight),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, Ur[Zt.BOTTOM] = function(e, t, n) {
  return {
    top: Math.round(e.top + n.height),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, Ur), hp = typeof window < "u" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
}, Qo = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.positions = up, this.positions = Object.assign({}, up, t);
    }
    return e.prototype.getRelativeOffset = function(t) {
      for (var n = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;
      return n;
    }, e.prototype.getAbsoluteOffset = function(t) {
      for (var n = t, r = {
        top: 0,
        left: 0
      }; n.offsetParent; ) {
        var i = getComputedStyle(n.offsetParent);
        i.position === "static" && i.marginLeft && i.marginTop && (parseInt(i.marginTop, 10) && (r.top += parseInt(i.marginTop, 10)), parseInt(i.marginLeft, 10) && (r.left += parseInt(i.marginLeft, 10))), n = n.offsetParent;
      }
      var s = t.getBoundingClientRect(), a = document.body.getBoundingClientRect();
      return {
        top: s.top - a.top + r.top,
        left: s.left - a.left + r.left
      };
    }, e.prototype.findRelative = function(t, n, r) {
      var i = this.getRelativeOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findAbsolute = function(t, n, r) {
      var i = this.getAbsoluteOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findPosition = function(t, n, r, i) {
      i === void 0 && (i = this.getAbsoluteOffset.bind(this));
      var s = i(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, n, r);
    }, e.prototype.findPositionAt = function(t, n, r) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, n, r);
    }, e.prototype.getPlacementBox = function(t, n) {
      var r = t.offsetHeight + n.top, i = t.offsetWidth + n.left;
      return {
        top: n.top,
        bottom: r,
        left: n.left,
        right: i
      };
    }, e.prototype.addOffset = function(t, n, r) {
      return n === void 0 && (n = 0), r === void 0 && (r = 0), Object.assign({}, t, {
        top: t.top + n,
        left: t.left + r
      });
    }, e.prototype.setElement = function(t, n) {
      t.style.top = n.top + "px", t.style.left = n.left + "px";
    }, e.prototype.findBestPlacement = function(t, n, r, i, s) {
      var a = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this)), s === void 0 && (s = this.findPosition.bind(this));
      var o = r.map(function(l) {
        var c = s(t, n, l), u = a.getPlacementBox(n, c), d = 0, h = 0, f = i();
        u.top < f.top ? d = f.top - u.top : u.bottom > f.height && (d = u.bottom - f.height), u.left < f.left ? h = f.left - u.left : u.right > f.width && (h = u.right - f.width), d && !h ? h = 1 : h && !d && (d = 1);
        var p = n.offsetHeight * n.offsetWidth, v = d * h, m = p - v, y = m / p;
        return {
          placement: l,
          weight: y
        };
      });
      return o.sort(function(l, c) {
        return c.weight - l.weight;
      }), o[0].placement;
    }, e.prototype.findBestPlacementAt = function(t, n, r, i) {
      var s = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this));
      var a = function(o, l, c) {
        return s.findPositionAt(t, l, c);
      };
      return this.findBestPlacement(null, n, r, i, a);
    }, e.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: hp.innerHeight,
        width: hp.innerWidth
      };
    }, e.prototype.calculatePosition = function(t, n, r, i) {
      return this.positions[i] ? this.positions[i](t, r, n) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, e;
  }()
);
new Qo();
class ch extends yt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "tooltip", this.renderType = rt.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new Qo(), this.handleShowTooltip = (i) => {
      const s = i.detail.data || i.detail.items;
      let a;
      const o = this.formatItems(this.getItems(i));
      i.detail.content ? a = `<div class="title-tooltip"><p>${ma(i.detail.content)}</p></div>` : a = ma(this.getTooltipHTML(o));
      const l = N.appendOrSelect(this.tooltip, "div.content-box");
      if (x(this.getOptions(), "tooltip", "customHTML"))
        if (i.detail.content) {
          const c = `<div class="title-tooltip"><p>${ma(
            i.detail.content
          )}</p></div>`;
          l.html(c);
        } else
          l.html(
            `<div class="title-tooltip"><p>${ma(
              this.model.getOptions().tooltip.customHTML(s, a)
            )}</p></div>`
          );
      else
        l.html(a);
      l.selectAll(".datapoint-tooltip").each(function(c, u) {
        const d = o[u];
        o[u] && o[u].color && I(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", d.color);
      }), this.positionTooltip(i), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = i.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(O.Tooltip.MOVE, (t) => {
      this.lastTriggeredEventType !== O.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(O.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(O.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(O.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(O.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(O.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(O.Tooltip.MOVE, null), this.services.events.removeEventListener(O.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(O.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(O.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(O.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(O.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const n = this.getOptions(), r = x(n, "tooltip", "truncation", "type"), i = x(n, "tooltip", "truncation", "threshold"), s = x(n, "tooltip", "truncation", "numCharacter");
    return r !== qe.NONE ? t.map((a) => {
      const o = a.labelIcon ? 12 : 0;
      return a.value = a.value ? this.valueFormatter(a.value, a.label) : a.value, a.label && a.label.length + o > i && (a.label = As(a.label, r, s)), a.value && a.value.length > i && (a.value = As(a.value, r, s)), a;
    }) : t.map((a) => (a.value = a.value ? this.valueFormatter(a.value, a.label) : a.value, a));
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (n) => `<li>
					<div class="datapoint-tooltip${n.bold ? " bold" : ""}">
						${n.class || n.color ? `<div class="tooltip-color ${n.class}"></div>` : ""}
						<div class="label">
						<p>${n.label || ""}</p>
						${n.labelIcon ? `<span class="label-icon"/>${n.labelIcon}</span>` : ""}
						</div>
						${n.value === void 0 || n.value === null ? "" : `<p class="value"/>${n.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  valueFormatter(t, n) {
    const r = this.getOptions(), i = x(r, "tooltip", "valueFormatter"), {
      code: s,
      number: a,
      date: o
    } = x(r, "locale");
    if (i)
      return i(t, n);
    if (typeof t.getTime == "function")
      return o(t, s, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t)) {
        const l = new Date(t);
        return o(l, s, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return a(t, s);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = x(n, "tooltip", "enabled");
    if (r) {
      const i = I(this.services.domUtils.getHolder()), s = x(n, "style", "prefix");
      this.tooltip = N.appendOrSelect(i, `div.${ve}--${s}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else
      !r && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(t, n, r) {
    const i = Object.assign({}, t);
    return n == Zt.LEFT ? i.left -= r : n == Zt.RIGHT ? i.left += r : n == Zt.TOP ? i.top -= r : n == Zt.BOTTOM && (i.top += r), i;
  }
  positionTooltip(t) {
    const n = this.services.domUtils.getHolder(), r = n.offsetWidth, i = n.offsetHeight, s = this.tooltip.node(), a = this.getOptions(), o = x(a, "zoomBar", "top", "enabled"), l = !!x(t, "detail", "noWrap"), c = Array.isArray(x(t, "detail", "placements")), u = c ? x(t, "detail", "placements") : [Zt.RIGHT, Zt.LEFT, Zt.TOP, Zt.BOTTOM];
    let d, { horizontalOffset: h, defaultOffset: f } = c$;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", l), c) {
      const m = x(t, "detail", "event", "target"), y = this.services.domUtils.getElementOffset(m, !0);
      d = this.positionService.findBestPlacementAt(
        y,
        s,
        u,
        () => ({
          top: 0,
          left: 0,
          width: r,
          height: i
        })
      );
      let g = this.positionService.findPosition(
        m,
        s,
        d,
        () => this.services.domUtils.getElementOffset(m)
      );
      g = this.addOffsetByPlacement(
        g,
        d,
        f
      ), this.positionService.setElement(s, g);
      return;
    }
    let p = x(t, "detail", "mousePosition");
    if (!p)
      p = vr(x(t, "detail", "event"), n);
    else {
      const m = x(a, "zoomBar", "top", "type"), y = Te.height[m];
      o && (p[1] += y + Te.spacerHeight);
    }
    p[0] / r > 0.9 ? d = Zt.LEFT : p[0] / r < 0.1 ? d = Zt.RIGHT : d = this.positionService.findBestPlacementAt(
      {
        left: p[0],
        top: p[1]
      },
      s,
      u,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: r,
        height: i
      })
    ), d === Zt.LEFT && (h *= -1);
    const v = this.positionService.findPositionAt(
      {
        left: p[0] + h,
        top: p[1]
      },
      s,
      d
    );
    this.positionService.setElement(s, v);
  }
}
const M0 = class ka extends yt {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = rt.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.parent, r = this.getComponentContainer();
    if (!n)
      throw new Error("SVG was not defined");
    const i = N.appendOrSelect(
      n,
      "svg.chart-grid-backdrop"
    ), s = N.appendOrSelect(i, `g.${this.type}`), a = N.appendOrSelect(s, this.selectionSelector), { width: o, height: l } = N.getSVGElementSize(i, {
      useAttrs: !0
    }), { cartesianScales: c } = this.services, u = c.getMainXScaleType(), d = c.getMainXScale(), [h] = d.range();
    r.attr("transform", `translate(${h},0)`);
    const f = N.appendOrSelect(r, this.frontSelectionSelector);
    if (d && u === et.TIME) {
      let p = this.model.get("zoomDomain");
      p === void 0 && (p = this.services.zoom.getDefaultZoomBarDomain(), p && this.model.set({ zoomDomain: p }, { animate: !1 }));
      const v = (_) => {
        const S = _[1] - _[0];
        let L = "0," + S.toString();
        const D = Math.floor(l / ka.DASH_LENGTH), k = D * ka.DASH_LENGTH;
        for (let R = 0; R < D; R++)
          L += "," + ka.DASH_LENGTH;
        L += "," + (l - k), D % 2 === 1 && (L += ",0"), L += "," + S.toString(), L += "," + l.toString(), f.attr("stroke-dasharray", L);
      }, m = (_) => {
        const S = _.selection;
        S === null || S[0] === S[1] || (f.attr("x", parseFloat(a.attr("x")) + parseFloat(i.attr("x"))).attr("y", a.attr("y")).attr("width", a.attr("width")).attr("height", a.attr("height")).style("cursor", "pointer").style("display", null), v(S));
      }, y = (_, S) => {
        const L = yg().range([0, o]).domain(p);
        let D = [L.invert(_), L.invert(S)];
        D[0].valueOf() === D[1].valueOf() && (D = this.services.zoom.getDefaultZoomBarDomain()), (p[0].valueOf() !== D[0].valueOf() || p[1].valueOf() !== D[1].valueOf()) && this.services.zoom.handleDomainChange(D);
      };
      let g;
      const b = (_) => {
        const S = _.selection;
        S !== null && (y(S[0], S[1]), s.call(g.move, null), f.style("display", "none"));
      };
      l != 0 && o != 0 && (g = Am().extent([
        [0, 0],
        [o - 1, l]
      ]).on("start brush end", m).on("end.brushed", b), s.call(g));
      const w = this.services.zoom.getZoomRatio();
      i.on("click", function(_) {
        if (_.shiftKey) {
          const S = this.services.domUtils.getHolder(), L = vr(s.node(), S)[0];
          let D = L - o * w / 2;
          D < 0 && (D = 0);
          let k = L + o * w / 2;
          k > o && (k = o), y(D, k);
        }
      });
    }
  }
};
M0.DASH_LENGTH = 4;
let iN = M0;
class sN extends yt {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = rt.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = Am(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(O.ZoomBar.UPDATE, this.render.bind(this));
    const t = x(this.getOptions(), "zoomBar", F.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer(), r = this.services.zoom.isZoomBarLoading(F.TOP), i = this.services.zoom.isZoomBarLocked(F.TOP), s = x(this.getOptions(), "zoomBar", F.TOP, "type"), a = x(this.getOptions(), "axes", F.BOTTOM, "highlights"), o = Te.height[s], { width: l } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (l === 0)
      return;
    let c = 0;
    const u = this.model.get("axesMargins");
    u && u.left && (c = u.left);
    const d = N.appendOrSelect(n, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1);
    if (N.appendOrSelect(n, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", Te.spacerHeight).attr("opacity", 1).attr("fill", "none"), s === an.GRAPH_VIEW ? N.appendOrSelect(d, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : s === an.SLIDER_VIEW && N.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", c).attr("y", o / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), r) {
      this.renderSkeleton(d, c, l);
      return;
    }
    const { cartesianScales: h } = this.services, f = h.getMainXScale(), p = h.getMainYScale(), v = h.getMainXScaleType();
    if (f && v === et.TIME) {
      let m = this.services.zoom.getZoomBarData();
      if (We(m) || m.length === 1)
        return;
      this.xScale = f.copy(), this.yScale = p.copy();
      const y = this.services.zoom.getDefaultZoomBarDomain(m);
      m = this.compensateDataForDefaultDomain(m, y);
      const g = this.model.get("initialZoomDomain"), b = x(
        this.getOptions(),
        "zoomBar",
        F.TOP,
        "initialZoomDomain"
      );
      b && b[0] && b[1] && (b[0] = new Date(b[0]), b[1] = new Date(b[1])), b && !(g && g[0].valueOf() === b[0].valueOf() && g[1].valueOf() === b[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: ct([], b),
          zoomDomain: b ? ct([], b) : y
        },
        { skipUpdate: !0 }
      ) : b === null && g !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: ct([], y)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([c, l]).domain(y), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(Ye(m, (S) => S.value));
      const w = this.model.get("zoomDomain");
      if (s === an.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", m, null), this.updateClipPath(n, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", m, this.clipId), this.renderZoomBarBaseline(d, c, l), a)) {
        const S = a.highlightStartMapsTo, L = a.highlightEndMapsTo, D = a.color, k = a.labelMapsTo;
        a.data.forEach((R, M) => {
          N.appendOrSelect(d, `rect.highlight-${M}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(R[S])).attr(
            "width",
            this.xScale(R[L]) - this.xScale(R[S])
          ).style(
            "fill",
            D && D.scale[R[k]] ? D.scale[R[k]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            D && D.scale[R[k]] ? D.scale[R[k]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(w, c, l);
      const _ = N.appendOrSelect(n, this.brushSelector).call(this.brush);
      if (w !== void 0)
        if (w[0].valueOf() === w[1].valueOf())
          _.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
        else {
          const S = w.map((L) => this.xScale(L));
          S[1] - S[0] < this.MIN_SELECTION_DIFF || (_.call(this.brush.move, S), this.updateBrushHandle(this.getComponentContainer(), S));
        }
      i && (this.brush.filter(() => !1), _.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, n, r) {
    const i = (o) => {
      const l = o.selection;
      l === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(o, t, this.xScale, l);
    }, s = x(this.getOptions(), "zoomBar", F.TOP, "type"), a = Te.height[s];
    this.brush.extent([
      [n, 0],
      [r, a]
    ]).on("start brush end", null).on("start brush end", i);
  }
  // brush event listener
  handleBrushedEvent(t, n, r, i) {
    const s = [r.invert(i[0]), r.invert(i[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), i), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      (n === void 0 || n[0] !== s[0] || n[1] !== s[1]) && this.services.zoom.handleDomainChange(s, {
        dispatchEvent: !1
      });
      let a;
      t.type === "start" ? a = O.ZoomBar.SELECTION_START : t.type === "brush" ? a = O.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (a = O.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(O.ZoomDomain.CHANGE, {
        newDomain: s
      })), this.services.events.dispatchEvent(a, {
        selection: i,
        newDomain: s
      });
    }
  }
  updateBrushHandle(t, n) {
    const r = this, i = Te.handleWidth, s = x(this.getOptions(), "zoomBar", F.TOP, "type"), a = Te.height[s], o = -i / 2, l = Te.handleBarWidth, c = s === an.GRAPH_VIEW ? Te.handleBarHeight : 6, u = -l / 2, d = (a - c) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(f) {
      if (f.type === "w")
        return Math.max(n[0] + o, r.maxSelectionRange[0]);
      if (f.type === "e")
        return Math.min(n[1] + o, r.maxSelectionRange[1] - i);
    }).attr("y", 0).attr("width", i).attr("height", a).attr("cursor", "ew-resize").style("display", null);
    const h = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    h.enter().append("rect").attr("class", function(f) {
      return "handle-bar handle-bar--" + f.type;
    }), h.attr("x", function(f) {
      if (f.type === "w")
        return Math.max(
          n[0] + u,
          r.maxSelectionRange[0] - o + u
        );
      if (f.type === "e")
        return Math.min(
          n[1] + u,
          r.maxSelectionRange[1] + o + u
        );
    }).attr("y", d).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), s === an.SLIDER_VIEW && this.updateSliderSelectedArea(n), this.updateClipPath(
      t,
      this.clipId,
      n[0],
      0,
      n[1] - n[0],
      a
    );
  }
  updateSliderSelectedArea(t) {
    const n = x(this.getOptions(), "zoomBar", F.TOP, "type"), r = Te.height[n], i = this.getComponentContainer().select("svg.zoom-container");
    N.appendOrSelect(i, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", r / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, n, r, i) {
    const { cartesianScales: s } = this.services, a = s.getMainXAxisPosition(), o = s.getMainYAxisPosition(), l = s.getMainXScaleType(), c = s.getMainYScaleType(), u = (y, g, b) => (w) => s.getValueFromScale(y, g, b, w), d = u(this.xScale, l, a), h = u(this.yScale, c, o), f = x(this.getOptions(), "zoomBar", F.TOP, "type"), p = Te.height[f], v = Nu().x((y) => d(y)).y0(p).y1((y) => p - h(y)), m = N.appendOrSelect(t, n).datum(r).attr("d", v);
    i && m.attr("clip-path", `url(#${i})`);
  }
  updateClipPath(t, n, r, i, s, a) {
    const o = N.appendOrSelect(t, "clipPath").attr("id", n);
    N.appendOrSelect(o, "rect").attr("x", r).attr("y", i).attr("width", s).attr("height", a);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, n) {
    if (!t || t.length < 2)
      return;
    const r = In(t), i = this.services.cartesianScales.getDomainIdentifier(), s = this.services.cartesianScales.getRangeIdentifier();
    if (Number(n[0]) < Number(r[0][i])) {
      const a = {};
      a[i] = n[0], a[s] = 0, r.unshift(a);
    }
    if (Number(n[1]) > Number(r[r.length - 1][i])) {
      const a = {};
      a[i] = n[1], a[s] = 0, r.push(a);
    }
    return r;
  }
  renderZoomBarBaseline(t, n, r, i = !1) {
    const s = x(
      this.model.getOptions(),
      "zoomBar",
      F.TOP,
      "type"
    ), a = Te.height[s], o = Ns()([
      [n, a],
      [r, a]
    ]);
    N.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", i).style(
      "stroke",
      i ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, n, r) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), N.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), x(this.getOptions(), "zoomBar", F.TOP, "type") === an.GRAPH_VIEW && this.renderZoomBarBaseline(t, n, r, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(O.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class aN extends yt {
  constructor(t, n) {
    super(t, n), this.type = "threshold", this.renderType = rt.SVG, this.positionService = new Qo();
  }
  render(t = !1) {
    const n = x(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(F).includes(c)) {
        const u = n[c];
        u.thresholds && u.thresholds.length > 0 && r.push({
          axisPosition: c,
          thresholds: u.thresholds,
          correspondingDatasets: u == null ? void 0 : u.correspondingDatasets,
          mapsTo: u == null ? void 0 : u.mapsTo
        });
      }
    });
    const i = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-thresholds").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-thresholds ${c.axisPosition}`);
    const a = s.selectAll("g.threshold-group").data(
      (c) => c.thresholds.map((u) => (u.axisPosition = c.axisPosition, u.datum = this.constructDatumObj(c, u), u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("line").attr("class", "threshold-line"), o.append("rect").attr("class", "threshold-hoverable-area"), o.merge(a).attr("class", "threshold-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getScaleByPosition(
        c
      ), d = l.services.cartesianScales.getScaleTypeByPosition(c);
      let h = null, f = null;
      c === F.LEFT || c === F.RIGHT ? (f = u, h = l.services.cartesianScales.getMainXScale()) : (h = u, f = l.services.cartesianScales.getMainYScale());
      const p = d === et.LABELS, [v, m] = h.range(), [y, g] = f.range(), { cartesianScales: b } = l.services, w = b.getOrientation(), _ = (R) => b.getDomainValue(R), S = (R) => b.getRangeValue(R), [L, D] = Cn(
        _,
        S,
        w
      ), k = I(this);
      c === F.TOP || c === F.BOTTOM ? (k.selectAll("line.threshold-line").transition().call(
        (R) => l.services.transitions.setupTransition({
          transition: R,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", g).attr("y2", y).attr(
        "x1",
        ({ datum: R }) => L(R) + (p ? u.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: R }) => L(R) + (p ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: R }) => R), k.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: R }) => -L(R)).attr("width", Math.abs(y - g)).classed("rotate", !0)) : (k.selectAll("line.threshold-line").transition().call(
        (R) => l.services.transitions.setupTransition({
          transition: R,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", v).attr("x2", m).attr(
        "y1",
        ({ datum: R }) => D(R) + (p ? u.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: R }) => D(R) + (p ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: R }) => R), k.selectAll("rect.threshold-hoverable-area").attr("x", v).attr("y", ({ datum: R }) => D(R)).attr("width", Math.abs(m - v)).classed("rotate", !1));
    }), this.services.events.addEventListener(O.Threshold.SHOW, (c) => {
      this.setThresholdLabelPosition(c.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(O.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: n, axisPosition: r } = t, i = this.getOptions(), s = this.services.cartesianScales.getScaleTypeByPosition(r), { code: a, number: o } = x(i, "locale");
    if (s === et.TIME) {
      const l = [F.LEFT, F.RIGHT].includes(r), c = this.services.cartesianScales.getMainXScale(), u = this.services.cartesianScales.getMainYScale(), d = l ? u : c, h = x(i, "timeScale"), f = kc(
        d.ticks(),
        x(h, "timeInterval")
      );
      return Rc(n, 0, d.ticks(), f, h, i.locale);
    }
    return o(n, a);
  }
  appendThresholdLabel() {
    const t = I(this.services.domUtils.getHolder()), n = x(this.getOptions(), "style", "prefix");
    this.label = N.appendOrSelect(
      t,
      `div.${ve}--${n}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: n }) {
    const r = this.services.domUtils.getHolder(), i = vr(t, r), s = n.valueFormatter ? n.valueFormatter(n.value) : this.getFormattedValue(n);
    this.label.html(un(`${n.label || "Threshold"}: ${s}`)).style("background-color", n.fillColor);
    const a = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      [Zt.RIGHT, Zt.LEFT, Zt.TOP, Zt.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: r.offsetWidth,
        height: r.offsetHeight
      })
    ), l = this.positionService.findPositionAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      o
    );
    this.positionService.setElement(a, l);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, n) {
    const r = {};
    return t.correspondingDatasets && (r.group = x(t, "correspondingDatasets", 0)), r[t.mapsTo] = n.value, r;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      I(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(O.Threshold.SHOW, {
        event: n,
        hoveredElement: I(this),
        datum: I(this).datum()
      });
    }).on("mouseout", function(n) {
      I(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(O.Threshold.HIDE, {
        event: n,
        hoveredElement: I(this),
        datum: I(this).datum()
      });
    });
  }
}
class oN extends yt {
  constructor(t, n) {
    super(t, n), this.type = "highlight", this.renderType = rt.SVG, this.positionService = new Qo(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const n = x(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(F).includes(c)) {
        const u = n[c];
        u.highlights && u.highlights.data.length > 0 && r.push({
          axisPosition: c,
          highlightStartMapsTo: u.highlights.highlightStartMapsTo,
          highlightEndMapsTo: u.highlights.highlightEndMapsTo,
          labelMapsTo: u.highlights.labelMapsTo,
          highlight: u.highlights.data,
          color: u.highlights.color
        });
      }
    });
    const i = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-highlight").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-highlight ${c.axisPosition}`);
    const a = s.selectAll("g.highlight-group").data(
      (c) => c.highlight.map((u) => (u.axisPosition = c.axisPosition, u.highlightStartMapsTo = c.highlightStartMapsTo, u.labelMapsTo = c.labelMapsTo, u.color = c.color, u.highlightEndMapsTo = c.highlightEndMapsTo, u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("rect").attr("class", "highlight-bar"), o.append("line").attr("class", "highlight-line"), o.merge(a).attr("class", "highlight-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getMainXScale(), d = l.services.cartesianScales.getMainYScale(), [h, f] = u.range(), [p, v] = d.range(), { cartesianScales: m } = l.services, y = m.getOrientation(), g = (L) => m.getDomainValue(L), b = (L) => m.getRangeValue(L), [w, _] = Cn(
        g,
        b,
        y
      ), S = I(this);
      c === F.TOP || c === F.BOTTOM ? S.selectAll("rect.highlight-bar").transition().call(
        (L) => l.services.transitions.setupTransition({
          transition: L,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(v + l.highlightStrokeWidth, 0)).attr("height", Math.max(p - 2 * l.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: L, ...D }) => w(D[L])).attr(
        "width",
        ({ highlightStartMapsTo: L, highlightEndMapsTo: D, ...k }) => Math.max(w(k[D]) - w(k[L]), 0)
      ).style("stroke", ({ color: L, labelMapsTo: D, ...k }) => L && L.scale[k[D]] ? L.scale[k[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: L, labelMapsTo: D, ...k }) => L && L.scale[k[D]] ? L.scale[k[D]] : null) : S.selectAll("rect.highlight-bar").transition().call(
        (L) => l.services.transitions.setupTransition({
          transition: L,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", h).attr("width", Math.max(f - h, 0)).attr("y", ({ highlightEndMapsTo: L, ...D }) => _(D[L])).attr(
        "height",
        ({ highlightStartMapsTo: L, highlightEndMapsTo: D, ...k }) => Math.max(_(k[L]) - _(k[D]), 0)
      ).style("stroke", ({ color: L, labelMapsTo: D, ...k }) => L && L.scale[k[D]] ? L.scale[k[D]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: L, labelMapsTo: D, ...k }) => L && L.scale[k[D]] ? L.scale[k[D]] : null);
    });
  }
}
class C0 extends ch {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: n } = t.detail;
    if (!n || !n.length || !n[0])
      return [];
    const r = this.getOptions(), { cartesianScales: i } = this.services, s = i.getDomainIdentifier(), a = i.isDualAxes(), { groupMapsTo: o } = r.data, l = i.getDomainLabel();
    let c = i.getRangeLabel();
    const u = n[0][s];
    let d;
    if (n.length === 1) {
      const h = n[0], f = i.getRangeIdentifier(h);
      if (a) {
        const v = i.getRangeAxisPosition({
          datum: h,
          groups: [h[o]]
        });
        c = i.getScaleLabel(v);
      }
      const p = h[f];
      d = [
        {
          label: l,
          value: u
        },
        ...Array.isArray(p) && p.length === 2 ? [
          {
            label: "Start",
            value: p[0]
          },
          {
            label: "End",
            value: p[1]
          }
        ] : [
          {
            label: c,
            value: h[f]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (v) => d.push({
          label: v.label,
          value: v.value
        })
      ), d.push({
        label: _t(r, "locale.translations.group") || _t(r, "tooltip.groupLabel"),
        value: h[o],
        color: this.model.getFillColor(h[o]),
        class: this.model.getColorClassName({
          classNameTypes: [st.TOOLTIP],
          dataGroupName: h[o]
        })
      });
    } else if (n.length > 1 && (d = [
      {
        label: l,
        value: u
      }
    ], d = d.concat(
      n.map((h) => {
        const f = h[i.getRangeIdentifier(h)];
        return {
          label: h[o],
          value: Array.isArray(f) && f.length === 2 ? `${f[0]} - ${f[1]}` : f,
          color: this.model.getFillColor(h[o]),
          class: this.model.getColorClassName({
            classNameTypes: [st.TOOLTIP],
            dataGroupName: h[o]
          })
        };
      }).sort((h, f) => f.value - h.value)
    ), !a && x(r, "tooltip", "showTotal") === !0)) {
      const h = i.getRangeIdentifier();
      d.push({
        label: _t(r, "locale.translations.total") || _t(r, "tooltip.totalLabel") || "Total",
        value: n.reduce(
          (f, p) => f + p[h],
          0
        ),
        bold: !0
      });
    }
    return d;
  }
}
class lN extends yt {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 });
    n.html("");
    const { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = x(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let l = ze.minNodePadding;
    s.alluvial.nodePadding > ze.minNodePadding && (l = s.alluvial.nodePadding);
    const c = x(s, "alluvial", "nodeAlignment");
    let u = qv;
    c === ee.LEFT ? u = BR : c === ee.RIGHT && (u = HR);
    const d = GR().nodeId((g) => g.name).nodeWidth(ze.nodeWidth).nodePadding(l).nodeAlign(u).extent([
      [2, 30],
      [r - 2, i]
    ]);
    this.graph = d({
      nodes: s.alluvial.nodes.map((g) => Object.assign({}, g)),
      links: a.map((g) => Object.assign({}, g))
    }), this.graph.nodes = this.graph.nodes.filter((g) => g.value !== 0);
    const h = {};
    this.graph.nodes.forEach((g) => {
      const b = g.x0;
      g.category && (h[b] = g == null ? void 0 : g.category);
    }), n.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(h)).join("g").attr("transform", (g) => `translate(${g}, 0)`).append("text").attr(
      "id",
      (g, b) => this.services.domUtils.generateElementIDString(`alluvial-category-${b}`)
    ).style("font-size", "14px").text((g) => h[g] ? h[g] : "").attr("y", 20).attr("x", (g, b) => {
      const w = this.services.domUtils.generateElementIDString(
        `alluvial-category-${b}`
      ), { width: _ } = N.getSVGElementSize(I(`text#${w}`), {
        useBBox: !0
      });
      let S = 0;
      return g + S >= _ && (S = -_ + 4), S;
    });
    const f = n.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (f.exit().remove(), o) {
      const g = x(this.getOptions(), "color", "scale");
      g && f.enter().append("linearGradient").attr("id", (b) => `${this.gradient_id}-link-${b.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (b) => b.append("stop").attr("offset", "0%").attr("stop-color", (w) => g[w.source.name])
      ).call(
        (b) => b.append("stop").attr("offset", "100%").attr("stop-color", (w) => g[w.target.name])
      ), f.exit().remove();
    }
    f.enter().append("path").classed("link", !0).attr("d", nk()).attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-line-${g.index}`)
    ).attr("class", (g) => s.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [st.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [st.STROKE],
      dataGroupName: g.source.index,
      originalClassName: "link"
    })).style("stroke", (g) => o ? `url(#${this.gradient_id}-link-${g.index})` : this.model.getFillColor(g.source.name, null, {
      ...g,
      source: g.source.name,
      target: g.target.name
    })).attr("stroke-width", (g) => Math.max(1, g.width)).style("stroke-opacity", ze.opacity.default).attr(
      "aria-label",
      (g) => `${g.source.name} → ${g.target.name} (${g.value}${s.alluvial.units ? " " + s.alluvial.units : ""})`
    );
    const p = n.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-${g.index}`)
    ).classed("node-group", !0).attr("transform", (g) => `translate(${g.x0}, ${g.y0})`);
    p.append("rect").classed("node", !0).attr("height", (g) => g.y1 - g.y0).attr("width", (g) => g.x1 - g.x0).attr("fill", "black");
    const v = p.append("g").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${g.index}`)
    ), { code: m, number: y } = x(s, "locale");
    v.append("text").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${g.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((g) => `${g.name} (${y(g.value, m)})`).attr("aria-label", (g) => `${g.name} (${g.value})`), v.append("rect").classed("node-text-bg", !0).attr("width", (g, b) => {
      const w = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${b}`
      ), { width: _ } = N.getSVGElementSize(I(`text#${w}`), {
        useBBox: !0
      });
      return _ + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), v.attr("transform", (g, b) => {
      const w = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${b}`
      ), { width: _ } = N.getSVGElementSize(I(`text#${w}`), {
        useBBox: !0
      }), S = (g.y1 - g.y0) / 2 - 9;
      let L = g.x1 - g.x0;
      return g.x1 >= _ ? L = L - (_ + 16) : L += 4, `translate(${L}, ${S})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), n = this, { number: r, code: i } = x(this.getOptions(), "locale"), s = po((a, o = "mouseover") => {
      const l = n.parent.selectAll("path.link").transition().call(
        (c) => n.services.transitions.setupTransition({
          transition: c,
          name: "alluvial-links-mouse-highlight"
        })
      );
      o === "mouseout" ? (I(a).lower(), l.style("stroke-opacity", ze.opacity.default)) : l.style("stroke-opacity", function() {
        return a === this ? (I(this).raise(), ze.opacity.selected) : ze.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(a, o) {
      const l = I(this);
      s(this, "mouseover"), l.classed("link-hovered", !0);
      const c = getComputedStyle(this).getPropertyValue("stroke");
      n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEOVER, {
        event: a,
        element: l,
        datum: o
      }), n.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: l,
        items: [
          {
            label: o.target.name,
            value: (r(o.value, i) ? `${r(o.value, i)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: c,
            labelIcon: n.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(a, o) {
      n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEMOVE, {
        event: a,
        element: I(this),
        datum: o
      }), n.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, o) {
      n.services.events.dispatchEvent(O.Alluvial.LINE_CLICK, {
        event: a,
        element: I(this),
        datum: o
      });
    }).on("mouseout", function(a, o) {
      const l = I(this);
      s(this, "mouseout"), l.classed("link-hovered", !1), n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEOUT, {
        event: a,
        element: l,
        datum: o
      }), n.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: a,
        hoveredElement: l
      });
    });
  }
  addNodeEventListener() {
    const t = this, n = po((r = [], i = "mouseover") => {
      if (i === "mouseout" || r.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (s) => s.index).order().style("stroke-opacity", ze.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(s) {
        return r.some((a) => a === s.index) ? (I(this).classed("link-hovered", !0).raise(), ze.opacity.selected) : ze.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(r, i) {
      const s = I(this), a = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, i, a), t.traverse({ link: "targetLinks", node: "source" }, i, a), a.length) {
        const o = es(s.attr("transform"));
        if (s.attr("transform", `translate(${o.x - 2}, ${o.y})`), s.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), i.x0 - 2 === 0) {
          const c = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${i.index}`
          ), u = t.parent.select(`g#${c}`), d = es(u.attr("transform"));
          u.attr("transform", `translate(${d.x + 4},${d.y})`);
        }
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${i.index}`
        );
        t.parent.select(`text#${l}`).style("font-weight", "bold"), n(a, "mouseover"), t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEOVER, {
          event: r,
          element: s,
          datum: i
        });
      }
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEMOVE, {
        event: r,
        element: I(this),
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(O.Alluvial.NODE_CLICK, {
        event: r,
        element: I(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = I(this), a = es(s.attr("transform"));
      if (s.classed("node-hovered", !1).attr("transform", `translate(${a.x + 2}, ${a.y})`).select("rect.node").attr("width", ze.nodeWidth), i.x0 - 2 === 0) {
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${i.index}`
        ), c = t.parent.select(`g#${l}`), u = es(c.attr("transform"));
        c.attr("transform", `translate(${u.x - 4},${u.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${i.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), n([], "mouseout"), t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, n, r = []) {
    n[t.link].map((i) => (r.push(i.index), i[t.node])).forEach((i) => this.traverse(t, i, r));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class Re extends yt {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = rt.SVG;
  }
  render(t = !0) {
    const n = x(this.getOptions(), "grid", "x", "enabled"), r = x(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(n, r), !(!n && !r) && (n && (N.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), r && (N.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const n = this.parent, r = this.backdrop.attr("height"), i = this.services.cartesianScales.getMainXScale(), s = hu(i).tickSizeInner(-r).tickSizeOuter(0);
    if (x(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getDomainAxisPosition(), l = x(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = x(this.getOptions(), "grid", "x", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${r})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  drawYGrid(t) {
    const n = this.parent, r = this.backdrop.attr("width"), i = this.services.cartesianScales.getMainYScale(), s = em(i).tickSizeInner(-r).tickSizeOuter(0);
    if (x(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getRangeAxisPosition(), l = x(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = x(this.getOptions(), "grid", "y", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const n = this.parent, r = n.selectAll(".x.grid .tick").nodes().sort((u, d) => Number(En(u).tx) - Number(En(d).tx));
    let i = -1;
    if (!r.length)
      return;
    r.forEach((u) => {
      t[0] >= +En(u).tx && i++;
    });
    const s = i + 1 < r.length ? i + 1 : r.length, a = r[i], o = r[s];
    let l;
    if (!a)
      l = +En(o).tx;
    else if (o)
      l = +En(o).tx - +En(a).tx;
    else {
      const u = n.select("rect.chart-grid-backdrop").node();
      l = N.getSVGElementSize(u).width - +En(a).tx;
    }
    const { threshold: c } = this.getOptions().tooltip.gridline;
    return l * c;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const n = x(this.getOptions, "tooltip", "gridline", "threshold"), r = n || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const i = En(this), s = {
        min: Number(i.tx) - r,
        max: Number(i.tx) + r
      };
      return s.min <= t[0] && t[0] <= s.max;
    });
  }
  drawBackdrop(t, n) {
    const r = this.parent, i = this.services.cartesianScales.getMainXScale(), s = this.services.cartesianScales.getMainYScale(), [a, o] = i.range(), [l, c] = s.range();
    this.backdrop = N.appendOrSelect(r, "svg.chart-grid-backdrop");
    const u = N.appendOrSelect(
      this.backdrop,
      t || n ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(u).attr("x", a).attr("y", c).attr("width", Math.abs(o - a)).attr("height", Math.abs(l - c)).lower(), u.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class A0 extends yt {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = rt.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-area"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? On.opacity.unselected : On.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", On.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions();
    let i = [0, 0];
    const { cartesianScales: s } = this.services, a = s.getOrientation(), o = Nu().curve(this.services.curves.getD3Curve()).defined((_) => {
      const S = s.getRangeIdentifier();
      return _[S] != null;
    }), l = this.model.getGroupedData(this.configs.groups), c = x(r, "bounds"), u = c && l && l.length === 1;
    !u && c && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${l.length}`
    );
    let d = 0;
    const h = (_, S) => {
      x(r, "axes", _, "includeZero") === !1 && S[0] > 0 && S[1] > 0 && (d = S[0]);
    }, f = (_) => u ? s.getBoundedScaledValues(_)[0] : s.getRangeValue(d), p = (_) => u ? s.getBoundedScaledValues(_)[1] : s.getRangeValue(_);
    a === te.VERTICAL ? (i = s.getMainYScale().domain(), h(s.getMainYAxisPosition(), i), o.x((_) => s.getDomainValue(_)).y0((_) => f(_)).y1((_) => p(_))) : (i = s.getMainXScale().domain(), h(s.getMainXAxisPosition(), i), o.x0((_) => f(_)).x1((_) => p(_)).y((_) => s.getDomainValue(_)));
    const v = x(r, "color", "gradient", "enabled"), m = l && l.length === 1 && v;
    l.length > 1 && v && console.error("Gradients can only be enabled when having 1 single dataset");
    const y = n.selectAll("path.area").data(l, (_) => _.name), g = I(this.services.domUtils.getMainContainer());
    if (y.exit().attr("opacity", 0).remove(), !l.length)
      return;
    if (m) {
      const _ = g.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [st.STROKE],
          dataGroupName: l[0].name
        })}`
      ).node();
      let S;
      if (_)
        S = getComputedStyle(_, null).getPropertyValue(
          "stroke"
        );
      else {
        const L = x(this.model.getOptions(), "color", "scale");
        if (L !== null) {
          const D = Object.keys(L);
          S = L[D[0]];
        }
      }
      Nc.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${l[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Nc.getStops(i, S)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const b = this, w = y.enter().append("path");
    m ? w.merge(y).style(
      "fill",
      (_) => `url(#${this.services.domUtils.generateElementIDString(
        `${_.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: _.name,
        originalClassName: "area"
      })
    ).attr("d", (_) => {
      const { data: S } = _;
      return o(S);
    }) : (w.attr("opacity", 0).merge(y).attr("class", "area").attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [st.FILL, st.STROKE],
        dataGroupName: _.name,
        originalClassName: "area"
      })
    ).style("fill", (_) => b.model.getFillColor(_.name, null, _.data)).transition().call(
      (_) => this.services.transitions.setupTransition({
        transition: _,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", u ? 1 : On.opacity.selected).attr("d", (_) => {
      const { data: S } = _;
      return o(S);
    }), u && w.attr("fill-opacity", On.opacity.selected).style("stroke", (_) => b.model.getStrokeColor(_.name, null, _.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class ei extends yt {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-line"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? wn.opacity.unselected : wn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", wn.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), { cartesianScales: r, curves: i } = this.services, s = (f) => r.getDomainValue(f), a = (f) => r.getRangeValue(f), [o, l] = Cn(
      s,
      a,
      r.getOrientation()
    ), c = this.getOptions(), u = Ns().x(o).y(l).curve(i.getD3Curve()).defined((f) => {
      const p = r.getRangeIdentifier(f);
      return f[p] != null;
    });
    let d = [];
    if (this.configs.stacked) {
      const f = Object.keys(c.axes).some((v) => c.axes[v].percentage), { groupMapsTo: p } = c.data;
      d = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: f
      }).map((v) => {
        const m = this.services.cartesianScales.getDomainIdentifier(v), y = this.services.cartesianScales.getRangeIdentifier(v);
        return {
          name: x(v, 0, p),
          data: v.map((g) => ({
            [m]: g.data.sharedStackKey,
            [p]: g[p],
            [y]: g[1]
          })),
          hidden: !wD(v, (g) => g[0] !== g[1])
        };
      });
    } else
      d = this.model.getGroupedData(this.configs.groups);
    const h = n.selectAll("path.line").data(d, (f) => f.name);
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").classed("line", !0).attr("opacity", 0).merge(h).data(d, (f) => f.name).attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        dataGroupName: f.name,
        originalClassName: "line"
      })
    ).style("stroke", (f) => this.model.getStrokeColor(f.name, null, f.data)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (f) => {
      const { data: p } = f;
      return p.map((v) => {
        const m = this.services.cartesianScales.getRangeIdentifier(v);
        return v[m];
      }).join(",");
    }).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (f) => f.hidden ? 0 : 1).attr("d", (f) => {
      const { data: p } = f;
      return u(p);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const dp = 5;
function cN(e, t) {
  return e > t - dp && e < t + dp;
}
class Qn extends yt {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = rt.SVG, this.isXGridEnabled = x(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = x(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = x(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), n && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !n && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.services.cartesianScales.getOrientation(), a = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [l, c] = o.range(), u = s === te.HORIZONTAL ? r : n, d = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), h = N.appendOrSelect(d, "line.ruler-line"), f = i.selectAll("[role=graphics-symbol]"), p = a.map((m) => ({
      domainValue: this.services.cartesianScales.getDomainValue(m),
      originalData: m
    })).filter((m) => cN(m.domainValue, u));
    if (this.pointsWithinLine && p.length === this.pointsWithinLine.length && p.map((m) => m.domainValue).join() === this.pointsWithinLine.map((m) => m.domainValue).join())
      return this.pointsWithinLine = p, this.services.events.dispatchEvent(O.Tooltip.MOVE, {
        mousePosition: [n, r]
      });
    this.pointsWithinLine = p;
    const v = this.pointsWithinLine.reduce((m, y) => {
      if (m.length === 0)
        return m.push(y), m;
      const g = m[0].domainValue, b = Math.abs(u - y.domainValue), w = Math.abs(u - g);
      return b > w || (b < w ? m = [y] : m.push(y)), m;
    }, []);
    if (v.length > 0) {
      const m = v.map((w) => w.originalData).filter((w) => {
        const _ = this.services.cartesianScales.getRangeIdentifier(w);
        return w[_] != null;
      }), y = v.map(
        (w) => w.domainValue
      ), g = f.filter((w) => {
        const _ = this.services.cartesianScales.getDomainValue(w);
        return y.includes(_);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !f0(this.elementsToHighlight, g) && this.hideRuler(), g.dispatch("mouseover"), this.elementsToHighlight = g, this.services.events.dispatchEvent(O.Tooltip.SHOW, {
        mousePosition: [n, r],
        hoveredElement: h,
        data: this.formatTooltipData(m)
      }), d.attr("opacity", 1);
      const b = v[0];
      s === "horizontal" ? h.attr("x1", c).attr("x2", l).attr("y1", b.domainValue).attr("y2", b.domainValue) : h.attr("y1", c).attr("y2", l).attr("x1", b.domainValue).attr("x2", b.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, n = N.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(O.Tooltip.HIDE), n.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, n = this.services.domUtils.getHolder(), r = this.model.getDisplayData();
    let i = function(s) {
      const a = vr(s, t.parent.node());
      t.showRuler(s, a);
    };
    if (r.length > 100) {
      const s = r.length % 50 * 12.5;
      i = N$(
        function(a) {
          const { mousePosition: o } = this;
          t.showRuler(a, o);
        },
        s,
        n
      );
    }
    this.backdrop.on("mousemove mouseover", i).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = N.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
}
class hn extends yt {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = rt.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (i) => {
          var s;
          return (s = this.services.transitions) == null ? void 0 : s.setupTransition({
            transition: i,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t)
      throw new Error("Services events are undefined.");
    t.addEventListener(
      O.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: n } = this.configs;
    n && (t.addEventListener(O.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(O.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Services cartesianScales are undefined.");
    const r = n.getDomainIdentifier(t), i = this.model.get("zoomDomain");
    return i !== void 0 ? t.filter(
      (s) => s[r].getTime() >= i[0].getTime() && s[r].getTime() <= i[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: n } = this.configs;
    let r;
    if (n) {
      const i = Object.keys(t.axes).some((s) => t.axes[s].percentage);
      r = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: i
      });
    } else {
      const { cartesianScales: i } = this.services;
      if (!i)
        throw new Error("Services cartesianScales are undefined.");
      r = this.model.getDisplayData(this.configs.groups).filter((s) => {
        const a = i.getRangeIdentifier(s);
        return s[a] !== void 0 && s[a] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(r);
  }
  render(t) {
    if (!(x(this.getOptions(), "points", "enabled") || x(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services;
    if (!s)
      throw new Error("Services cartesianScales are undefined.");
    const a = s.getDomainIdentifier(), o = n.selectAll("circle.dot").data(
      this.getScatterData(),
      (c) => `${c[i]}-${c[a]}`
    );
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(o);
    this.styleCircles(l, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: n } = this.configs;
    if (!n)
      return !1;
    const { cartesianScales: r } = this.services;
    if (!r)
      throw new Error("Cartesian scales service is undefined");
    const i = r.getOrientation(), [s, a] = Cn(
      r.getHighestDomainThreshold(),
      r.getHighestRangeThreshold(),
      i
    ), [o, l] = Cn(
      (d) => r.getDomainValue(d),
      (d) => r.getRangeValue(d),
      i
    ), c = o(t), u = l(t);
    return a && s ? u <= a.scaleValue && c >= s.scaleValue : a ? u <= a.scaleValue : s ? c >= s.scaleValue : !1;
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { filled: i, fillOpacity: s } = r.points, { cartesianScales: a } = this.services;
    if (!a)
      throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = r.data, l = (f) => a.getDomainValue(f), c = (f) => a.getRangeValue(f), [u, d] = Cn(
      l,
      c,
      a.getOrientation()
    ), { fadeInOnChartHolderMouseover: h } = this.configs;
    t.raise().classed("dot", !0).attr("class", (f) => {
      const p = a.getDomainIdentifier(f), v = this.model.getIsFilled(f[o], f[p], f, i) ? [st.FILL, st.STROKE] : [st.STROKE];
      return this.model.getColorClassName({
        classNameTypes: v,
        dataGroupName: f[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (f) => this.isDatapointThresholdAnomaly(f)).classed("filled", (f) => {
      const p = a.getDomainIdentifier(f);
      return this.model.getIsFilled(f[o], f[p], f, i);
    }).classed("unfilled", (f) => {
      const p = a.getDomainIdentifier(f);
      return !this.model.getIsFilled(f[o], f[p], f, i);
    }).transition().call(
      (f) => {
        var p;
        return (p = this.services.transitions) == null ? void 0 : p.setupTransition({
          transition: f,
          name: "scatter-update-enter",
          animate: n
        });
      }
    ).attr("cx", u).attr("cy", d).attr("r", r.points.radius).style("fill", (f) => {
      const p = a.getDomainIdentifier(f);
      if (this.model.getIsFilled(f[o], f[p], f, i))
        return this.model.getFillColor(f[o], f[p], f);
    }).style("stroke", (f) => {
      const p = a.getDomainIdentifier(f);
      return this.model.getStrokeColor(f[o], f[p], f);
    }).attr("fill-opacity", i ? s : 1).attr("opacity", h ? 0 : 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (f) => {
      const p = a.getRangeIdentifier(f);
      return f[p];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: n } = t.getOptions().data;
    if (!this.parent)
      throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(r, i) {
      var s, a;
      const o = I(this);
      o.classed("hovered", !0).attr(
        "class",
        (l) => t.model.getColorClassName({
          classNameTypes: [st.FILL],
          dataGroupName: l[n],
          originalClassName: o.attr("class")
        })
      ).style("fill", (l) => {
        var c;
        const u = (c = t.services.cartesianScales) == null ? void 0 : c.getDomainIdentifier(l);
        return t.model.getFillColor(l[n], l[u], l);
      }).classed("unfilled", !1), (s = t.services.events) == null || s.dispatchEvent(O.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        data: [i],
        additionalItems: t.getTooltipAdditionalItems(i)
      }), (a = t.services.events) == null || a.dispatchEvent(O.Scatter.SCATTER_MOUSEOVER, {
        event: r,
        element: o,
        datum: i
      });
    }).on("mousemove", function(r, i) {
      var s, a;
      const o = I(this);
      (s = t.services.events) == null || s.dispatchEvent(O.Scatter.SCATTER_MOUSEMOVE, {
        event: r,
        element: o,
        datum: i
      }), (a = t.services.events) == null || a.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      var s;
      (s = t.services.events) == null || s.dispatchEvent(O.Scatter.SCATTER_CLICK, {
        event: r,
        element: I(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      var s, a, o;
      const l = I(this);
      if (l.classed("hovered", !1), !t.configs.filled) {
        const { filled: c } = t.getOptions().points, u = (s = t.services.cartesianScales) == null ? void 0 : s.getDomainIdentifier(i), d = t.model.getIsFilled(
          i[n],
          i[u],
          i,
          c
        );
        l.classed("unfilled", !d).style("fill", (h) => d || c ? t.model.getFillColor(h[n], h[u], h) : null);
      }
      (a = t.services.events) == null || a.dispatchEvent(O.Scatter.SCATTER_MOUSEOUT, {
        event: r,
        element: l,
        datum: i
      }), (o = t.services.events) == null || o.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  destroy() {
    var t;
    (t = this.parent) == null || t.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: n } = this.services;
    if (!n)
      throw new Error("Services events undefined");
    n.removeEventListener(
      O.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), n.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), n.removeEventListener(O.Chart.MOUSEOVER, this.handleChartHolderOnHover), n.removeEventListener(O.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class $0 extends yt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "axes", this.renderType = rt.SVG, this.truncation = {
      [F.LEFT]: !1,
      [F.RIGHT]: !1,
      [F.TOP]: !1,
      [F.BOTTOM]: !1
    }, r && (this.configs = r), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: n } = this.configs, r = this.getOptions(), i = x(r, "axes", n, "visible"), s = this.getComponentContainer(), { width: a, height: o } = N.getSVGElementSize(s, {
      useAttrs: !0
    }), l = N.appendOrSelect(s, `g.axis.${n}`);
    let c, u;
    if (n === F.BOTTOM || n === F.TOP ? (c = this.configs.axes[F.LEFT] ? this.margins.left : 0, u = this.configs.axes[F.RIGHT] ? a - this.margins.right : a) : (c = o - this.margins.bottom, u = this.margins.top), !this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const d = this.services.cartesianScales.getScaleByPosition(n);
    this.scaleType === et.LABELS || this.scaleType === et.LABELS_RATIO ? d.rangeRound([c, u]) : d.range([c, u]);
    let h;
    switch (n) {
      case F.LEFT:
        h = em;
        break;
      case F.BOTTOM:
        h = hu;
        break;
      case F.RIGHT:
        h = Ay;
        break;
      case F.TOP:
        h = Cy;
        break;
    }
    l.attr("aria-label", `${n} axis`);
    const f = !l.select("g.ticks").empty();
    let p = N.appendOrSelect(l, "g.ticks");
    f || (p.attr("role", `${ht.GRAPHICS_OBJECT} ${ht.GROUP}`), p.attr("aria-label", `${n} ticks`));
    const v = N.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${n} ticks`), m = x(r, "axes", n), y = this.scaleType === et.TIME || m.scaleType === et.TIME, g = n === F.LEFT || n === F.RIGHT, b = this.model.get("zoomDomain");
    if (b && y && !g && d.domain(b), !i) {
      p.attr("aria-hidden", !0);
      return;
    }
    const w = x(m, "scaleType"), _ = x(r, "data", "loading"), S = x(m, "ticks", "number"), L = x(m, "ticks", "values"), D = x(m, "truncation", "type"), k = x(m, "truncation", "threshold"), R = x(m, "truncation", "numCharacter"), M = S !== null, V = x(r, "timeScale"), P = N.appendOrSelect(v, "g.tick"), H = N.appendOrSelect(P, "text").text("0"), E = N.getSVGElementSize(H.node(), {
      useBBox: !0
    }).height;
    P.remove();
    const A = this.scaleType || m.scaleType || et.LINEAR, $ = h(d).tickSizeOuter(0);
    if (d.ticks) {
      let Z;
      if (M ? Z = S : (Z = Xn.ticks.number, g && (Z = this.getNumberOfFittingTicks(
        o,
        E,
        Xn.ticks.verticalSpaceRatio
      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (Z = 0), $.ticks(Z), y)
        if (!d.ticks(Z).length)
          $.tickValues([]);
        else {
          const tt = x(r, "timeScale", "addSpaceOnEdges"), ft = x(r, "axes", n, "domain"), q = d.copy();
          tt && !ft && q.nice(Z);
          const J = q.ticks(Z);
          tt && J.length > 2 && !ft && (J.splice(J.length - 1, 1), J.splice(0, 1)), $.tickValues(J);
        }
    }
    let U;
    const B = x(m, "ticks", "formatter"), { code: W, number: K } = x(r, "locale");
    if (y) {
      const Z = kc(
        $.tickValues(),
        x(r, "timeScale", "timeInterval")
      );
      B === null ? U = (tt, ft) => Rc(tt, ft, $.tickValues(), Z, V, r.locale) : U = (tt, ft) => {
        const q = Rc(
          tt,
          ft,
          $.tickValues(),
          Z,
          V,
          r.locale
        );
        return B(tt, ft, q);
      };
    } else
      B === null ? A === et.LINEAR && (U = (Z) => K(Z, W)) : U = B;
    $.tickFormat(U);
    const [Q, dt] = this.services.cartesianScales.getScaleByPosition(n).domain();
    let it;
    if (L) {
      if (y)
        L.forEach((Z, tt) => {
          Z.getTime === void 0 && (L[tt] = new Date(Z));
        }), it = L.filter((Z) => {
          const tt = Z.getTime();
          return tt >= new Date(Q).getTime() && tt <= new Date(dt).getTime();
        });
      else if (w === et.LABELS) {
        const Z = this.services.cartesianScales.getScaleByPosition(n).domain();
        it = L.filter((tt) => Z.includes(tt));
      } else
        it = L.filter(
          (Z) => Z >= Q && Z <= dt
        );
      $.tickValues(it);
    }
    switch (n) {
      case F.LEFT:
        p.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case F.BOTTOM:
        p.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case F.RIGHT:
        p.attr("transform", `translate(${a - this.margins.right}, 0)`);
        break;
      case F.TOP:
        p.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const pt = this.model.isDataEmpty();
    if (m.title) {
      const Z = N.appendOrSelect(l, "text.axis-title").html(
        pt || _ ? "" : un(m.title)
      ), tt = x(m, "titleOrientation");
      let ft;
      switch (n) {
        case F.LEFT:
          tt === ql.RIGHT ? Z.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : Z.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case F.BOTTOM:
          Z.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${o + 4})`
          ).style("text-anchor", "middle");
          break;
        case F.RIGHT:
          tt === ql.LEFT ? Z.attr("transform", "rotate(-90)").attr("y", a).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : Z.attr("transform", "rotate(90)").attr("y", -a).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case F.TOP:
          ft = N.getSVGElementSize(Z, {
            useBBox: !0
          }).height, Z.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${ft / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (y) {
      const Z = kc(
        $.tickValues(),
        x(r, "timeScale", "timeInterval")
      ), tt = V.showDayName, ft = p;
      t && (p = p.transition().call(
        (q) => this.services.transitions.setupTransition({
          transition: q,
          name: "axis-update",
          animate: t
        })
      )), p = p.call($), ft.selectAll(".tick").data($.tickValues(), d).order().select("text").style("font-weight", (q, J) => Dv(q, J, $.tickValues(), Z, tt) ? "bold" : "normal");
    } else
      !t || !f ? p = p.call($) : p = p.transition().call(
        (Z) => this.services.transitions.setupTransition({
          transition: Z,
          name: "axis-update",
          animate: t
        })
      ).call($);
    if (v.call($), n === F.BOTTOM || n === F.TOP) {
      let Z = !1;
      const tt = x(m, "ticks", "rotation");
      if (tt === ya.ALWAYS)
        Z = !0;
      else if (tt === ya.NEVER)
        Z = !1;
      else if (!tt || tt === ya.AUTO)
        if (d.step)
          Z = v.selectAll("g.tick text").nodes().some(
            (ft) => N.getSVGElementSize(ft, {
              useBBox: !0
            }).width >= d.step()
          );
        else {
          Z = !1;
          const ft = v.append("text").text("A"), q = N.getSVGElementSize(ft.node(), {
            useBBox: !0
          }).width;
          let J;
          v.selectAll("g.tick").each(function() {
            const ot = I(this), G = parseFloat(x(En(this), "tx"));
            G !== null && J + ot.text().length * q * 0.8 >= G && (Z = !0), J = G;
          }), ft.remove();
        }
      Z ? (M || ($.ticks(
        this.getNumberOfFittingTicks(a, E, Xn.ticks.horizontalSpaceRatio)
      ), v.call($), p.call($)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", n === F.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (_ ? l.attr("opacity", 0) : l.attr("opacity", 1), p.selectAll("g.tick").attr("aria-label", (Z) => Z), v.selectAll("g.tick").attr("aria-label", (Z) => Z), D !== qe.NONE && w === et.LABELS && !L) {
      const Z = this.services.cartesianScales.getScaleDomain(n);
      if (Z.length > 0) {
        const tt = s.select(`g.axis.${n} g.ticks g.tick`).html();
        l.selectAll("g.ticks g.tick").html(tt);
        const ft = this;
        l.selectAll("g.tick text").data(Z).text(function(q) {
          return q.length > k ? (ft.truncation[n] = !0, As(q, D, R)) : q;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(Z).text(function(q) {
          return q.length > k ? As(q, D, R) : q;
        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data(Z);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = x(i, "axes", n), a = x(s, "scaleType"), o = x(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick text").on("mouseover", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: c,
        hoveredElement: I(this),
        content: u
      });
    }).on("mousemove", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && u.length > o && l.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_CLICK, {
        event: c,
        element: I(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: I(this),
        datum: u
      }), a === et.LABELS && l.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, n, r) {
    const i = Math.floor(t / (n * r));
    return d0(i, 2, Xn.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class uN extends $0 {
  constructor(t, n, r) {
    super(t, n, r);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const n = this.configs.position, r = this.getComponentContainer(), i = N.appendOrSelect(r, `g.axis.${n}`), s = this;
    i.selectAll("g.tick").each(function(a, o) {
      const l = I(this);
      l.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const c = l.select("text"), { width: u, height: d } = N.getSVGElementSize(c, {
        useBBox: !0
      }), h = N.appendOrSelect(l, "rect.axis-holder");
      let f = 0, p = 0;
      switch (n) {
        case F.LEFT:
          f = -u + Number(c.attr("x")), p = -(d / 2);
          break;
        case F.RIGHT:
          f = Math.abs(Number(c.attr("x"))), p = -(d / 2);
          break;
        case F.TOP:
          f = -(u / 2), p = -d + Number(c.attr("y")) / 2, s.truncation[n] && (f = 0, h.attr("transform", "rotate(-45)"));
          break;
        case F.BOTTOM:
          f = -(u / 2), p = d / 2 - 2, s.truncation[n] && (f = -u, h.attr("transform", "rotate(-45)"));
          break;
      }
      h.attr("x", f - Xn.hover.rectanglePadding).attr("y", p).attr("width", u + Xn.hover.rectanglePadding * 2).attr("height", d).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = N.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = x(i, "axes", n), a = x(s, "scaleType"), o = x(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick.tick-hover").on("mouseover", function(c) {
      const u = I(this).select("text"), d = u.datum();
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: u,
        datum: d
      }), a === et.LABELS && d.length > o && l.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: c,
        element: u,
        datum: d
      });
    }).on("mousemove", function(c) {
      const u = I(this).select("text"), d = u.datum();
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: u,
        datum: d
      }), l.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_CLICK, {
        event: c,
        element: I(this).select("text"),
        datum: I(this).select("text").datum()
      });
    }).on("mouseout", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: I(this).select("text"),
        datum: I(this).select("text").datum()
      }), a === et.LABELS && l.services.events.dispatchEvent(O.Tooltip.HIDE);
    }).on("focus", function(c) {
      const u = { clientX: 0, clientY: 0 };
      if (c.target) {
        c.target.focus();
        const d = c.target.getBoundingClientRect();
        u.clientX = d.x, u.clientY = d.y;
      }
      l.services.events.dispatchEvent(O.Axis.LABEL_FOCUS, {
        event: { ...c, ...u },
        element: I(this),
        datum: I(this).select("text").datum()
      });
    }).on("blur", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_BLUR, {
        event: c,
        element: I(this),
        datum: I(this).select("text").datum()
      });
    }).on("keydown", function(c) {
      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(O.Tooltip.HIDE), l.services.events.dispatchEvent(O.Axis.LABEL_BLUR, {
        event: c,
        element: I(this),
        datum: I(this).select("text").datum()
      })), n === F.LEFT || n === F.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, n) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, n) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    N.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class Ee extends yt {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = rt.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const n = {}, r = Object.keys(F), i = x(this.getOptions(), "axes");
    r.forEach((a) => {
      i[F[a]] && (n[F[a]] = !0);
    }), this.configs.axes = n, r.forEach((a) => {
      const o = F[a];
      if (this.configs.axes[o] && !this.children[o]) {
        const l = {
          position: o,
          axes: this.configs.axes,
          margins: this.margins
        }, c = this.model.axisFlavor === So.DEFAULT ? new $0(this.model, this.services, l) : new uN(this.model, this.services, l);
        c.setModel(this.model), c.setServices(this.services), c.setParent(this.parent), this.children[o] = c;
      }
    }), Object.keys(this.children).forEach((a) => {
      this.children[a].render(t);
    });
    const s = {};
    Object.keys(this.children).forEach((a) => {
      const o = this.children[a], l = o.configs.position, c = o.getInvisibleAxisRef(), { width: u, height: d } = N.getSVGElementSize(c, { useBBox: !0 });
      let h;
      switch (o.getTitleRef().empty() ? h = 0 : (h = N.getSVGElementSize(o.getTitleRef(), {
        useBBox: !0
      }).height, (l === F.LEFT || l === F.RIGHT) && (h += 5)), l) {
        case F.TOP:
          s.top = d + h;
          break;
        case F.BOTTOM:
          s.bottom = d + h;
          break;
        case F.LEFT:
          s.left = u + h;
          break;
        case F.RIGHT:
          s.right = u + h;
          break;
      }
    }), this.services.events.dispatchEvent(O.Axis.RENDER_COMPLETE), Object.keys(s).some(
      (a) => this.margins[a] !== s[a]
    ) && (this.margins = Object.assign(this.margins, s), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(O.ZoomBar.UPDATE), Object.keys(this.children).forEach((a) => {
      const o = this.children[a];
      o.margins = this.margins;
    }), this.render(!0));
  }
}
class pe extends yt {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = x(this.getOptions(), "data", "loading");
    n ? this.renderSkeleton(n) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === Jt.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === Jt.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === Jt.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === Jt.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const n = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), n === te.VERTICAL && this.drawYGrid(t), n === te.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const n = this.computeOuterRadius();
    this.drawRing(n, 0, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const n = this.computeOuterRadius(), r = this.computeInnerRadius();
    this.drawRing(n, r, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), n = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Ke().domain([0, 1]).range(t), this.yScale = Ke().domain([0, 1]).range(n);
  }
  drawBackdrop(t) {
    const n = this.parent, { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    });
    this.backdrop = N.appendOrSelect(n, "svg.chart-skeleton.DAII").attr("width", r).attr("height", i);
    const s = N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    s.attr("width", "100%").attr("height", "100%");
    const [a] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(s).attr("x", a).attr("y", o), s.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const n = +this.backdrop.attr("width"), r = x(this.getOptions(), "grid", "x", "numberOfTicks"), i = this.xScale.ticks(r).map((o) => o * n), s = N.appendOrSelect(this.backdrop, "g.x.skeleton"), a = s.selectAll("line").data(i);
    a.enter().append("line").merge(a).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const n = +this.backdrop.attr("height"), r = this.backdrop.attr("width"), i = x(this.getOptions(), "grid", "y", "numberOfTicks"), s = this.xScale.ticks(i).map((l) => l * n), a = N.appendOrSelect(this.backdrop, "g.y.skeleton"), o = a.selectAll("line").data(s);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", r).attr("y1", (l) => l).attr("y2", (l) => l), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, n, r = !0) {
    const i = this.parent, { width: s, height: a } = N.getSVGElementSize(i, {
      useAttrs: !0
    }), o = N.appendOrSelect(i, "svg.chart-skeleton").attr("width", s).attr("height", a), l = n === 0 ? "pie" : "donut", c = x(this.getOptions(), l, "alignment");
    N.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", s).attr("height", a).attr("fill", "none");
    const u = ws().innerRadius(n).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(Bt.radiusOffset), h = t + (Math.min(s, a) - t * 2) / 2, f = N.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${h})`).attr("d", u).classed("shimmer-effect-areas", r).classed("empty-state-areas", !r).style(
      "fill",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let p = t + Bt.xOffset;
    c === ee.CENTER ? p = s / 2 : c === ee.RIGHT && (p = s - t - Bt.xOffset);
    const v = t + Bt.yOffset;
    f.attr("transform", `translate(${p}, ${v})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: n } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, n) / 2 + Bt.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const n = "stop-bg-shimmer", r = "stop-shimmer", i = this.parent.select(".chart-skeleton"), { width: s } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), a = 0, o = s, l = N.appendOrSelect(i, "defs").lower(), c = N.appendOrSelect(l, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", a - 3 * 0.2 * s).attr("x2", o).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `
			<stop class="${n}" offset="${a}"></stop>
			<stop class="${r}" offset="${a + 0.2}"></stop>
			<stop class="${n}" offset="${a + 2 * 0.2}"></stop>
		`;
    c.html(u), d();
    function d() {
      c.attr("gradientTransform", `translate(${a - 3 * 0.2 * s}, 0)`).transition().duration(2e3).delay(1e3).ease(qb).attr("gradientTransform", `translate(${o + 3 * 0.2 * s}, 0)`).on("end", d);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class hN extends yt {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = rt.SVG;
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getDataGroupNames(), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [l, c] = a.range(), [u, d] = o.range(), h = c - l, f = u - d;
    if (h === 0)
      return;
    const { cartesianScales: p } = this.services, v = p.getOrientation(), m = v === te.VERTICAL, [y, g] = Cn(
      (M) => this.services.cartesianScales.getDomainValue(M),
      (M) => this.services.cartesianScales.getRangeValue(M),
      v
    ), b = Math.floor((m ? h : f) / s.length), w = Math.min(b / 2, 16), _ = this.model.getBoxplotData(), S = n.selectAll(".box-group").data(_);
    S.exit().remove();
    const L = S.enter().append("g").attr("class", "box-group"), D = S.merge(L);
    L.append("path").merge(S.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", De.strokeWidth.default).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]), P = V, H = p.getRangeValue(M.whiskers.min), E = p.getRangeValue(M.quartiles.q_25);
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    }), L.append("path").merge(S.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", De.strokeWidth.default).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]), P = V, H = p.getRangeValue(M.whiskers.max), E = p.getRangeValue(M.quartiles.q_75);
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    }), L.append("path").merge(S.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.FILL, st.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", De.box.opacity.default).attr("stroke-width", De.strokeWidth.default).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (M) => M[i]).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]) - w / 2, P = V + w, H = p.getRangeValue(
        Math[m ? "max" : "min"](M.quartiles.q_75, M.quartiles.q_25)
      ), E = H + Math.abs(
        p.getRangeValue(M.quartiles.q_75) - p.getRangeValue(M.quartiles.q_25)
      );
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    }), L.append("path").merge(S.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (M) => {
      const V = p.getDomainValue(M[i]) - w / 2, P = V + w, H = p.getRangeValue(M.whiskers.min), E = p.getRangeValue(M.whiskers.max);
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    }), L.append("path").merge(S.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", De.strokeWidth.thicker).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]) - w / 4, P = V + w / 2, H = p.getRangeValue(M.whiskers.min), E = p.getRangeValue(M.whiskers.min);
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    }), L.append("path").merge(S.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]) - w / 2, P = V + w, H = p.getRangeValue(M.quartiles.q_50);
      return de({ x0: V, x1: P, y0: H, y1: H }, v);
    }), L.append("path").merge(S.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", De.strokeWidth.thicker).attr("fill", "none").transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (M) => {
      const V = p.getDomainValue(M[i]) - w / 4, P = V + w / 2, H = p.getRangeValue(M.whiskers.max), E = p.getRangeValue(M.whiskers.max);
      return de({ x0: V, x1: P, y0: H, y1: E }, v);
    });
    const k = D.selectAll("circle.outlier").data(
      (M) => M.outliers.map((V) => ({
        min: M.whiskers.min,
        max: M.whiskers.max,
        [i]: M[i],
        value: V
      }))
    );
    k.exit().remove();
    const R = k.enter().append("circle");
    k.merge(R).attr("r", De.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [st.FILL, st.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", De.circle.opacity.default).attr("cx", y).transition().call(
      (M) => this.services.transitions.setupTransition({
        transition: M,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", g), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(i, s) {
      const a = I(this);
      I(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", De.box.opacity.hovered), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: x(n, "locale", "translations", "group") || x(n, "tooltip", "groupLabel") || "Group",
            value: s[r],
            class: t.model.getColorClassName({
              classNameTypes: [st.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: s.whiskers.min
          },
          {
            label: "Q1",
            value: s.quartiles.q_25
          },
          {
            label: "Median",
            value: s.quartiles.q_50
          },
          {
            label: "Q3",
            value: s.quartiles.q_75
          },
          {
            label: "Maximum",
            value: s.whiskers.max
          },
          {
            label: "IQR",
            value: s.quartiles.q_75 - s.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      });
    }).on("mousemove", function(i, s) {
      const a = I(this);
      t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      t.services.events.dispatchEvent(O.Boxplot.BOX_CLICK, {
        event: i,
        element: I(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = I(this);
      I(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", De.box.opacity.default), t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  addCircleEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(s, a) {
      const o = I(this);
      o.classed("hovered", !0).attr("fill-opacity", De.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: x(n, "locale", "translations", "group") || x(n, "tooltip", "groupLabel") || "Group",
            value: a[r],
            class: t.model.getColorClassName({
              classNameTypes: [st.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: a[i]
          }
        ]
      }), t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const o = I(this);
      t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(O.Boxplot.OUTLIER_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      o.classed("hovered", !1).attr("fill-opacity", De.circle.opacity.default), t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class yi extends yt {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = rt.SVG;
  }
  render(t) {
    const n = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), r = this.services.cartesianScales.getScaleByPosition(n), [i, s] = r.domain(), a = i > 0 && s < 0 || i < 0 && s > 0, o = this.getComponentContainer();
    if (!a) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [l, c] = this.services.cartesianScales.getDomainScale().range();
    let u = +r(0) + 0.5;
    u || (u = r.range()[0]);
    const d = Ov(
      {
        x0: l,
        x1: c,
        y0: u,
        y1: u
      },
      this.services.cartesianScales.getOrientation()
    );
    N.appendOrSelect(o, "line.domain").transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);
  }
}
class dN extends hn {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = rt.SVG;
  }
  getRadiusScale(t) {
    const n = this.getOptions(), { radiusMapsTo: r } = n.bubble, i = t.data(), s = i.map((c) => c[r]).filter((c) => c), a = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = s.length > 0, l = o ? Ye(s) : [1, 1];
    return Ke().domain(l).range(o ? n.bubble.radiusRange(a, i) : [4, 4]);
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { radiusMapsTo: i } = r.bubble, s = this.getRadiusScale(t), { groupMapsTo: a } = r.data, { cartesianScales: o } = this.services, l = (h) => o.getDomainValue(h), c = (h) => o.getRangeValue(h), [u, d] = Cn(
      l,
      c,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (h) => {
      const f = o.getRangeIdentifier(h);
      return h[f];
    }).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "bubble-update-enter",
        animate: n
      })
    ).attr("cx", u).attr("cy", d).attr("r", (h) => s(h[i] || 1)).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [st.FILL, st.STROKE],
        dataGroupName: h[a],
        originalClassName: "dot"
      })
    ).style("fill", (h) => {
      const f = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getFillColor(h[a], h[f], h);
    }).style("stroke", (h) => {
      const f = this.services.cartesianScales.getDomainIdentifier(h);
      return this.model.getStrokeColor(h[a], h[f], h);
    }).attr("fill-opacity", r.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const n = x(this.getOptions(), "bubble");
    return [
      {
        label: x(n, "radiusLabel"),
        value: t[x(n, "radiusMapsTo")]
      }
    ];
  }
}
class fN extends yt {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [l, c] = a.range(), [, u] = a.domain(), d = () => {
      const v = [];
      s.forEach((y) => {
        y.ranges ? y.ranges.forEach((g, b) => {
          g != null && g < u && v.push({
            datum: y,
            value: g,
            order: b + 1
          });
        }) : v.push({
          datum: y,
          order: 1
        });
      });
      const m = N.appendOrSelect(i, "g.range-boxes").selectAll("path.range-box").data(v, (y) => `${y[r]}-${y.order}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (y) => `range-box order-${y.order}`).transition().call(
        (y) => this.services.transitions.setupTransition({
          transition: y,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (y) => {
        let g, b, w, _;
        return y.order === 1 ? (g = this.services.cartesianScales.getDomainValue(y.datum) - 16 / 2, b = g + 16, w = c - 2, _ = l + 1) : (g = this.services.cartesianScales.getDomainValue(y.datum) - 16 / 2, b = g + 16, w = this.services.cartesianScales.getRangeValue(y.value), _ = c), de(
          { x0: g, x1: b, y0: w, y1: _ },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, h = () => {
      const v = N.appendOrSelect(i, "g.bars").selectAll("path.bar").data(s, (m) => m[r]);
      v.exit().attr("opacity", 0).remove(), v.enter().append("path").attr("opacity", 0).merge(v).classed("bar", !0).transition().call(
        (m) => this.services.transitions.setupTransition({
          transition: m,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (m) => this.model.getColorClassName({
          classNameTypes: [st.FILL],
          dataGroupName: m[r],
          originalClassName: "bar"
        })
      ).style("fill", (m) => {
        const y = this.services.cartesianScales.getDomainIdentifier(m);
        return this.model.getFillColor(m[r], m[y], m);
      }).attr("d", (m) => {
        const y = this.services.cartesianScales.getDomainValue(m) - 4, g = y + 8, b = this.services.cartesianScales.getRangeValue(0) + 1, w = this.services.cartesianScales.getRangeValue(m);
        return de(
          { x0: y, x1: g, y0: b, y1: w },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (m) => m.value);
    }, f = () => {
      const v = N.appendOrSelect(i, "g.markers").selectAll("path.marker").data(
        s.filter((m) => x(m, "marker") !== null),
        (m) => m[r]
      );
      v.exit().attr("opacity", 0).remove(), v.enter().append("path").attr("opacity", 0).merge(v).classed("marker", !0).transition().call(
        (m) => this.services.transitions.setupTransition({
          transition: m,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (m) => {
        const y = this.services.cartesianScales.getDomainValue(m) - 12, g = y + 24, b = this.services.cartesianScales.getRangeValue(m.marker);
        return de(
          { x0: y, x1: g, y0: b, y1: b },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, p = () => {
      let v = [];
      s.filter((y) => x(y, "marker") !== null).forEach((y) => {
        const g = y.marker, b = y[o];
        v = v.concat([
          { datum: y, value: g * 0.25, barValue: b },
          { datum: y, value: g * 0.5, barValue: b },
          { datum: y, value: g * 0.75, barValue: b }
        ]);
      });
      const m = N.appendOrSelect(i, "g.quartiles").selectAll("path.quartile").data(v, (y) => y[r]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (y) => `quartile ${y.value <= y.barValue ? "over-bar" : ""}`).transition().call(
        (y) => this.services.transitions.setupTransition({
          transition: y,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: y, value: g }) => {
        let b = 4;
        y.ranges && y.ranges.indexOf(g) !== -1 && (b = 8);
        const w = this.services.cartesianScales.getDomainValue(y) - b / 2, _ = w + b, S = this.services.cartesianScales.getRangeValue(g);
        return de(
          { x0: w, x1: _, y0: S, y1: S },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    d(), h(), f(), p(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), { code: s, number: a } = x(n, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(o, l) {
      const c = I(this);
      c.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: o,
        element: c,
        datum: l
      });
      const u = x(n, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(l);
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: o,
        hoveredElement: c,
        items: [
          {
            label: x(n, "locale", "translations", "group") || x(n, "tooltip", "groupLabel") || "Group",
            value: l[r],
            class: t.model.getColorClassName({
              classNameTypes: [st.TOOLTIP],
              dataGroupName: l[r]
            })
          },
          {
            label: "Value",
            value: l[i]
          },
          {
            label: "Target",
            value: l.marker
          },
          {
            label: "Percentage",
            value: `${a(Math.floor(l[i] / l.marker * 100), s)}%`
          },
          {
            label: "Performance",
            value: u[d]
          }
        ]
      });
    }).on("mousemove", function(o, l) {
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: o,
        element: I(this),
        datum: l
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: o
      });
    }).on("click", function(o, l) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: o,
        element: I(this),
        datum: l
      });
    }).on("mouseout", function(o, l) {
      const c = I(this);
      c.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: o,
        element: c,
        datum: l
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: c
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function pN(e) {
  return e;
}
function mN(e) {
  if (e == null)
    return pN;
  var t, n, r = e.scale[0], i = e.scale[1], s = e.translate[0], a = e.translate[1];
  return function(o, l) {
    l || (t = n = 0);
    var c = 2, u = o.length, d = new Array(u);
    for (d[0] = (t += o[0]) * r + s, d[1] = (n += o[1]) * i + a; c < u; )
      d[c] = o[c], ++c;
    return d;
  };
}
function gN(e, t) {
  for (var n, r = e.length, i = r - t; i < --r; )
    n = e[i], e[i++] = e[r], e[r] = n;
}
function vN(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return fp(e, n);
  }) } : fp(e, t);
}
function fp(e, t) {
  var n = t.id, r = t.bbox, i = t.properties == null ? {} : t.properties, s = uh(e, t);
  return n == null && r == null ? { type: "Feature", properties: i, geometry: s } : r == null ? { type: "Feature", id: n, properties: i, geometry: s } : { type: "Feature", id: n, bbox: r, properties: i, geometry: s };
}
function uh(e, t) {
  var n = mN(e.transform), r = e.arcs;
  function i(u, d) {
    d.length && d.pop();
    for (var h = r[u < 0 ? ~u : u], f = 0, p = h.length; f < p; ++f)
      d.push(n(h[f], f));
    u < 0 && gN(d, p);
  }
  function s(u) {
    return n(u);
  }
  function a(u) {
    for (var d = [], h = 0, f = u.length; h < f; ++h)
      i(u[h], d);
    return d.length < 2 && d.push(d[0]), d;
  }
  function o(u) {
    for (var d = a(u); d.length < 4; )
      d.push(d[0]);
    return d;
  }
  function l(u) {
    return u.map(o);
  }
  function c(u) {
    var d = u.type, h;
    switch (d) {
      case "GeometryCollection":
        return { type: d, geometries: u.geometries.map(c) };
      case "Point":
        h = s(u.coordinates);
        break;
      case "MultiPoint":
        h = u.coordinates.map(s);
        break;
      case "LineString":
        h = a(u.arcs);
        break;
      case "MultiLineString":
        h = u.arcs.map(a);
        break;
      case "Polygon":
        h = l(u.arcs);
        break;
      case "MultiPolygon":
        h = u.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: d, coordinates: h };
  }
  return c(t);
}
function yN(e, t) {
  var n = {}, r = {}, i = {}, s = [], a = -1;
  t.forEach(function(c, u) {
    var d = e.arcs[c < 0 ? ~c : c], h;
    d.length < 3 && !d[1][0] && !d[1][1] && (h = t[++a], t[a] = c, t[u] = h);
  }), t.forEach(function(c) {
    var u = o(c), d = u[0], h = u[1], f, p;
    if (f = i[d])
      if (delete i[f.end], f.push(c), f.end = h, p = r[h]) {
        delete r[p.start];
        var v = p === f ? f : f.concat(p);
        r[v.start = f.start] = i[v.end = p.end] = v;
      } else
        r[f.start] = i[f.end] = f;
    else if (f = r[h])
      if (delete r[f.start], f.unshift(c), f.start = d, p = i[d]) {
        delete i[p.end];
        var m = p === f ? f : p.concat(f);
        r[m.start = p.start] = i[m.end = f.end] = m;
      } else
        r[f.start] = i[f.end] = f;
    else
      f = [c], r[f.start = d] = i[f.end = h] = f;
  });
  function o(c) {
    var u = e.arcs[c < 0 ? ~c : c], d = u[0], h;
    return e.transform ? (h = [0, 0], u.forEach(function(f) {
      h[0] += f[0], h[1] += f[1];
    })) : h = u[u.length - 1], c < 0 ? [h, d] : [d, h];
  }
  function l(c, u) {
    for (var d in c) {
      var h = c[d];
      delete u[h.start], delete h.start, delete h.end, h.forEach(function(f) {
        n[f < 0 ? ~f : f] = 1;
      }), s.push(h);
    }
  }
  return l(i, r), l(r, i), t.forEach(function(c) {
    n[c < 0 ? ~c : c] || s.push([c]);
  }), s;
}
function xN(e) {
  for (var t = -1, n = e.length, r, i = e[n - 1], s = 0; ++t < n; )
    r = i, i = e[t], s += r[0] * i[1] - r[1] * i[0];
  return Math.abs(s);
}
function bN(e) {
  return uh(e, EN.apply(this, arguments));
}
function EN(e, t) {
  var n = {}, r = [], i = [];
  t.forEach(s);
  function s(l) {
    switch (l.type) {
      case "GeometryCollection":
        l.geometries.forEach(s);
        break;
      case "Polygon":
        a(l.arcs);
        break;
      case "MultiPolygon":
        l.arcs.forEach(a);
        break;
    }
  }
  function a(l) {
    l.forEach(function(c) {
      c.forEach(function(u) {
        (n[u = u < 0 ? ~u : u] || (n[u] = [])).push(l);
      });
    }), r.push(l);
  }
  function o(l) {
    return xN(uh(e, { type: "Polygon", arcs: [l] }).coordinates[0]);
  }
  return r.forEach(function(l) {
    if (!l._) {
      var c = [], u = [l];
      for (l._ = 1, i.push(c); l = u.pop(); )
        c.push(l), l.forEach(function(d) {
          d.forEach(function(h) {
            n[h < 0 ? ~h : h].forEach(function(f) {
              f._ || (f._ = 1, u.push(f));
            });
          });
        });
    }
  }), r.forEach(function(l) {
    delete l._;
  }), {
    type: "MultiPolygon",
    arcs: i.map(function(l) {
      var c = [], u;
      if (l.forEach(function(v) {
        v.forEach(function(m) {
          m.forEach(function(y) {
            n[y < 0 ? ~y : y].length < 2 && c.push(y);
          });
        });
      }), c = yN(e, c), (u = c.length) > 1)
        for (var d = 1, h = o(c[0]), f, p; d < u; ++d)
          (f = o(c[d])) > h && (p = c[0], c[0] = c[d], c[d] = p, h = f);
      return c;
    }).filter(function(l) {
      return l.length > 0;
    })
  };
}
class _N extends Qn {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = rt.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.model.getOptions(), { cartesianScales: a } = this.services, o = a.getOrientation(), l = a.getRangeScale(), [c, u] = l.range(), d = a.getDomainScale(), h = d.invert(
      o === te.VERTICAL ? n : r
    ), f = N.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), p = N.appendOrSelect(f, "line.ruler-line"), v = i.selectAll("[role=graphics-symbol]").filter((m) => {
      if (parseFloat(_t(m, "data.x0")) <= h && parseFloat(_t(m, "data.x1")) >= h)
        return !0;
    });
    if (v.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !f0(this.elementsToHighlight, v) && this.hideRuler(), v.dispatch("mouseover"), this.elementsToHighlight = v;
      const m = I(v.nodes()[0]).datum(), y = parseFloat(_t(m, "data.x0")), g = parseFloat(_t(m, "data.x1")), b = this.model.getActiveDataGroupNames(), w = b.reverse().map((_) => ({
        label: _,
        value: _t(m, `data.${_}`),
        class: this.model.getColorClassName({
          classNameTypes: [st.TOOLTIP],
          dataGroupName: _
        })
      })).filter((_) => _.value !== 0);
      if (w.length > 0) {
        this.services.events.dispatchEvent(O.Tooltip.SHOW, {
          mousePosition: [n, r],
          hoveredElement: p,
          items: [
            {
              label: _t(s, "bins.rangeLabel") || "Range",
              value: `${y} – ${g}`
            },
            ...w,
            ...x(s, "tooltip", "showTotal") === !0 ? [
              {
                label: _t(s, "locale.translations.total") || _t(s, "tooltip.totalLabel") || "Total",
                value: b.reduce(
                  (S, L) => S + parseFloat(_t(m, `data.${L}`)),
                  0
                )
              }
            ] : []
          ]
        }), f.attr("opacity", 1);
        const _ = d((y + g) / 2);
        o === "horizontal" ? p.attr("x1", u).attr("x2", c).attr("y1", _).attr("y2", _) : p.attr("y1", u).attr("y2", c).attr("x1", _).attr("x2", _);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class wo extends Qn {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const wN = (e, t) => {
  const n = e.x, r = e.y, i = t.x, s = t.y, a = Lm();
  return a.moveTo(n, r), a.lineTo(i, s), a.toString();
}, SN = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, ON = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, TN = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, MN = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, CN = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, AN = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class L0 extends lh {
  constructor(t, n, r) {
    super(t, n, r), this.type = "color-legend", this.renderType = rt.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const i = this.getComponentContainer(), { width: s } = N.getSVGElementSize(i, {
        useAttrs: !0
      }), a = x(this.getOptions(), "data", "loading");
      if (s > qt.color.barWidth && !a) {
        const o = x(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, c = l.getMainXScale().range();
        if (c[0] > 1 && (i.select("g.legend").attr("transform", `translate(${c[0]}, 0)`), o)) {
          const { width: u } = N.getSVGElementSize(
            i.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), d = c[0] - u - 9;
          d > 1 ? i.select("g.legend-title").attr("transform", `translate(${d}, 0)`) : (i.select("g.legend").attr("transform", `translate(${c[0]}, 16)`), i.select("g.legend-title").attr("transform", `translate(${c[0]}, 0)`));
        }
      } else
        i.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = r.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(O.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = this.getComponentContainer(), { width: i } = N.getSVGElementSize(r, {
      useAttrs: !0
    }), s = x(n, "color", "gradient", "colors"), a = x(n, this.chartType, "colorLegend", "type");
    let o = x(n, "color", "pairing", "option");
    const l = x(n, "heatmap", "colorLegend", "title");
    if (x(this.getOptions(), "data", "loading")) {
      r.html("");
      return;
    }
    const c = !We(s), u = Iv(this.model.getDisplayData()), d = !(i <= qt.color.barWidth), h = d ? qt.color.barWidth : i, f = N.appendOrSelect(r, "g.legend"), p = N.appendOrSelect(f, "g.legend-axis");
    if (l) {
      const k = N.appendOrSelect(r, "g.legend-title");
      N.appendOrSelect(k, "text").text(l).attr("dy", "0.7em"), f.attr("transform", "translate(0, 16)");
    }
    const v = u[0] < 0 && u[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && v === "mono" || o < 1 && o > 2 && v === "diverge") && (o = 1);
    let m = [];
    const y = v === "diverge" ? 17 : 11;
    if (c)
      m = s;
    else
      for (let k = 1; k < y + 1; k++)
        m.push(
          a === xa.LINEAR ? `stop-color-${v}-${o}-${k}` : `fill-${v}-${o}-${k}`
        );
    const g = Me(u[0], u[1]), b = Bx(g, 3), w = Ke().domain(u).range([0, h]), _ = hu(w).tickSize(0).tickValues(b), { code: S, number: L } = x(n, "locale");
    _.tickFormat((k) => L(k, S));
    let D;
    switch (a) {
      case xa.LINEAR:
        this.drawLinear(m, f, h);
        break;
      case xa.QUANTIZE:
        D = this.drawQuantize(
          m,
          v,
          c,
          f,
          h
        ), w.range([D, h]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    p.attr("transform", `translate(0,${qt.color.axisYTranslation})`).call(_), p.select(".domain").remove(), p.select("g.tick:last-of-type text").style("text-anchor", d ? "middle" : "end"), p.select("g.tick:first-of-type text").style(
      "text-anchor",
      d && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, n, r) {
    const i = 100 / (t.length - 1);
    N.appendOrSelect(n, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (s, a) => `${a * i}%`).attr("class", (s, a) => t[a]).attr("stop-color", (s) => s), N.appendOrSelect(n, "rect").attr("width", r).attr("height", qt.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, n, r, i, s) {
    !r && n === "diverge" && t.splice(t.length / 2, 1);
    const a = Ds().domain(t).range([0, s]);
    return N.appendOrSelect(i, "g.quantized-rect").selectAll("rect").data(a.domain()).join("rect").attr("x", (o) => a(o)).attr("y", 0).attr("width", Math.max(0, a.bandwidth() - 1)).attr("height", qt.color.barHeight).attr("class", (o) => o).attr("fill", (o) => o), (!r && n) === "mono" ? a.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(O.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class $N extends zs {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = rt.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = x(this.model.getDisplayData(), 0), r = this.getOptions(), i = this.getComponentContainer(), { groupMapsTo: s } = r.data, a = r.locale.translations.meter.title;
    if (x(r, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const c = i.selectAll("text.meter-title").data(a ? [a] : [n[s]]);
      c.enter().append("text").classed("meter-title", !0).merge(c).attr("x", 0).attr("y", "1em").text((u) => u), c.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const o = this.getMaxTitleWidth(), l = N.appendOrSelect(i, "text.meter-title");
    o > 0 && l.node().getComputedTextLength() > o && this.truncateTitle(l, o);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), i = x(n, "meter", "proportional", "total"), s = x(n, "meter", "proportional", "unit") ? x(n, "meter", "proportional", "unit") : "";
    let a;
    if (r === i)
      a = null;
    else {
      const u = i !== null ? i - r : r, d = x(n, "meter", "proportional", "breakdownFormatter"), { code: h, number: f } = x(n, "locale");
      a = d !== null ? d({
        datasetsTotal: r,
        total: i
      }) : `${f(r, h)} ${s} used (${f(u, h)} ${s} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([a]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((u) => u), o.exit().remove();
    const l = this.getMaxTitleWidth(), c = N.appendOrSelect(t, "text.proportional-meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = x(n, "meter", "proportional", "total"), i = r ? x(n, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), s = x(n, "meter", "proportional", "unit") ? x(n, "meter", "proportional", "unit") : "", a = x(n, "meter", "proportional", "totalFormatter"), { code: o, number: l } = x(n, "locale"), c = a !== null ? a(i) : `${l(r, o)} ${s} total`, u = N.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([c]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof u != "string" ? u - ie.total.paddingRight : u
    ).attr("y", "1em").attr("text-anchor", "end").text((h) => h), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, n = this.getComponentContainer(), r = N.getHTMLElementSize(this.parent.node()).width || 0, i = this.model.getStatus(), s = ie.status.indicatorSize / 2, a = N.appendOrSelect(n, "g.status-indicator").attr("class", i !== null ? `status-indicator status--${i}` : "").attr("transform", `translate(${r - s}, 0)`), o = i ? [i] : [], l = a.selectAll("circle.status").data(o);
    l.enter().append("circle").merge(l).attr("class", "status").attr("r", s).attr("cx", 0).attr("cy", 8);
    const c = a.selectAll("path.innerFill").data(o);
    c.enter().append("path").merge(c).attr("d", t.getStatusIconPathString(i)).attr("transform", `translate(-${s}, 0)`).attr("class", "innerFill"), c.exit().remove(), l.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = x(this.model.getDisplayData(), 0, "value"), { code: n, number: r } = x(this.getOptions(), "locale"), i = this.getComponentContainer(), s = N.appendOrSelect(i, "text.meter-title"), a = x(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = i.selectAll("text.percent-value").data(a), l = ie.statusBar.paddingRight;
    o.enter().append("text").classed("percent-value", !0).merge(o).text((c) => `${c != null ? r(c, n) : 0}%`).attr("x", +s.attr("x") + s.node().getComputedTextLength() + l).attr("y", s.attr("y")), o.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param titlestring the original string that needs truncation
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, n) {
    super.truncateTitle(t, n);
    const r = N.appendOrSelect(this.parent, "tspan"), i = ie.statusBar.paddingRight, s = Math.ceil(r.node().getComputedTextLength());
    N.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + s + i
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = x(this.getOptions(), "meter", "proportional"), n = N.getHTMLElementSize(this.parent.node()).width;
    if (t !== null) {
      const r = N.appendOrSelect(this.parent, "text.proportional-meter-total").node(), i = N.getSVGElementSize(r, {
        useBBox: !0
      }).width;
      return n - i - ie.total.paddingLeft;
    } else {
      const r = N.appendOrSelect(this.parent, "text.percent-value"), i = ie.statusBar.paddingRight, s = r.node().getComputedTextLength(), a = N.appendOrSelect(this.parent, "g.status-indicator").node(), o = N.getSVGElementSize(a, { useBBox: !0 }).width + ie.status.paddingLeft;
      return n - s - i - o;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case va.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case va.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case va.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class hh extends yt {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const n = this.model.getDisplayData().length, r = this.services.cartesianScales.getMainXScale(), i = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!r.step) {
      const s = x(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, i * s / n);
    }
    return Math.min(t.bars.maxWidth, r.step() / 2);
  }
  isOutsideZoomedDomain(t, n) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const r = this.model.get("zoomDomain");
    if (r !== void 0) {
      const i = this.services.cartesianScales.getDomainScale();
      return t < i(r[0]) || n > i(r[1]);
    }
    return !1;
  }
}
class LN extends yt {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (r) => r.data.dataGroupName === n.datum().name ? 1 : Fr.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    let s = this.model.getDisplayData();
    const a = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), l = this.getOptions(), c = x(l, "canvasZoom", "enabled");
    a && x(s, 0, "children") && (s = x(s, 0, "children"));
    const u = ks({ children: s }).sum((p) => p.value).sort((p, v) => v.value - p.value), d = Q_().size([r, i]).padding((p) => p.depth >= 1 ? Fr.padding.children + 3 : Fr.padding.mainGroup + 3)(u).descendants().splice(1).filter((p) => p.depth <= o), h = n.selectAll("circle.node").data(d);
    h.exit().attr("width", 0).attr("height", 0).remove();
    const f = h.enter().append("circle").classed("node", !0);
    f.merge(h).attr("class", (p) => {
      const v = c && o === 3 ? this.getZoomClass(p) : "";
      return this.model.getColorClassName({
        classNameTypes: [st.FILL, st.STROKE],
        dataGroupName: p.data.dataGroupName,
        originalClassName: p.children ? `node ${v}` : `node node-leaf ${v}`
      });
    }).style("fill", (p) => this.model.getFillColor(p.data.dataGroupName, null, p.data)).style("stroke", (p) => this.model.getFillColor(p.data.dataGroupName, null, p.data)).attr("cx", (p) => p.x).attr("cy", (p) => p.y).transition("circlepack-leaf-update-enter").call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (p) => p.r).attr("opacity", 1).attr("fill-opacity", Fr.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, f, Zr), this.setBackgroundListeners()), a || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", (r) => this.model.getFillColor(r.data.dataGroupName, null, r.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", Fr.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((n) => n.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    I(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = I(this.services.domUtils.getMainContainer()), n = this, r = this.parent.selectAll("circle.node");
    t.on("click", () => {
      n.focal = null, n.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), n.services.canvasZoom.zoomOut(r, Zr);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(n, r) {
      const i = I(this);
      i.classed("hovered", !0);
      const s = t.model.getHierarchyLevel(), a = s > 2 && !i.classed("focal"), o = x(t.model.getOptions(), "canvasZoom", "enabled");
      let l = !1;
      if (!a) {
        let c = [], u = [], d = null;
        if (r.children) {
          r.depth > 1 && o && (l = !0, i.classed("clickable", !0)), c = r.children.map((p) => {
            if (p !== null)
              return typeof p.data.value == "number" ? {
                label: p.data.name,
                value: p.data.value
              } : {
                label: p.data.name,
                labelIcon: o && s <= 2 ? t.getZoomIcon() : null,
                value: p.value
              };
          });
          const f = t.model.getOptions();
          u = [
            {
              label: _t(f, "locale.translations.total") || _t(f, "tooltip.totalLabel") || "Total",
              value: r.value,
              bold: !0
            }
          ], t.highlightChildren(r.children);
        } else
          d = r.value;
        const h = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: n,
          hoveredElement: i,
          items: [
            {
              color: h,
              label: r.data.name,
              labelIcon: l && o && s <= 2 ? t.getZoomIcon() : null,
              value: d
            },
            ...c,
            ...u
          ]
        });
      }
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1), r.children && t.unhighlightChildren(r.children), t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    }).on("click", function(n, r) {
      const i = I(this), s = i.classed("non-focal"), a = x(t.model.getOptions(), "canvasZoom", "enabled");
      if (a && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Zr);
      } else if (r.depth === 2 && r.children && !s && a) {
        const o = t.parent.selectAll("circle.node");
        I(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = r, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(r, o, Zr), n.stopPropagation();
      }
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_CLICK, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function RN(e, t) {
  const n = Rs(this._current, e);
  return (r) => (this._current = n(r), t(this._current));
}
class R0 extends yt {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = rt.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (i) => i.data[r] !== n.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return Bt.innerRadius;
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer(), i = this.getOptions(), { groupMapsTo: s } = i.data, { valueMapsTo: a } = i.pie;
    this.isRendering = !0;
    const o = this.model.getDisplayData().filter((k) => k[a] > 0), l = this.computeRadius();
    this.arc = ws().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = ws().innerRadius(this.getInnerRadius()).outerRadius(l + Bt.hoverArc.outerRadiusOffset);
    const c = JS().value((k) => k[a]).sort(x(i, "pie", "sortFunction")).padAngle(Bt.padAngle)(o), u = N.appendOrSelect(r, "g.slices").attr("role", ht.GROUP).attr("data-name", "slices").selectAll("path.slice").data(c, (k) => k.data[s]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (k) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: k.data[s],
        originalClassName: "slice"
      })
    ).style("fill", (k) => n.model.getFillColor(k.data[s], null, k.data)).attr("d", this.arc).transition().call(
      (k) => this.services.transitions.setupTransition({
        transition: k,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(
      "aria-label",
      (k) => `${k[a]}, ${kl(k.data[a], o, a) + "%"}`
    ).attrTween("d", function(k) {
      return RN.bind(this)(k, n.arc);
    }).on("end", () => {
      n.isRendering = !1;
    });
    const { code: d, number: h } = x(i, "locale"), f = i.pie.labels.enabled, p = f ? c.filter((k) => k.data[a] > 0) : [], v = N.appendOrSelect(r, "g.labels").attr("role", ht.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(p, (k) => k.data[s]);
    v.exit().attr("opacity", 0).remove();
    const m = v.enter().append("text").classed("pie-label", !0), y = [];
    m.merge(v).style("text-anchor", "middle").text((k) => i.pie.labels.formatter ? i.pie.labels.formatter({
      ...k,
      percentageValue: kl(
        k.data[a],
        o,
        a,
        !0
      )
    }) : h(
      kl(k.data[a], o, a),
      d
    ) + "%").datum(function(k) {
      const R = l + 7, M = (k.endAngle - k.startAngle) / 2 + k.startAngle, V = M / Math.PI * 180, P = this.getComputedTextLength();
      return k.textOffsetX = P / 2, k.textOffsetY = V > 90 && V < 270 ? 10 : 0, k.xPosition = (k.textOffsetX + R) * Math.sin(M), k.yPosition = (k.textOffsetY + R) * -Math.cos(M), k;
    }).attr("transform", function(k, R) {
      const M = p.length, V = (k.endAngle - k.startAngle) * (180 / Math.PI);
      if (R >= M - 2 && V < Bt.callout.minSliceDegree) {
        let P, H;
        return k.index === M - 1 ? (P = k.xPosition + Bt.callout.offsetX + Bt.callout.textMargin + k.textOffsetX, H = k.yPosition - Bt.callout.offsetY, k.direction = ga.RIGHT, y.push(k)) : (P = k.xPosition - Bt.callout.offsetX - k.textOffsetX - Bt.callout.textMargin, H = k.yPosition - Bt.callout.offsetY, k.direction = ga.LEFT, y.push(k)), `translate(${P}, ${H})`;
      }
      return `translate(${k.xPosition}, ${k.yPosition})`;
    }), this.renderCallouts(y);
    const g = x(i, "donut") ? "donut" : "pie", b = x(i, g, "alignment"), { width: w } = N.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), _ = f ? Bt.xOffset : 0, S = f ? Bt.yOffset : 0;
    let L = l + _;
    b === ee.CENTER ? L = w / 2 : b === ee.RIGHT && (L = w - l - Bt.xOffset);
    let D = l + S;
    y.length > 0 && (D += Bt.yOffsetCallout), r.attr("x", L + 7).attr("y", D), this.addEventListeners();
  }
  renderCallouts(t) {
    const n = N.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", ht.GROUP).attr("data-name", "callouts"), r = n.selectAll("g.callout").data(t);
    r.exit().remove();
    const i = r.enter().append("g").classed("callout", !0).attr("role", ht.GROUP).attr("aria-roledescription", "label callout");
    i.merge(r).datum(function(s) {
      const { xPosition: a, yPosition: o, direction: l } = s;
      return l === ga.RIGHT ? (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a + Bt.callout.offsetX,
        y: o - Bt.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x - Bt.callout.horizontalLineLength) : (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a - Bt.callout.offsetX,
        y: o - Bt.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x + Bt.callout.horizontalLineLength), s;
    }), i.append("line").classed("vertical-line", !0).merge(n.selectAll("line.vertical-line")).datum(function() {
      return I(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.startPos.x).attr("y1", (s) => s.startPos.y).attr("x2", (s) => s.intersectPointX).attr("y2", (s) => s.endPos.y), i.append("line").classed("horizontal-line", !0).merge(n.selectAll("line.horizontal-line")).datum(function() {
      return I(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.intersectPointX).attr("y1", (s) => s.endPos.y).attr("x2", (s) => s.endPos.x).attr("y2", (s) => s.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(n, r) {
      const i = I(this);
      t.isRendering || i.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEOVER, {
        event: n,
        element: I(this),
        datum: r
      });
      const { groupMapsTo: s } = t.getOptions().data, { valueMapsTo: a } = t.getOptions().pie;
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: r.data[s],
            value: r.data[a]
          }
        ]
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Pie.SLICE_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      vD(() => {
        t.isRendering || i.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (s) => t.services.transitions.setupTransition({
            transition: s,
            name: "pie_slice_mouseout"
          })
        ).attr("d", t.arc);
      }, 100), t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: n } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), r = this.getOptions(), i = Math.min(t, n) / 2;
    return r.pie.labels.enabled ? i + Bt.radiusOffset : i;
  }
}
class kN extends R0 {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = rt.SVG;
  }
  render(t = !0) {
    super.render(t);
    const n = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    const r = N.appendOrSelect(this.getComponentContainer(), "g.center"), i = this.getOptions(), s = this.computeRadius(), a = x(i, "donut", "center", "label");
    N.appendOrSelect(r, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => a === null || a === "" ? "central" : "initial").style("font-size", () => i.donut.center.numberFontSize(s)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return n.centerNumberTween(I(this));
    }), a !== null && a !== "" && N.appendOrSelect(r, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => i.donut.center.titleFontSize(s)).attr("y", i.donut.center.titleYPosition(s)).text(a);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const n = this.getOptions();
    let r = x(n, "donut", "center", "number");
    r === null && (r = this.model.getDisplayData().reduce((o, l) => o + l[n.pie.valueMapsTo], 0));
    const i = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let s;
    i % 1 === 0 && r % 1 === 0 ? s = ym : s = Me;
    const a = s(i, r);
    return (o) => {
      const { numberFormatter: l } = n.donut.center;
      if (l)
        t.text(l(a(o)));
      else {
        const { code: c, number: u } = x(n, "locale");
        t.text(u(Math.floor(a(o)), c));
      }
    };
  }
}
const pp = "4,10 8,6 12,10", mp = "12,6 8,10 4,6";
class DN extends yt {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = rt.SVG;
  }
  getValue() {
    var t;
    return ((t = this.model.getData().find((n) => n.group === "value")) == null ? void 0 : t.value) ?? null;
  }
  getValueRatio() {
    return d0(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var t;
    return ((t = this.model.getData().find((n) => n.group === "delta")) == null ? void 0 : t.value) ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return x(t, "gauge", "type") === jr.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const n = this.getOptions();
    switch (x(n, "gauge", "deltaArrow", "direction")) {
      case Wl.UP:
        return pp;
      case Wl.DOWN:
        return mp;
      default:
        return t > 0 ? pp : mp;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), r = this.getOptions(), i = this.getValue(), s = this.getValueRatio(), a = this.getArcSize(), o = this.getStartAngle(), l = s * a, c = o + l, u = o + a, d = this.computeRadius(), h = this.getInnerRadius();
    this.backgroundArc = ws().innerRadius(h).outerRadius(d).startAngle(c).endAngle(u), this.arc = ws().innerRadius(h).outerRadius(d).startAngle(o).endAngle(c), N.appendOrSelect(n, "path.arc-background").attr("d", this.backgroundArc);
    const f = n.selectAll("path.arc-foreground").data([i]);
    f.enter().append("path").merge(f).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => x(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (y) => y), this.drawValueNumber(), this.drawDelta(), f.exit().remove();
    const p = x(r, "gauge", "alignment"), { width: v } = N.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let m = d;
    p === ee.CENTER ? m = v / 2 : p === ee.RIGHT && (m = v - d), n.attr("x", m).attr("y", d), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = x(n, "gauge", "type"), i = this.getValue(), s = this.getDelta(), a = this.computeRadius(), o = x(n, "gauge", "valueFontSize"), l = x(n, "gauge", "deltaFontSize"), c = x(n, "gauge", "numberSpacing"), u = x(n, "gauge", "showPercentageSymbol");
    let d = 0;
    r === jr.FULL && !s ? d = l(a) : r === jr.SEMI && s && (d = -(l(a) + c));
    const h = N.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${d})`
    ), f = o(a), p = N.appendOrSelect(h, "g.gauge-value-number"), { code: v, number: m } = x(n, "locale"), y = x(n, "gauge", "numberFormatter"), g = p.selectAll("text.gauge-value-number").data([i]);
    g.enter().append("text").attr("class", "gauge-value-number").merge(g).style("font-size", `${f}px`).attr("text-anchor", "middle").text((k) => {
      let R;
      return k != null ? R = Number(k.toFixed(2)) % 1 !== 0 ? k.toFixed(2) : k.toFixed() : R = 0, y ? y(R) : m(Number(R), v);
    });
    const { width: b } = N.getSVGElementSize(
      N.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), w = f / 2, _ = u ? "%" : "", S = N.appendOrSelect(p, "text.gauge-value-symbol").style("font-size", `${w}px`).attr("x", b / 2).text(_), { width: L, height: D } = N.getSVGElementSize(S, {
      useBBox: !0
    });
    S.attr("y", `-${D / 2}px`), p.attr("transform", `translate(-${L / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = this.getDelta(), { code: s, number: a } = x(r, "locale");
    if (i) {
      const o = this.computeRadius(), l = i ? x(r, "gauge", "deltaFontSize") : () => 0, c = i ? x(r, "gauge", "numberFormatter") : () => null, u = x(r, "gauge", "deltaArrow", "size"), d = x(r, "gauge", "numberSpacing"), h = x(r, "gauge", "showPercentageSymbol"), f = N.appendOrSelect(n, "g.gauge-numbers"), p = N.appendOrSelect(f, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${l(o) + d})`
      ), v = N.appendOrSelect(p, "text.gauge-delta-number"), m = h ? "%" : "";
      v.data(i === null ? [] : [i]), v.enter().append("text").classed("gauge-delta-number", !0).merge(v).attr("text-anchor", "middle").style("font-size", `${l(o)}px`).text((w) => {
        let _;
        return w != null ? _ = Number(w.toFixed(2)) % 1 !== 0 ? w.toFixed(2) : w.toFixed() : _ = 0, c ? `${c(_)}${m}` : `${a(Number(_), s)}${m}`;
      });
      const { width: y } = N.getSVGElementSize(
        N.appendOrSelect(n, ".gauge-delta-number"),
        { useBBox: !0 }
      ), g = x(r, "gauge", "deltaArrow", "enabled"), b = p.selectAll("svg.gauge-delta-arrow").data(i !== null && g ? [i] : []);
      b.enter().append("svg").merge(b).attr("class", "gauge-delta-arrow").attr("x", -u(o) - y / 2).attr("y", -u(o) / 2 - l(o) * 0.35).attr("width", u(o)).attr("height", u(o)).attr("viewBox", "0 0 16 16").each(function() {
        const w = I(this);
        N.appendOrSelect(w, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const _ = x(r, "gauge", "status");
        N.appendOrSelect(w, "polygon.gauge-delta-arrow").attr("class", _ !== null ? `gauge-delta-arrow status--${_}` : "").attr("points", t.getArrow(i));
      }), b.exit().remove(), v.exit().remove();
    } else {
      const o = n.select("g.gauge-delta");
      o.empty() || o.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), n = x(this.getOptions(), "gauge", "arcWidth");
    return t - n;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(n, r) {
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEOVER, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Gauge.ARC_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), n = x(t, "gauge", "type"), { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return n === jr.SEMI ? Math.min(r / 2, i) : Math.min(r / 2, i / 2);
  }
}
class k0 extends hh {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = rt.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.model.getDisplayData(this.configs.groups), r = this.getOptions(), { groupMapsTo: i } = r.data;
    this.setGroupScale();
    const s = this.getComponentContainer({ withinChartClip: !0 }), a = Cs(
      n.map((u) => {
        const d = this.services.cartesianScales.getDomainIdentifier(u);
        return u[d] && typeof u[d].toString == "function" ? u[d].toString() : u[d];
      })
    ), o = s.selectAll("g.bars").data(a, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const d = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === te.VERTICAL ? `translate(${d}, 0)` : `translate(0, ${d})`;
    });
    const c = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[i]
    );
    c.exit().attr("opacity", 0).remove(), c.enter().append("path").attr("opacity", 0).merge(c).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: u[i],
        originalClassName: "bar"
      })
    ).style("fill", (u) => {
      const d = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[i], u[d], u);
    }).attr("d", (u) => {
      const d = this.groupScale(u[i]), h = this.getBarWidth(), f = d, p = d + h, v = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), m = this.services.cartesianScales.getDomainLowerBound(v), y = this.services.cartesianScales.getValueThroughAxisPosition(v, m), g = this.services.cartesianScales.getRangeValue(u), b = this.services.cartesianScales.getDomainValue(u) - h / 2, w = b + h;
      if (!this.isOutsideZoomedDomain(b, w))
        return de(
          { x0: f, x1: p, y0: y, y1: g },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {
      const i = I(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        data: [r]
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const r = this.services.cartesianScales.getDomainIdentifier(n);
      return n[r].toString() === t;
    });
  }
  getGroupWidth() {
    const t = this.model.getGroupedData(this.configs.groups), n = this.getTotalGroupPadding();
    return this.getBarWidth() * t.length + n;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), n = this.model.getGroupedData(this.configs.groups);
    let r = this.defaultStepFactor;
    if (typeof t.step == "function")
      r = t.step();
    else if (n.length > 0) {
      const i = n.find((s) => {
        var a;
        return ((a = s.data) == null ? void 0 : a.length) > 1;
      });
      if (i) {
        const s = this.services.cartesianScales.getDomainIdentifier(i.data[0]);
        r = Math.abs(
          t(i.data[1][s]) - t(i.data[0][s])
        );
      }
    }
    return r;
  }
  getTotalGroupPadding() {
    const t = this.model.getGroupedData(this.configs.groups);
    return t.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (t.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), n = x(t, "bars", "width"), r = x(t, "bars", "maxWidth");
    if (n !== null && (r === null || n <= r))
      return n;
    const i = this.model.getGroupedData(this.configs.groups).length, s = this.getTotalGroupPadding();
    return Math.min(
      r,
      (this.getDomainScaleStep() - s) / i
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = Ds().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
}
class IN extends yt {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = rt.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: n } = t, { datum: r } = n, i = this.model.getUniqueRanges(), s = this.model.getUniqueDomain(), a = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();
      let u = "", d = null, h = null, f = null;
      this.matrix[r] !== void 0 ? (u = a, i.forEach((p) => {
        if (typeof this.matrix[r][p].value == "number") {
          const v = this.matrix[r][p].value;
          if (d === null) {
            d = v, h = v, f = v;
            return;
          }
          d += v, h = v < h ? v : h, f = v > f ? v : f;
        }
      })) : (u = o, s.forEach((p) => {
        if (typeof this.matrix[p][r].value == "number") {
          const v = this.matrix[p][r].value;
          if (d === null) {
            d = v, h = v, f = v;
            return;
          }
          d += v, h = v < h ? v : h, f = v > f ? v : f;
        }
      })), l(r) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(r)}, ${Zn(c.range())})`) : c(r) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${Zn(l.range())},${c(r)})`), this.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n.event,
        hoveredElement: I(t.detail.element),
        items: [
          {
            label: u,
            value: r,
            bold: !0
          },
          {
            label: "Min",
            value: h !== null ? h : "-"
          },
          {
            label: "Max",
            value: f !== null ? f : "-"
          },
          {
            label: "Average",
            value: d !== null ? d / s.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(O.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(O.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(O.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 });
    n.lower();
    const { cartesianScales: r } = this.services;
    if (this.matrix = this.model.getMatrix(), n.html(""), x(this.getOptions(), "data", "loading"))
      return;
    const i = r.getMainXScale(), s = r.getMainYScale(), a = r.getDomainIdentifier(), o = r.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), u = this.model.getMatrixAsArray(), d = i.range(), h = s.range();
    this.xBandwidth = Math.abs((d[1] - d[0]) / l.length), this.yBandwidth = Math.abs((h[1] - h[0]) / c.length);
    const f = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    n.append("defs").append("pattern").attr("id", f).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const p = n.selectAll().data(u).enter().append("g").attr("class", (v) => `heat-${v.index}`).classed("cell", !0).attr(
      "transform",
      (v) => `translate(${i(v[a])}, ${s(v[o])})`
    ).append("rect").attr(
      "class",
      (v) => this.model.getColorClassName({
        value: v.value,
        originalClassName: `heat-${v.index}`
      })
    ).classed("heat", !0).classed("null-state", (v) => v.index === -1 || v.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (v) => {
      const m = this.services.cartesianScales.getDomainIdentifier(v);
      return v.index === -1 || v.value === null ? `url(#${f})` : this.model.getFillColor(Number(v.value), v[m], v);
    }).attr("aria-label", (v) => v.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(h[1] - h[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(d[1] - d[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (p.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, n, r) {
    const i = N.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    N.appendOrSelect(i, "line.top").attr("x1", -1).attr("x2", n + 1), N.appendOrSelect(i, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", r + 1), N.appendOrSelect(i, "line.down").attr("x1", -1).attr("x2", n + 1).attr("y1", r).attr("y2", r), N.appendOrSelect(i, "line.right").attr("x1", n).attr("x2", n).attr("y1", -1).attr("y2", r + 1);
  }
  determineDividerStatus() {
    const t = x(this.getOptions(), "heatmap", "divider", "state");
    return t !== as.OFF && (t === as.AUTO && vf.minCellDividerDimension <= this.xBandwidth && vf.minCellDividerDimension <= this.yBandwidth || t === as.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: n } = this.services, r = this.getOptions(), i = _t(r, "locale.translations.total") || _t(r, "tooltip.totalLabel") || "Total", s = n.getDomainIdentifier(), a = n.getRangeIdentifier(), o = n.getDomainLabel(), l = n.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(c, u) {
      const d = I(this), h = d.select("rect.heat");
      if (!h.classed("null-state")) {
        const f = es(d.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${f.x + t.translationUnits.x}, ${f.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEOVER, {
          event: c,
          element: h,
          datum: u
        }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: c,
          items: [
            {
              label: o,
              value: u[s]
            },
            {
              label: l,
              value: u[a]
            },
            {
              label: i,
              value: u.value,
              color: h.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(c, u) {
      t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEMOVE, {
        event: c,
        element: I(this),
        datum: u
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      t.services.events.dispatchEvent(O.Heatmap.HEATMAP_CLICK, {
        event: c,
        element: I(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      const d = I(this).select("rect.heat"), h = d.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), h || (t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEOUT, {
        event: c,
        element: d,
        datum: u
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: c,
        hoveredElement: d
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class NN extends yt {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer(), r = this.model.getOptions(), { groupIdentifier: i } = r, { groupMapsTo: s } = r.data, a = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), l = n.selectAll("g.bars").data(a, (u) => _t(u, `0.${s}`));
    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", ht.GROUP);
    const c = n.selectAll("g.bars").selectAll("path.bar").data((u) => u);
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(i, (u, d) => d).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: u[s],
        originalClassName: "bar"
      })
    ).style("fill", (u) => this.model.getFillColor(u[s], null, u)).attr("d", (u) => {
      const d = _t(u, "data");
      if (!d)
        return;
      const h = o(d.x1) - o(d.x0) - 1, f = this.services.cartesianScales.getDomainValue(d.x0), p = f + h, v = this.services.cartesianScales.getRangeValue(u[0]);
      let m = this.services.cartesianScales.getRangeValue(u[1]);
      return Math.abs(m - v) > 0 && Math.abs(m - v) > r.bars.dividerSize && (this.services.cartesianScales.getOrientation() === te.VERTICAL ? m += 1 : m -= 1), de(
        { x0: f, x1: p, y0: v, y1: m },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => x(u, "data", u[s])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: n } = t.data, { code: r, number: i } = x(t, "locale"), s = this;
    this.parent.selectAll("path.bar").on("mouseover", function(a, o) {
      const l = I(this);
      l.classed("hovered", !0);
      const c = i(parseFloat(_t(o, "data.x0")), r), u = i(parseFloat(_t(o, "data.x1")), r), d = s.services.cartesianScales.getRangeAxisPosition(), h = s.services.cartesianScales.getScaleLabel(d);
      s.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: l,
        items: [
          {
            label: _t(t, "bins.rangeLabel") || "Range",
            value: `${c} – ${u}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: o[n],
            class: s.model.getColorClassName({
              classNameTypes: [st.TOOLTIP],
              dataGroupName: o[n]
            })
          },
          {
            label: h,
            value: _t(o, `data.${o[n]}`)
          }
        ]
      });
    }).on("mousemove", function(a) {
      s.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: a
      });
    }).on("mouseout", function() {
      I(this).classed("hovered", !1), s.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class PN extends hn {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = rt.SVG, this.handleScatterOnHover = (t) => {
      const n = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").attr("stroke-width", (s) => s[i] !== n.datum[i] ? wn.weight.unselected : wn.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", wn.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-line"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? wn.opacity.unselected : wn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", wn.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.model.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services, a = s.getMainXScale(), o = s.getMainYScale(), l = s.getDomainIdentifier(), c = (m) => s.getDomainValue(m), u = (m) => s.getRangeValue(m), d = s.getOrientation(), [h, f] = Cn(
      c,
      u,
      d
    ), p = n.selectAll("line.line").data(
      this.getScatterData(),
      (m) => `${m[i]}-${m[l]}`
    );
    p.exit().attr("opacity", 0).remove();
    const v = p.enter().append("line").attr("opacity", 0).merge(p).classed("line", !0).attr(
      "class",
      (m) => this.model.getColorClassName({
        classNameTypes: [st.STROKE],
        dataGroupName: m[i],
        originalClassName: "line"
      })
    ).transition().call(
      (m) => this.services.transitions.setupTransition({
        transition: m,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (m) => this.model.getFillColor(m[i], m[l], m)).attr("opacity", 1);
    d === te.HORIZONTAL ? v.attr("y1", f).attr("y2", f).attr("x1", a.range()[0]).attr("x2", (m) => h(m) - r.points.radius) : v.attr("x1", h).attr("x2", h).attr("y1", o.range()[0]).attr("y2", (m) => f(m) + r.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      O.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      O.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(O.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      O.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class UN extends yt {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = rt.SVG;
  }
  getStackedBounds(t, n) {
    let r = 0;
    return t.map((i, s) => s !== 0 ? (r += n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - ie.dividerWidth),
      x: r - n(i.value)
    }) : (r = n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - ie.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer(), i = this.getOptions(), s = x(i, "meter", "proportional"), a = this.model.getDisplayData(), o = this.model.getStatus(), { width: l } = N.getSVGElementSize(r, {
      useAttrs: !0
    }), { groupMapsTo: c } = i.data;
    let u;
    x(i, "meter", "proportional") === null ? u = 100 : u = x(i, "meter", "proportional", "total") || this.model.getMaximumDomain(this.model.getDisplayData());
    const d = Ke().domain([0, u]).range([0, l]), h = this.getStackedBounds(a, d), f = x(i, "meter", "height");
    N.appendOrSelect(r, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(
      "height",
      f || (s ? ie.height.proportional : ie.height.default)
    ), N.appendOrSelect(r, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(
      "y2",
      f || (s ? ie.height.proportional : ie.height.default)
    );
    const p = r.selectAll("rect.value").data(h), v = o != null && !n.model.isUserProvidedColorScaleValid() && !s ? `value status--${o}` : "value";
    p.enter().append("rect").classed("value", !0).merge(p).attr("x", (b) => b.x).attr("y", 0).attr("height", () => f || (s ? ie.height.proportional : ie.height.default)).attr(
      "class",
      (b) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: b[c],
        originalClassName: v
      })
    ).transition().call(
      (b) => this.services.transitions.setupTransition({
        transition: b,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (b) => b.value > u ? d(u) : Math.max(b.width, 2)).style("fill", (b) => n.model.getFillColor(b[c], null, b)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (b) => b.value), p.exit().remove();
    const m = x(i, "meter", "peak");
    let y = m;
    m !== null && (m > u ? y = u : m < a[0].value && (y = a[0].value > u ? u : a[0].value));
    const g = r.selectAll("line.peak").data(y == null ? [] : [y]);
    g.enter().append("line").classed("peak", !0).merge(g).attr("y1", 0).attr("y2", () => f || (s ? ie.height.proportional : ie.height.default)).transition().call(
      (b) => this.services.transitions.setupTransition({
        transition: b,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (b) => d(b)).attr("x2", (b) => d(b)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (b) => b), g.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = x(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !0), r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: a[n],
            value: a.value
          }
        ]
      }));
    }).on("mousemove", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), i && r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(O.Meter.METER_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !1), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class BN extends yt {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = rt.SVG, this.getLabelDimensions = (t) => {
      const n = N.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), r = N.appendOrSelect(n, "text").text(t), { width: i, height: s } = N.getSVGElementSize(r.node(), { useBBox: !0 });
      return n.remove(), { width: i, height: s };
    }, this.normalizeFlatData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = x(n, "radar", "axes"), s = x(n, "data", "groupMapsTo"), a = ED(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((l) => ({
          [r]: o,
          [s]: l,
          [i]: null
        })))
      );
      return ct(a, t);
    }, this.normalizeGroupedData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = x(n, "radar", "axes"), s = x(n, "data", "groupMapsTo");
      return t.map(({ name: a, data: o }) => {
        const l = this.uniqueKeys.map((c) => ({
          [s]: a,
          [r]: c,
          [i]: null
        }));
        return { name: a, data: ct(l, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (r) => r.name !== n.datum().name ? sr.opacity.unselected : sr.opacity.selected).style("stroke-opacity", (r) => r.name !== n.datum().name ? sr.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", sr.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer(), { width: r, height: i } = N.getSVGElementSize(n, {
      useAttrs: !0
    }), s = this.model.getData(), a = this.model.getGroupedData(), o = this.getOptions(), l = x(o, "data", "groupMapsTo"), c = x(o, "radar", "axes", "value"), { angle: u, value: d } = x(o, "radar", "axes"), { xLabelPadding: h, yLabelPadding: f, yTicksNumber: p, minRange: v, xAxisRectHeight: m } = sr;
    this.uniqueKeys = Array.from(new Set(s.map((E) => E[u]))), this.uniqueGroups = Array.from(new Set(s.map((E) => E[l]))), this.fullDataNormalized = this.normalizeFlatData(s), this.groupedDataNormalized = this.normalizeGroupedData(a);
    const y = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + f), g = (Math.min(r, i) - y) / 2;
    if (g <= 0)
      return;
    const b = Ds().domain(this.fullDataNormalized.map((E) => E[u])).range([0, 2 * Math.PI].map((E) => E - Math.PI / 2)), w = Zn(this.fullDataNormalized.map((E) => E[d])), _ = Ke().domain([
      w >= 0 ? 0 : w,
      gr(this.fullDataNormalized.map((E) => E[d]))
    ]).range([v, g]).nice(p), S = _.ticks(p), L = (E, A, $) => this.model.getFillColor(E, A, $), D = nO().angle((E) => b(E[u]) + Math.PI / 2).radius((E) => _(E[d])).curve(Ag), k = this.uniqueKeys.map((E) => {
      const A = this.getLabelDimensions(E).width, $ = PR(
        b(E),
        g
      );
      return A + $;
    }), R = {
      x: gr(k) + h,
      y: i / 2
    }, M = N.appendOrSelect(n, "g.y-axes").attr("role", ht.GROUP).selectAll("path").data(S, (E) => E), V = (E) => this.uniqueKeys.map((A) => ({ [u]: A, [d]: E }));
    M.join(
      (E) => E.append("path").attr("opacity", 0).attr("transform", `translate(${R.x}, ${R.y})`).attr("fill", "none").call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", ($) => D(V($)))
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", ($) => D(V($)))
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", ($) => D(V($))).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.x-axes").attr("role", ht.GROUP).selectAll("line").data(this.uniqueKeys, (E) => E).join(
      (E) => E.append("line").attr("opacity", 0).attr("class", (A) => `x-axis-${Pr(A)}`).attr("stroke-dasharray", "0").attr("x1", (A) => Yt(b(A), 0, R).x).attr("y1", (A) => Yt(b(A), 0, R).y).attr("x2", (A) => Yt(b(A), 0, R).x).attr("y2", (A) => Yt(b(A), 0, R).y).call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", ($) => Yt(b($), _.range()[0], R).x).attr("y1", ($) => Yt(b($), _.range()[0], R).y).attr("x2", ($) => Yt(b($), _.range()[1], R).x).attr("y2", ($) => Yt(b($), _.range()[1], R).y)
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", ($) => Yt(b($), _.range()[0], R).x).attr("y1", ($) => Yt(b($), _.range()[0], R).y).attr("x2", ($) => Yt(b($), _.range()[1], R).x).attr("y2", ($) => Yt(b($), _.range()[1], R).y)
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.x-labels").attr("role", ht.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (E) => E.append("text").text((A) => A).attr("opacity", 0).attr(
        "x",
        (A) => Yt(b(A), _.range()[1] + h, R).x
      ).attr(
        "y",
        (A) => Yt(b(A), _.range()[1] + h, R).y
      ).style("text-anchor", (A) => If(b(A)).textAnchor).style(
        "dominant-baseline",
        (A) => If(b(A)).dominantBaseline
      ).call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          ($) => Yt(b($), _.range()[1] + h, R).x
        ).attr(
          "y",
          ($) => Yt(b($), _.range()[1] + h, R).y
        ).end().finally(() => {
          const $ = x(o, "radar", "alignment"), U = this.getAlignmentXOffset($, n, this.getParent());
          n.attr("x", U);
        })
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), N.appendOrSelect(n, "g.blobs").attr("role", ht.GROUP).selectAll("path").data(this.groupedDataNormalized, (E) => E.name).join(
      (E) => E.append("path").attr(
        "class",
        (A) => this.model.getColorClassName({
          classNameTypes: [st.FILL, st.STROKE],
          dataGroupName: A.name,
          originalClassName: "blob"
        })
      ).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (A) => A.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})` : `translate(${R.x}, ${R.y})`
      ).style("fill", (A) => L(A.name, null, A.data)).style("fill-opacity", sr.opacity.selected).style("stroke", (A) => L(A.name, null, A.data)).call((A) => {
        const $ = A.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && $.delay(() => Math.random() * 30).attr("transform", `translate(${R.x}, ${R.y})`), $.attr("opacity", 1).attr("d", (U) => D(U.data));
      }),
      (E) => (E.attr(
        "class",
        (A) => this.model.getColorClassName({
          classNameTypes: [st.FILL, st.STROKE],
          dataGroupName: A.name,
          originalClassName: "blob"
        })
      ).style("fill", (A) => L(A.name, null, A.data)).style("stroke", (A) => L(A.name, null, A.data)), E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${R.x}, ${R.y})`).attr("d", ($) => D($.data))
      ), E),
      (E) => E.call((A) => {
        const $ = A.transition().call(
          (U) => this.services.transitions.setupTransition({
            transition: U,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && $.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${R.x}, ${R.y}) scale(${1 + Math.random() * 0.35})`
        ), $.attr("opacity", 0).remove();
      })
    ), N.appendOrSelect(n, "g.dots").attr("role", ht.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((E) => x(E, d) !== null)).join(
      (E) => E.append("circle").attr("role", ht.GRAPHICS_SYMBOL).attr("aria-label", (A) => A[c]),
      (E) => E,
      (E) => E.remove()
    ).attr(
      "class",
      (E) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: E[l],
        originalClassName: Pr(E[u])
      })
    ).attr("cx", (E) => Yt(b(E[u]), _(E[d]), R).x).attr("cy", (E) => Yt(b(E[u]), _(E[d]), R).y).attr("r", 0).attr("opacity", 0).style("fill", (E) => L(E[l])), N.appendOrSelect(n, "g.x-axes-rect").attr("role", ht.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (E) => E.append("rect"),
      (E) => E,
      (E) => E.remove()
    ).attr("x", R.x).attr("y", R.y - m / 2).attr("width", _.range()[1]).attr("height", m).style("fill", "red").style("fill-opacity", 0).attr("transform", (E) => `rotate(${Wv(b(E))}, ${R.x}, ${R.y})`);
    const { code: P, number: H } = x(o, "locale");
    N.appendOrSelect(n, "g.y-labels").attr("role", ht.GROUP).selectAll("text").data(Ye(S)).join(
      (E) => E.append("text").attr("opacity", 0).text((A) => H(A, P)).attr(
        "x",
        (A) => Yt(-Math.PI / 2, _(A), R).x + f
      ).attr("y", (A) => Yt(-Math.PI / 2, _(A), R).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text(($) => $).attr("opacity", 1).attr(
          "x",
          ($) => Yt(-Math.PI / 2, _($), R).x + f
        ).attr("y", ($) => Yt(-Math.PI / 2, _($), R).y)
      ),
      (E) => E.call(
        (A) => A.transition().call(
          ($) => this.services.transitions.setupTransition({
            transition: $,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, n, r) {
    const i = N.getSVGElementSize(n, {
      useBBox: !0
    }), { width: s } = N.getSVGElementSize(r, {
      useAttrs: !0
    });
    let a = 0;
    return t === ee.CENTER ? a = Math.floor((s - i.width) / 2) : t === ee.RIGHT && (a = s - i.width), a;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: n }
    } = x(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEOVER, {
        event: r,
        element: s,
        datum: i
      });
      const a = t.parent.select(`.x-axes .x-axis-${Pr(i)}`), o = t.parent.selectAll(`.dots circle.${Pr(i)}`), l = t.model.getActiveDataGroupNames(), c = t.getOptions(), { groupMapsTo: u } = c.data, d = x(c, "radar", "axes", "value");
      a.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (f) => l.indexOf(f[u]) !== -1 ? 1 : 0
      ).attr("r", sr.dotsRadius);
      const h = t.fullDataNormalized.filter(
        (f) => f[n] === i && l.indexOf(f[u]) !== -1
      );
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: r,
        hoveredElement: s,
        items: h.filter((f) => typeof f[d] == "number").map((f) => ({
          label: f[u],
          value: f[d],
          color: t.model.getFillColor(f[u], null, f),
          class: t.model.getColorClassName({
            classNameTypes: [st.TOOLTIP],
            dataGroupName: f[u]
          })
        }))
      });
    }).on("mousemove", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEMOVE, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(O.Radar.X_AXIS_CLICK, {
        event: r,
        element: I(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = I(this), a = t.parent.select(`.x-axes .x-axis-${Pr(i)}`), o = t.parent.selectAll(`.dots circle.${Pr(i)}`);
      a.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
}
class D0 extends hh {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getOrientation(), o = i.selectAll("path.bar").data(s, (l) => l[r]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: l[r],
        originalClassName: "bar"
      })
    ).style("fill", (l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l);
      return this.model.getFillColor(l[r], l[c], l);
    }).attr("d", (l) => {
      const c = this.services.cartesianScales.getRangeIdentifier(), u = this.getBarWidth(), d = l[c], h = this.services.cartesianScales.getDomainValue(l) - u / 2, f = h + u;
      let p, v;
      if (Array.isArray(d) && d.length === 2)
        p = this.services.cartesianScales.getRangeValue(d[0]), v = this.services.cartesianScales.getRangeValue(d[1]);
      else {
        const y = this.services.cartesianScales.getRangeScale().domain()[0];
        p = this.services.cartesianScales.getRangeValue(Math.max(0, y)), v = this.services.cartesianScales.getRangeValue(l);
      }
      const m = Math.abs(v - p);
      if (m !== 0 && m < 2 && (d > 0 && a === te.VERTICAL || d < 0 && a === te.HORIZONTAL ? v = p - 2 : v = p + 2), !this.isOutsideZoomedDomain(h, f))
        return de({ x0: h, x1: f, y0: p, y1: v }, a);
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {
      const i = I(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        data: [r]
      });
    }).on("mousemove", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: n,
        element: I(this),
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class HN extends pe {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = x(this.getOptions(), "data", "loading"), r = !x(this.getOptions(), "grid", "x", "enabled") && !x(this.getOptions(), "grid", "y", "enabled") && !x(this.getOptions(), "axes", "bottom", "visible") && !x(this.getOptions(), "axes", "left", "visible");
    n && !r ? super.renderGridSkeleton(n) : n && r ? this.renderSparklineSkeleton(n) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const n = this.backdrop.attr("width"), r = [100], i = N.appendOrSelect(this.backdrop, "g.y.skeleton"), s = i.selectAll("line").data(r);
    s.enter().append("line").merge(s).attr("x1", 0).attr("x2", n).attr("y1", (a) => a).attr("y2", (a) => a), i.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = N.appendOrSelect(t, "svg.chart-skeleton.DAII"), N.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class I0 extends yt {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-area"
        })
      ).attr("opacity", (s) => x(s, 0, i) !== n.datum().name ? On.opacity.unselected : On.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", On.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this, i = this.getOptions(), { groupMapsTo: s } = i.data, a = Object.keys(i.axes).some((f) => i.axes[f].percentage), o = this.model.getStackedData({
      percentage: a,
      groups: this.configs.groups
    }), l = x(o, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), u = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), d = this.services.cartesianScales.getScaleByPosition(u), h = n.selectAll("path.area").data(o, (f) => x(f, 0, s));
    this.areaGenerator = Nu().x(
      (f) => this.services.cartesianScales.getValueThroughAxisPosition(
        c,
        f.data.sharedStackKey
      )
    ).y0((f) => d(f[0])).y1((f) => d(f[1])).curve(this.services.curves.getD3Curve()), h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).data(o, (f) => x(f, 0, s)).attr("class", "area").attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: x(f, 0, s),
        originalClassName: "area"
      })
    ).style("fill", (f) => r.model.getFillColor(x(f, 0, s), null, f)).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (f) => x(f, 0, s)).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", On.opacity.selected).attr("d", this.areaGenerator);
  }
}
class N0 extends hh {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), a = this.model.getActiveDataGroupNames(), o = n.selectAll("g.bars").data(s, (c) => x(c, 0, i));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", ht.GROUP).attr("data-name", "bars");
    const l = n.selectAll("g.bars").selectAll("path.bar").data(
      (c) => c,
      (c) => c.data.sharedStackKey
    );
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: c[i],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (c) => this.model.getFillColor(c[i], c.data.sharedStackKey, c.data)
    ).attr("d", (c) => {
      const u = c.data.sharedStackKey, d = this.getBarWidth(), h = this.services.cartesianScales.getDomainValue(u) - d / 2, f = h + d, p = this.services.cartesianScales.getRangeValue(c[0]);
      let v = this.services.cartesianScales.getRangeValue(c[1]);
      if (!this.isOutsideZoomedDomain(h, f)) {
        if (Math.abs(v - p) > 0 && Math.abs(v - p) > r.bars.dividerSize) {
          const m = c[0] < 0 && c[1] <= 0;
          m && a.length > 1 ? this.services.cartesianScales.getOrientation() === te.VERTICAL ? v += c[1] === 0 ? 2 : 1 : v -= 1 : m || (this.services.cartesianScales.getOrientation() === te.VERTICAL ? v += 1 : v -= 1);
        }
        return de(
          { x0: h, x1: f, y0: p, y1: v },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", ht.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this;
    this.parent.selectAll("path.bar").on("mouseover", function(i, s) {
      const a = I(this);
      a.classed("hovered", !0), r.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      });
      let o = r.model.getDisplayData(r.configs.groups).find((l) => {
        const c = r.services.cartesianScales.getDomainIdentifier(l), u = r.services.cartesianScales.getRangeIdentifier(l);
        return l[u] === s.data[s[n]] && l[c].toString() === s.data.sharedStackKey && l[n] === s[n];
      });
      if (o === void 0) {
        const l = r.services.cartesianScales.getDomainIdentifier(), c = r.services.cartesianScales.getRangeIdentifier();
        o = {
          [l]: s.data.sharedStackKey,
          [c]: s.data[s[n]],
          [n]: s[n]
        };
      }
      r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        data: [o]
      });
    }).on("mousemove", function(i, s) {
      const a = I(this);
      r.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      r.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: i,
        element: I(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = I(this);
      a.classed("hovered", !1), r.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (x(t, "bars", "width"))
      return t.bars.width;
    const n = this.services.cartesianScales.getMainXScale(), r = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, i = this.model.getStackKeys().length, s = x(t, "bars", "spacingFactor");
    return n.step ? Math.min(t.bars.maxWidth, n.step() / 2) : Math.min(t.bars.maxWidth, r * s / i);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class P0 extends hn {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = rt.SVG;
  }
  render(t) {
    if (!x(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((u) => r.axes[u].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = n.selectAll("g.dots").data(a, (u) => x(u, 0, i));
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("dots", !0).attr("role", ht.GROUP).merge(o).selectAll("circle.dot").data((u) => u);
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l).datum((u) => {
      const d = u[i], h = this.services.cartesianScales.getDomainIdentifier(u), f = this.services.cartesianScales.getRangeIdentifier(u);
      return {
        [i]: d,
        [h]: u.data.sharedStackKey,
        [f]: u[1]
      };
    });
    this.styleCircles(c, t), this.addEventListeners();
  }
  getTooltipData(t, n) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((l) => r.axes[l].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = [];
    return a.forEach((l, c) => {
      l.forEach((u, d) => {
        const h = u[i], f = u.data.sharedStackKey;
        let p = u.data[h];
        const v = u[1], m = this.services.cartesianScales.getDomainIdentifier(u), y = this.services.cartesianScales.getRangeIdentifier(u);
        p != null && t === this.services.cartesianScales.getDomainValue(f) && n === this.services.cartesianScales.getRangeValue(v) && (s && (p = this.model.getStackedData({
          groups: this.configs.groups
        })[c][d].data[h]), p !== null && o.push({
          [i]: h,
          [m]: f,
          [y]: p
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l), u = this.services.cartesianScales.getRangeIdentifier(l);
      return o.find((d) => d[i] == l[i] && d[c] == l[c] && d[u] == l[u]) !== void 0;
    });
  }
}
const Br = 6;
class VN extends yt {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = rt.SVG;
  }
  getLongestLabel(t) {
    let n = "";
    return t.forEach((r) => {
      const i = r.children ? this.getLongestLabel(r.children) : "";
      (i.length > n.length || r.name.length > n.length) && (n = i.length > r.name.length ? i : r.name);
    }), n;
  }
  getMockLabelWidth(t, n) {
    const r = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(n), { width: i } = N.getSVGElementSize(r.node(), {
      useBBox: !0
    });
    return r.remove(), i;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer();
    n.html("");
    const { width: r, height: i } = N.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = x(s, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(n, o), c = this.getLongestLabel(a), u = this.getMockLabelWidth(n, c), d = {
      top: 0,
      right: 0,
      bottom: 0,
      left: l > 0 ? l + Br : 30 - Br
    }, h = ks({
      name: o,
      children: a
    }), f = 10, p = r / 6, v = (S) => {
      const L = h.descendants().reverse(), D = h.links();
      let k = h, R = h;
      h.eachBefore((U) => {
        U.x < k.x && (k = U), U.x > R.x && (R = U);
      });
      const M = R.x - k.x, V = n.transition().call(
        (U) => this.services.transitions.setupTransition({
          transition: U,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-d.left, k.x, r, M].join(" ")), P = _.selectAll("g").data(L, (U) => U.id), H = this, E = P.enter().append("g").attr("transform", () => `translate(${S.y0},${S.x0})`).attr(
        "class",
        (U) => U.depth !== 0 && U.children && U.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(U, B) {
        H.services.events.dispatchEvent(O.Tree.NODE_MOUSEOVER, {
          event: U,
          element: I(this),
          datum: B
        });
      }).on("click", function(U, B) {
        B.depth !== 0 && (B.children = B.children ? null : B._children, v(B)), H.services.events.dispatchEvent(O.Tree.NODE_CLICK, {
          event: U,
          element: I(this),
          datum: B
        });
      }).on("mouseout", function(U, B) {
        H.services.events.dispatchEvent(O.Tree.NODE_MOUSEOUT, {
          event: U,
          element: I(this),
          datum: B
        });
      });
      E.append("circle").attr("r", 2.5).attr("class", (U) => U._children ? "parent" : "child").attr("stroke-width", 10), E.append("text").attr("dy", "0.31em").attr("x", (U) => U._children ? -Br : Br).attr("text-anchor", (U) => U._children ? "end" : "start").text((U) => U.data.name).clone(!0).attr("class", "text-stroke").lower(), P.merge(E).transition(V).attr("transform", (U) => `translate(${U.y},${U.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), P.exit().transition(V).remove().attr("transform", () => `translate(${S.y},${S.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const A = w.selectAll("path").data(D, (U) => U.target.id), $ = A.enter().append("path").attr("d", () => {
        const U = { x: S.x0, y: S.y0 };
        return b({ source: U, target: U });
      });
      A.merge($).transition(V).attr("d", b), A.exit().transition(V).remove().attr("d", () => {
        const U = { x: S.x, y: S.y };
        return b({ source: U, target: U });
      }), h.eachBefore((U) => {
        U.x0 = U.x, U.y0 = U.y;
      });
    }, m = h.descendants(), y = m[m.length - 1].depth, g = x(s, "tree", "type") === lu.DENDROGRAM ? x_().size([
      i,
      r - u - y * Br - l
    ]) : aw().nodeSize([f, p]).size([
      i,
      r - u - y * Br - l
    ]), b = lO().x((S) => S.y).y((S) => S.x);
    h.x0 = p / 2, h.y0 = 0, h.descendants().forEach((S, L) => {
      S.id = L, S._children = S.children;
    }), g(h), n.attr("viewBox", [-d.left, -d.top, r, f]).style("user-select", "none");
    const w = n.append("g").attr("class", "links"), _ = n.append("g").attr("class", "nodes");
    v(h);
  }
}
var FN = "#000000", zN = "#ffffff", GN = "#fcf4d6", jN = "#fddc69", WN = "#f1c21b", qN = "#d2a106", YN = "#b28600", XN = "#8e6a00", ZN = "#684e00", KN = "#483700", QN = "#302400", JN = "#1c1500", tP = {
  10: GN,
  20: jN,
  30: WN,
  40: qN,
  50: YN,
  60: XN,
  70: ZN,
  80: KN,
  90: QN,
  100: JN
}, eP = "#fff2e8", nP = "#ffd9be", rP = "#ffb784", iP = "#ff832b", sP = "#eb6200", aP = "#ba4e00", oP = "#8a3800", lP = "#5e2900", cP = "#3e1a00", uP = "#231000", hP = {
  10: eP,
  20: nP,
  30: rP,
  40: iP,
  50: sP,
  60: aP,
  70: oP,
  80: lP,
  90: cP,
  100: uP
}, dP = "#fff1f1", fP = "#ffd7d9", pP = "#ffb3b8", mP = "#ff8389", gP = "#fa4d56", vP = "#da1e28", yP = "#a2191f", xP = "#750e13", bP = "#520408", EP = "#2d0709", _P = {
  10: dP,
  20: fP,
  30: pP,
  40: mP,
  50: gP,
  60: vP,
  70: yP,
  80: xP,
  90: bP,
  100: EP
}, wP = "#fff0f7", SP = "#ffd6e8", OP = "#ffafd2", TP = "#ff7eb6", MP = "#ee5396", CP = "#d02670", AP = "#9f1853", $P = "#740937", LP = "#510224", RP = "#2a0a18", kP = {
  10: wP,
  20: SP,
  30: OP,
  40: TP,
  50: MP,
  60: CP,
  70: AP,
  80: $P,
  90: LP,
  100: RP
}, DP = "#f6f2ff", IP = "#e8daff", NP = "#d4bbff", PP = "#be95ff", UP = "#a56eff", BP = "#8a3ffc", HP = "#6929c4", VP = "#491d8b", FP = "#31135e", zP = "#1c0f30", GP = {
  10: DP,
  20: IP,
  30: NP,
  40: PP,
  50: UP,
  60: BP,
  70: HP,
  80: VP,
  90: FP,
  100: zP
}, jP = "#edf5ff", WP = "#d0e2ff", qP = "#a6c8ff", YP = "#78a9ff", XP = "#4589ff", ZP = "#0f62fe", KP = "#0043ce", QP = "#002d9c", JP = "#001d6c", tU = "#001141", eU = {
  10: jP,
  20: WP,
  30: qP,
  40: YP,
  50: XP,
  60: ZP,
  70: KP,
  80: QP,
  90: JP,
  100: tU
}, nU = "#e5f6ff", rU = "#bae6ff", iU = "#82cfff", sU = "#33b1ff", aU = "#1192e8", oU = "#0072c3", lU = "#00539a", cU = "#003a6d", uU = "#012749", hU = "#061727", dU = {
  10: nU,
  20: rU,
  30: iU,
  40: sU,
  50: aU,
  60: oU,
  70: lU,
  80: cU,
  90: uU,
  100: hU
}, fU = "#d9fbfb", pU = "#9ef0f0", mU = "#3ddbd9", gU = "#08bdba", vU = "#009d9a", yU = "#007d79", xU = "#005d5d", bU = "#004144", EU = "#022b30", _U = "#081a1c", wU = {
  10: fU,
  20: pU,
  30: mU,
  40: gU,
  50: vU,
  60: yU,
  70: xU,
  80: bU,
  90: EU,
  100: _U
}, SU = "#defbe6", OU = "#a7f0ba", TU = "#6fdc8c", MU = "#42be65", CU = "#24a148", AU = "#198038", $U = "#0e6027", LU = "#044317", RU = "#022d0d", kU = "#071908", DU = {
  10: SU,
  20: OU,
  30: TU,
  40: MU,
  50: CU,
  60: AU,
  70: $U,
  80: LU,
  90: RU,
  100: kU
}, IU = "#f2f4f8", NU = "#dde1e6", PU = "#c1c7cd", UU = "#a2a9b0", BU = "#878d96", HU = "#697077", VU = "#4d5358", FU = "#343a3f", zU = "#21272a", GU = "#121619", jU = {
  10: IU,
  20: NU,
  30: PU,
  40: UU,
  50: BU,
  60: HU,
  70: VU,
  80: FU,
  90: zU,
  100: GU
}, WU = "#f4f4f4", qU = "#e0e0e0", YU = "#c6c6c6", XU = "#a8a8a8", ZU = "#8d8d8d", KU = "#6f6f6f", QU = "#525252", JU = "#393939", tB = "#262626", eB = "#161616", nB = {
  10: WU,
  20: qU,
  30: YU,
  40: XU,
  50: ZU,
  60: KU,
  70: QU,
  80: JU,
  90: tB,
  100: eB
}, rB = "#f7f3f2", iB = "#e5e0df", sB = "#cac5c4", aB = "#ada8a8", oB = "#8f8b8b", lB = "#726e6e", cB = "#565151", uB = "#3c3838", hB = "#272525", dB = "#171414", fB = {
  10: rB,
  20: iB,
  30: sB,
  40: aB,
  50: oB,
  60: lB,
  70: cB,
  80: uB,
  90: hB,
  100: dB
}, gp = {
  black: {
    100: FN
  },
  blue: eU,
  coolGray: jU,
  cyan: dU,
  gray: nB,
  green: DU,
  magenta: kP,
  orange: hP,
  purple: GP,
  red: _P,
  teal: wU,
  warmGray: fB,
  white: {
    0: zN
  },
  yellow: tP
};
const pB = (e) => {
  if (!e)
    return null;
  for (const t of Object.keys(gp)) {
    const n = gp[t];
    for (const r of Object.keys(n))
      if (n[+r] === e)
        return r;
  }
  return null;
}, vp = function() {
  const e = I(this.parentNode).select("rect.leaf"), t = getComputedStyle(e.node(), null).getPropertyValue(
    "fill"
  ), n = $n(t);
  let r;
  if (n && (r = pB(n ? n.hex() : null)), r == null) {
    const i = gu(n).l;
    r = Math.abs(i * 100 - 100);
  }
  return r > 50 ? "white" : "black";
};
let mB = 0;
class gB extends yt {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (r) => r.parent.data.name === n.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer();
    this.model.getData();
    const r = this.model.getDisplayData(), i = this.model.getOptions(), s = x(window, "location"), { width: a, height: o } = N.getSVGElementSize(n, {
      useAttrs: !0
    }), l = ks({
      name: i.title || "Treemap",
      children: r
    }).sum((f) => f.value).sort((f, p) => p.value - f.value), c = hw().size([a, o]).paddingInner(1).paddingOuter(0).round(!0)(
      l
    ), u = n.selectAll("g[data-name='leaf']").data(c.leaves(), (f) => f.data.name);
    u.exit().attr("opacity", 0).remove();
    const d = u.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => mB++).merge(u);
    d.attr("data-name", "leaf").transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (f) => `translate(${f.x0},${f.y0})`);
    const h = d.selectAll("rect.leaf").data((f) => [f]);
    h.exit().attr("width", 0).attr("height", 0).remove(), h.enter().append("rect").classed("leaf", !0).merge(h).attr("width", 0).attr("height", 0).attr("id", function() {
      const f = I(this.parentNode).attr("data-uid");
      return `${i.style.prefix}-leaf-${f}`;
    }).attr("class", (f) => {
      for (; f.depth > 1; )
        f = f.parent;
      return this.model.getColorClassName({
        classNameTypes: [st.FILL],
        dataGroupName: f.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (f) => f.x1 - f.x0).attr("height", (f) => f.y1 - f.y0).style("fill", (f) => {
      for (; f.depth > 1; )
        f = f.parent;
      return this.model.getFillColor(f.data.name, null, f.data);
    }), d.selectAll("clipPath").data(
      (f) => f.data.showLabel !== !0 ? [] : [1],
      (f) => f
    ).join(
      (f) => f.append("clipPath").attr("id", function() {
        const p = I(this.parentNode).attr("data-uid");
        return `${i.style.prefix}-clip-${p}`;
      }).append("use").attr("xlink:href", function() {
        const p = I(this.parentNode.parentNode).attr("data-uid"), v = `${i.style.prefix}-leaf-${p}`;
        return new URL(`#${v}`, s) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (f) => null,
      (f) => f.remove()
    ), d.selectAll("text").data(
      (f) => {
        if (f.data.showLabel !== !0)
          return [];
        let p = f;
        for (; p.depth > 1; )
          p = p.parent;
        const v = gu(this.model.getFillColor(p.data.name));
        return [
          {
            text: f.data.name,
            color: v.l < 0.5 ? "white" : "black"
          }
        ];
      },
      (f) => f
    ).join(
      (f) => {
        const p = f.append("text").text((v) => v.text).style("fill", vp).attr("x", 7).attr("y", 18);
        return s && p.attr("clip-path", function() {
          const v = I(this.parentNode).attr("data-uid"), m = `${i.style.prefix}-clip-${v}`;
          return `url(${new URL(`#${m}`, s) + ""})`;
        }), p;
      },
      (f) => f.text((p) => p.text).style("fill", vp),
      (f) => f.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(n, r) {
      const i = I(this);
      let s = getComputedStyle(this, null).getPropertyValue("fill"), a = r;
      for (; a.depth > 1; )
        a = a.parent;
      i.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const l = t.model.getFillColor(o.parent.data.name, null, o.data);
        return l && (s = l), $n(s).darker(0.7).toString();
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            color: s,
            label: a.data.name,
            bold: !0
          },
          {
            label: r.data.name,
            value: r.data.value
          }
        ]
      }), t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = I(this);
      t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Treemap.LEAF_CLICK, {
        event: n,
        element: I(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = I(this);
      i.classed("hovered", !1);
      let s = r;
      for (; s.depth > 1; )
        s = s.parent;
      i.transition().call(
        (a) => t.services.transitions.setupTransition({
          transition: a,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (a) => t.model.getFillColor(a.parent.data.name, null, a.data)), t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
}
class vB extends yt {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = rt.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), i = this.model.getDisplayData(), s = this.getFontSizeScale(i), a = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: l } = a.wordCloud, { groupMapsTo: c } = a.data, { width: u, height: d } = N.getSVGElementSize(r, {
      useAttrs: !0
    });
    if (u === 0 || d === 0)
      return;
    const h = Sk().size([u, d]).words(
      i.map(function(p) {
        const v = p[o];
        if (typeof p[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [c]: p[c],
          text: p[l],
          size: v,
          value: v
        };
      })
    ).padding(5).rotate(0).fontSize((p) => s(p.size)).on("end", f);
    h.start();
    function f(p) {
      const v = N.appendOrSelect(r, "g.words");
      v.attr("transform", `translate(${h.size()[0] / 2}, ${h.size()[1] / 2})`);
      const m = v.selectAll("text").data(p, (y) => `${y[c]}-${y.text}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("text").attr("opacity", 0).merge(m).style("font-size", (y) => `${y.size}px`).text(function(y) {
        return y.text;
      }).attr(
        "class",
        (y) => n.model.getColorClassName({
          classNameTypes: [st.FILL],
          dataGroupName: y[c],
          originalClassName: `word ${y.size > 32 ? "light" : ""}`
        })
      ).style("fill", (y) => n.model.getFillColor(y[c], y.text, y)).attr("text-anchor", "middle").transition().call(
        (y) => n.services.transitions.setupTransition({
          transition: y,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (y) => `translate(${y.x}, ${y.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const n = this.getOptions(), { fontSizeMapsTo: r } = n.wordCloud, i = t.map((l) => l[r]).filter((l) => l), s = N.getHTMLElementSize(this.services.domUtils.getMainContainer()), a = i.length > 0, o = a ? Ye(i) : [1, 1];
    return Ke().domain(o).range(a ? n.wordCloud.fontSizeRange(s, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = po((s) => {
      const a = r.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => r.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      s === null ? a.attr("opacity", 1) : a.attr("opacity", function() {
        return s === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(s, a) {
      const o = this;
      i(o), r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEOVER, {
        event: s,
        element: I(this),
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: a.text
          },
          {
            label: t.tooltip.valueLabel,
            value: a.value
          },
          {
            label: _t(t, "locale.translations.group") || _t(t, "tooltip.groupLabel") || "Group",
            value: a[n],
            class: r.model.getColorClassName({
              classNameTypes: [st.TOOLTIP],
              dataGroupName: a[n]
            })
          }
        ]
      });
    }).on("mousemove", function(s, a) {
      const o = I(this);
      r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(O.WordCloud.WORD_CLICK, {
        event: s,
        element: I(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = I(this);
      i(null), r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class yB extends yt {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = rt.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: r } = N.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (n < 1 || r < 1)
      return;
    const i = this.getProjection(), s = x(this.getOptions(), "geoData"), a = this.model.getCombinedData(), o = {}, l = {};
    Object.keys(a).forEach((m) => {
      typeof a[m].value == "number" ? o[m] = a[m] : l[m] = a[m];
    });
    const c = bN(s, Object.values(l)), u = vN(s, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), d = i.fitSize([n, r], u), h = jE().projection(d);
    N.appendOrSelect(t, "g.geo").selectAll("path").data(u.features).join("path").attr("d", h);
    const f = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), p = N.appendOrSelect(t, "defs");
    N.appendOrSelect(p, "pattern").attr("id", f).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Ns()([
        [0, 0],
        [0, 10]
      ])
    );
    const v = N.appendOrSelect(t, "g.missing-data");
    N.appendOrSelect(v, "path").datum(c).attr("d", h).style("fill", `url(#${f})`);
  }
  /**
   * @info
   * Depending on projection, we may need to provide additional configuration
   * e.g. sizing
   *
   * In such case, function can be refactored so that
   * projection should return an object with the configuraiton & function
   */
  getProjection() {
    let t = null;
    switch (x(this.getOptions(), "thematic", "projection")) {
      case _n.geoEqualEarth:
        t = u_();
        break;
      case _n.geoAlbers:
        t = r_();
        break;
      case _n.geoConicEqualArea:
        t = tg();
        break;
      case _n.geoConicEquidistant:
        t = l_();
        break;
      case _n.geoEquirectangular:
        t = a_();
        break;
      case _n.geoMercator:
        t = i_();
        break;
      case _n.geoNaturalEarth1:
        t = h_();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class xB extends yB {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const n = this.model.getCombinedData();
    this.getComponentContainer({ withinChartClip: !0 }).select("g.geo").selectAll("path").classed("border", !0).attr("class", (r) => this.model.getColorClassName({
      value: n[r.properties.NAME].value,
      originalClassName: "border"
    })), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, n = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(Gr.CHOROPLETH_MOUSEOVER, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(is.SHOW, {
        event: r,
        hoveredElement: s,
        items: [
          {
            label: i.properties.NAME,
            value: n[i.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(Gr.CHOROPLETH_MOUSEMOVE, {
        event: r,
        element: I(this),
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(is.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(Gr.CHOROPLETH_CLICK, {
        event: r,
        element: I(this),
        datum: n[i.properties.NAME]
      });
    }).on("mouseout", function(r, i) {
      const s = I(this);
      t.services.events.dispatchEvent(Gr.CHOROPLETH_MOUSEOUT, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(is.HIDE, {
        event: r,
        hoveredElement: s
      });
    });
  }
}
function dh(e) {
  var t = e == null ? 0 : e.length;
  return t ? jo(e, 1) : [];
}
function bB(e) {
  return Ug(Hg(e, void 0, dh), e + "");
}
function U0(e, t, n) {
  var r = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(i); ++r < i; )
    s[r] = e[r + t];
  return s;
}
function EB(e, t) {
  return t.length < 2 ? e : Zu(e, U0(t, 0, -1));
}
function _B(e, t) {
  return t = Go(t, e), e = EB(e, t), e == null || delete e[Vs(pv(t))];
}
function wB(e) {
  return Xg(e) ? void 0 : e;
}
var SB = 1, OB = 2, TB = 4, MB = bB(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var r = !1;
  t = Vu(t, function(s) {
    return s = Go(s, e), r || (r = s.length > 1), s;
  }), vi(e, ev(e), n), r && (n = ds(n, SB | OB | TB, wB));
  for (var i = t.length; i--; )
    _B(n, t[i]);
  return n;
});
let CB = class extends Bn {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(t, n, r) {
    let i, s, a;
    const o = r || Zr;
    t && (i = t.x, s = t.y, a = 2);
    const { width: l, height: c } = N.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    n.transition().duration(o.duration).ease(o.ease).attr(
      "transform",
      `translate(${l / 2}, ${c / 2}) scale(${a}) translate(${-i},${-s})`
    ), this.services.events.dispatchEvent(O.CanvasZoom.CANVAS_ZOOM_IN, {
      element: I(t)
    });
  }
  zoomOut(t, n) {
    const r = n || Zr;
    t.transition().duration(r.duration).ease(r.ease).attr("transform", ""), this.services.events.dispatchEvent(O.CanvasZoom.CANVAS_ZOOM_OUT);
  }
};
class AB extends Bn {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(t, n) {
    this.documentFragment.addEventListener(t, n);
  }
  removeEventListener(t, n) {
    this.documentFragment.removeEventListener(t, n);
  }
  dispatchEvent(t, n) {
    let r;
    n ? r = new CustomEvent(t, {
      detail: n
    }) : (r = document.createEvent("Event"), r.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(r);
  }
}
class $B extends Bn {
  constructor(t, n) {
    super(t, n);
  }
  downloadCSV(t, n) {
    const r = document.createElement("a"), i = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([t], {
          type: i
        }),
        n
      );
    else if (URL && "download" in r) {
      const s = URL.createObjectURL(
        new Blob([t], {
          type: i
        })
      );
      r.href = s, r.setAttribute("download", n), document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(s);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;
  }
  downloadImage(t, n) {
    const r = document.createElement("a");
    r.download = n, r.href = t, document.body.appendChild(r), r.click(), document.body.removeChild(r);
  }
}
class LB extends Bn {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    var t;
    (t = this.services.events) == null || t.addEventListener(O.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: t, name: n, animate: r }) {
    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {
      delete this.pendingTransitions[t._id];
    }), this.model.getOptions().animations === !1 || r === !1 ? t.duration(0) : t.duration(
      x(xf, n, "duration") || xf.default.duration
    );
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
function fs(e, t) {
  const n = St(e), r = St(t), i = n.getTime() - r.getTime();
  return i < 0 ? -1 : i > 0 ? 1 : i;
}
function RB(e, t) {
  const n = St(e), r = St(t);
  return n.getFullYear() - r.getFullYear();
}
function kB(e, t) {
  const n = St(e), r = St(t), i = fs(n, r), s = Math.abs(RB(n, r));
  n.setFullYear(1584), r.setFullYear(1584);
  const a = fs(n, r) === -i, o = i * (s - +a);
  return o === 0 ? 0 : o;
}
function fh(e, t) {
  const n = St(e);
  if (isNaN(t))
    return Qe(e, NaN);
  if (!t)
    return n;
  const r = n.getDate(), i = Qe(e, n.getTime());
  i.setMonth(n.getMonth() + t + 1, 0);
  const s = i.getDate();
  return r >= s ? i : (n.setFullYear(
    i.getFullYear(),
    i.getMonth(),
    r
  ), n);
}
function B0(e, t) {
  return fh(e, t * 12);
}
function DB(e, t) {
  return B0(e, -t);
}
function IB(e, t) {
  const n = St(e), r = St(t), i = n.getFullYear() - r.getFullYear(), s = n.getMonth() - r.getMonth();
  return i * 12 + s;
}
function NB(e) {
  const t = St(e);
  return t.setHours(23, 59, 59, 999), t;
}
function PB(e) {
  const t = St(e), n = t.getMonth();
  return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function UB(e) {
  const t = St(e);
  return +NB(t) == +PB(t);
}
function BB(e, t) {
  const n = St(e), r = St(t), i = fs(n, r), s = Math.abs(
    IB(n, r)
  );
  let a;
  if (s < 1)
    a = 0;
  else {
    n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30), n.setMonth(n.getMonth() - i * s);
    let o = fs(n, r) === -i;
    UB(St(e)) && s === 1 && fs(e, r) === 1 && (o = !1), a = i * (s - Number(o));
  }
  return a === 0 ? 0 : a;
}
function HB(e, t) {
  return fh(e, -t);
}
function VB(e, t) {
  const n = St(e), r = St(t), i = yp(n, r), s = Math.abs(Av(n, r));
  n.setDate(n.getDate() - i * s);
  const a = +(yp(n, r) === -i), o = i * (s - a);
  return o === 0 ? 0 : o;
}
function yp(e, t) {
  const n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function H0(e, t) {
  const n = St(e);
  return isNaN(t) ? Qe(e, NaN) : (t && n.setDate(n.getDate() + t), n);
}
function FB(e, t) {
  return H0(e, -t);
}
function ph(e) {
  return (t) => {
    const n = (e ? Math[e] : Math.trunc)(t);
    return n === 0 ? 0 : n;
  };
}
function mh(e, t) {
  return +St(e) - +St(t);
}
function zB(e, t, n) {
  const r = mh(e, t) / Cv;
  return ph(n == null ? void 0 : n.roundingMethod)(r);
}
function gh(e, t) {
  const n = +St(e);
  return Qe(e, n + t);
}
function V0(e, t) {
  return gh(e, t * Cv);
}
function GB(e, t) {
  return V0(e, -t);
}
function xp(e, t, n) {
  const r = mh(e, t) / Mv;
  return ph(n == null ? void 0 : n.roundingMethod)(r);
}
function ru(e, t) {
  return gh(e, t * Mv);
}
function bp(e, t) {
  return ru(e, -t);
}
function Ep(e, t, n) {
  const r = mh(e, t) / 1e3;
  return ph(n == null ? void 0 : n.roundingMethod)(r);
}
function iu(e, t) {
  return gh(e, t * 1e3);
}
function _p(e, t) {
  return iu(e, -t);
}
class jB extends Bn {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: t = null } = {}) {
    if (this.dualAxes && t) {
      const n = this.model.getOptions(), { groupMapsTo: r } = n.data, i = x(n, "axes", this.secondaryDomainAxisPosition), s = t[r];
      if (i != null && i.correspondingDatasets && i.correspondingDatasets.includes(s))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: t = null, groups: n = null } = {}) {
    if (this.dualAxes) {
      const r = this.model.getOptions(), { groupMapsTo: i } = r.data, s = x(r, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (t !== null ? a = t[i] : n && n.length > 0 && (a = n[0]), s != null && s.correspondingDatasets && s.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(t) {
    return x(this.model.getOptions(), "axes", t);
  }
  getDomainAxisOptions() {
    const t = this.getDomainAxisPosition();
    return this.getAxisOptions(t);
  }
  getRangeAxisOptions() {
    const t = this.getRangeAxisPosition();
    return this.getAxisOptions(t);
  }
  getScaleLabel(t) {
    return this.getAxisOptions(t).title || (t === F.BOTTOM || t === F.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(F).map(
      (t) => F[t]
    ).forEach((t) => {
      this.scales[t] = this.createScale(t);
    });
  }
  findDomainAndRangeAxes() {
    const t = this.findVerticalAxesPositions(), n = this.findHorizontalAxesPositions(), r = this.findDomainAndRangeAxesPositions(
      t,
      n
    );
    this.domainAxisPosition = r.primaryDomainAxisPosition, this.rangeAxisPosition = r.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = r.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = r.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === F.LEFT || this.rangeAxisPosition === F.RIGHT) && (this.domainAxisPosition === F.BOTTOM || this.domainAxisPosition === F.TOP) ? this.orientation = te.VERTICAL : this.orientation = te.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    var t, n, r, i;
    const s = this.model.getOptions(), a = x(s, "axes");
    ((t = a[F.LEFT]) != null && t.correspondingDatasets && a[F.RIGHT] || (n = a[F.RIGHT]) != null && n.correspondingDatasets && a[F.LEFT] || (r = a[F.TOP]) != null && r.correspondingDatasets && a[F.BOTTOM] || (i = a[F.BOTTOM]) != null && i.correspondingDatasets && a[F.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(t) {
    const n = x(this.model.getOptions(), "axes", t, "domain");
    if (n && !Array.isArray(n))
      throw new Error(`Domain in ${t} axis is not a valid array`);
    if (Array.isArray(n) && (this.scaleTypes[t] === et.LINEAR || this.scaleTypes[t] === et.TIME) && n.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`
      );
    return n;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(t) {
    return this.scales[t];
  }
  getScaleTypeByPosition(t) {
    return this.scaleTypes[t];
  }
  getDomainAxisScaleType() {
    const t = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getRangeAxisScaleType() {
    const t = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const t = [F.BOTTOM, F.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const t = [F.LEFT, F.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(t, n, r, i) {
    const s = this.model.getOptions(), a = x(s, "axes")[r], { mapsTo: o } = a, l = x(i, o) !== null ? i[o] : i;
    let c;
    switch (n) {
      case et.LABELS:
        c = t(l) + t.step() / 2;
        break;
      case et.TIME:
        c = t(new Date(l));
        break;
      default:
        c = t(l);
    }
    return c;
  }
  getBoundedScaledValues(t) {
    const { bounds: n } = this.model.getOptions(), r = this.getRangeAxisPosition({ datum: t }), i = this.scales[r], s = this.model.getOptions(), a = x(s, "axes")[r], { mapsTo: o } = a, l = t[o] !== void 0 ? t[o] : t;
    return [
      i(
        x(t, n.upperBoundMapsTo) !== null ? t[n.upperBoundMapsTo] : l
      ),
      i(
        x(t, n.lowerBoundMapsTo) !== null ? t[n.lowerBoundMapsTo] : l
      )
    ];
  }
  getValueThroughAxisPosition(t, n) {
    const r = this.scaleTypes[t], i = this.scales[t];
    return this.getValueFromScale(i, r, t, n);
  }
  getDomainValue(t) {
    const n = this.getDomainAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getRangeValue(t) {
    const n = this.getRangeAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(t) {
    const n = this.model.getOptions();
    return x(n, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");
  }
  getRangeIdentifier(t) {
    const n = this.model.getOptions();
    return x(n, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");
  }
  extendsDomain(t, n) {
    const r = this.model.getOptions(), i = x(r, "axes", t);
    if (i.scaleType === et.TIME) {
      const s = x(r, "timeScale", "addSpaceOnEdges");
      return WB(n, s);
    } else
      return qB(n, Xn.paddingRatio, i.scaleType);
  }
  findVerticalAxesPositions() {
    const t = this.model.getOptions(), n = x(t, "axes"), r = this.isDualAxes();
    return x(n, F.LEFT) === null && x(n, F.RIGHT) !== null || x(n, F.RIGHT, "main") === !0 || r && x(n, F.LEFT, "correspondingDatasets") ? {
      primary: F.RIGHT,
      secondary: F.LEFT
    } : { primary: F.LEFT, secondary: F.RIGHT };
  }
  findHorizontalAxesPositions() {
    const t = this.model.getOptions(), n = x(t, "axes"), r = this.isDualAxes();
    return x(n, F.BOTTOM) === null && x(n, F.TOP) !== null || x(n, F.TOP, "main") === !0 || r && x(n, F.BOTTOM, "correspondingDatasets") ? {
      primary: F.TOP,
      secondary: F.BOTTOM
    } : { primary: F.BOTTOM, secondary: F.TOP };
  }
  findDomainAndRangeAxesPositions(t, n) {
    const r = this.model.getOptions(), i = x(r, "axes", t.primary), s = x(r, "axes", n.primary), a = i.scaleType || et.LINEAR, o = s.scaleType || et.LINEAR, l = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return l.primaryDomainAxisPosition = n.primary, l.primaryRangeAxisPosition = t.primary, l.secondaryDomainAxisPosition = n.secondary, l.secondaryRangeAxisPosition = t.secondary, (!(o === et.LABELS || o === et.TIME) && a === et.LABELS || a === et.TIME) && (l.primaryDomainAxisPosition = t.primary, l.primaryRangeAxisPosition = n.primary, l.secondaryDomainAxisPosition = t.secondary, l.secondaryRangeAxisPosition = n.secondary), l;
  }
  getScaleDomain(t) {
    const n = this.model.getOptions(), r = x(n, "axes", t), i = x(n, "bounds"), { includeZero: s } = r, a = x(r, "scaleType") || et.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (r.binned) {
      const { bins: y } = this.model.getBinConfigurations();
      return [0, gr(y, (g) => g.length)];
    } else if (r.limitDomainToBins) {
      const { bins: y } = this.model.getBinConfigurations(), g = this.model.getStackKeys({ bins: y });
      return [g[0].split(":")[0], g[g.length - 1].split(":")[1]];
    }
    const o = this.model.getDisplayData(), { extendLinearDomainBy: l, mapsTo: c, percentage: u, thresholds: d } = r, { reference: h, compareTo: f } = Xn.ratio;
    if (r.domain)
      return a === et.LABELS ? r.domain : (a === et.TIME && (r.domain = r.domain.map(
        (y) => y.getTime === void 0 ? new Date(y) : y
      )), this.extendsDomain(t, r.domain));
    if (u)
      return [0, 100];
    if (r && a === et.LABELS)
      return Cs(o.map((y) => y[c]));
    let p, v;
    const m = this.model.getDataGroupNames();
    if (a === et.LABELS_RATIO)
      return o.map((y) => `${y[h]}/${y[f]}`);
    if (a === et.TIME)
      v = o.map((y) => +new Date(y[c]));
    else if (i && n.axes)
      v = [], o.forEach((y) => {
        v.push(y[c]), y[i.upperBoundMapsTo] && v.push(y[i.upperBoundMapsTo]), y[i.lowerBoundMapsTo] && v.push(y[i.lowerBoundMapsTo]);
      });
    else if (r.stacked === !0 && m && t === this.getRangeAxisPosition()) {
      const { groupMapsTo: y } = n.data, g = this.model.getDataValuesGroupedByKeys({
        groups: m
      }), b = o.filter(
        (_) => !m.includes(_[y])
      ), w = [];
      g.forEach((_) => {
        const { ...S } = _;
        let L = 0, D = 0;
        Object.values(MB(S, "sharedStackKey")).forEach((k) => {
          isNaN(k) || (k < 0 ? D += k : L += k);
        }), w.push([D, L]);
      }), v = [
        ...dh(w),
        ...b.map((_) => _[c])
      ];
    } else
      v = [], o.forEach((y) => {
        const g = y[c];
        Array.isArray(g) && g.length === 2 ? (v.push(g[0]), v.push(g[1])) : (l && v.push(Math.max(y[c], y[l])), v.push(g));
      });
    return a !== et.TIME && a !== et.LOG && s && v.push(0), d && d.length > 0 && d.forEach((y) => {
      const g = x(y, "value");
      g !== null && v.push(g);
    }), p = Ye(v), p = this.extendsDomain(t, p), p;
  }
  createScale(t) {
    const n = this.model.getOptions(), r = x(n, "axes", t);
    if (!r)
      return null;
    const i = x(r, "scaleType") || et.LINEAR;
    this.scaleTypes[t] = i;
    let s;
    return i === et.TIME ? s = yg() : i === et.LOG ? s = ug().base(r.base || 10) : i === et.LABELS || i === et.LABELS_RATIO ? s = Ds() : s = Ke(), s.domain(this.getScaleDomain(t)), s;
  }
  getDomainLowerBound(t) {
    let n, r = 0;
    return this.getOrientation() === te.VERTICAL ? n = this.getMainYScale().domain() : n = this.getMainXScale().domain(), x(this.model.getOptions(), "axes", t, "includeZero") === !1 && n[0] > 0 && n[1] > 0 && (r = n[0]), r;
  }
  getHighestDomainThreshold() {
    const t = x(this.model.getOptions(), "axes"), n = this.getDomainAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getDomainScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return this.getScaleTypeByPosition(n) === et.TIME && (typeof s.value == "string" || s.value.getTime === void 0) && (s.value = new Date(s.value)), {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
  getHighestRangeThreshold() {
    const t = x(this.model.getOptions(), "axes"), n = this.getRangeAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getRangeScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
}
function WB(e, t) {
  const n = new Date(e[0]), r = new Date(e[1]);
  return kB(r, n) > 1 ? [DB(n, t), B0(r, t)] : BB(r, n) > 1 ? [HB(n, t), fh(r, t)] : VB(r, n) > 1 ? [FB(n, t), H0(r, t)] : zB(r, n) > 1 ? [GB(n, t), V0(r, t)] : xp(r, n) > 30 ? [
    bp(n, t * 30),
    ru(r, t * 30)
  ] : xp(r, n) > 1 ? [bp(n, t), ru(r, t)] : Ep(r, n) > 15 ? [
    _p(n, t * 15),
    iu(r, t * 15)
  ] : Ep(r, n) > 1 ? [_p(n, t), iu(r, t)] : [n, r];
}
function qB([e, t], n, r) {
  const i = (t - e) * n, s = t <= 0 && t + i > 0 ? 0 : t + i;
  let a = e >= 0 && e - i < 0 ? 0 : e - i;
  if (r === et.LOG && a <= 0) {
    if (e <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    a = e;
  }
  return [a, s];
}
let YB = class extends Bn {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: Do,
      curveLinearClosed: Ag,
      curveBasis: cO,
      curveBasisClosed: uO,
      curveBasisOpen: hO,
      curveBundle: dO,
      curveCardinal: fO,
      curveCardinalClosed: pO,
      curveCardinalOpen: mO,
      curveCatmullRom: gO,
      curveCatmullRomClosed: vO,
      curveCatmullRomOpen: yO,
      curveMonotoneX: xO,
      curveMonotoneY: bO,
      curveNatural: EO,
      curveStep: _O,
      curveStepAfter: SO,
      curveStepBefore: wO
    };
  }
  getD3Curve() {
    let t = "curveLinear";
    const n = this.model.getOptions().curve;
    if (n && (typeof n == "string" ? t = n : t = n.name), this.curveTypes[t]) {
      let r = this.curveTypes[t];
      return n && Object.keys(n).forEach((i) => {
        r[i] && (r = r[i](n[i]));
      }), r;
    }
    return console.warn(`The curve type '${t}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}, XB = class extends Bn {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !x(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const t = this.services.cartesianScales.getMainXAxisPosition(), n = x(
      this.model.getOptions(),
      "axes",
      t,
      "scaleType"
    );
    return t === F.BOTTOM && n === et.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const t = this.model.getZoomBarData();
    return t && t.length > 1 ? t : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(t) {
    if (!this.services.zoom)
      throw new Error("Services zoom not defined");
    const n = t || this.services.zoom.getZoomBarData(), { cartesianScales: r } = this.services;
    if (!r)
      throw new Error("Services cartesianScales undefined");
    const i = r.getMainXAxisPosition(), s = r.getDomainIdentifier(), a = x(this.model.getOptions(), "axes", i, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!i)
      throw new Error("Not defined: mainXAxisPosition");
    return r.extendsDomain(
      i,
      Ye(n, (o) => o[s])
    );
  }
  handleDomainChange(t, n = { dispatchEvent: !0 }) {
    var r;
    this.model.set({ zoomDomain: t }, { animate: !1 }), n.dispatchEvent && ((r = this.services.events) == null || r.dispatchEvent(O.ZoomDomain.CHANGE, {
      newDomain: t
    }));
  }
  getZoomRatio() {
    return x(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(t, n) {
    var r;
    const i = this.model.get("zoomDomain"), s = Object.assign(
      { stacked: !1 },
      // default configs
      n
    ), a = x(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && a && i) {
      const o = s.stacked ? "sharedStackKey" : (r = this.services.cartesianScales) == null ? void 0 : r.getDomainIdentifier(), l = t.filter(
        (c) => new Date(c[o]) >= i[0] && new Date(c[o]) <= i[1]
      );
      if (l.length > 0)
        return l;
    }
    return t;
  }
  zoomIn(t = this.getZoomRatio()) {
    var n;
    const r = this.model.get("zoomDomain"), i = Te.handleWidth, s = (n = this.services.cartesianScales) == null ? void 0 : n.getMainXScale().copy();
    s.domain(this.getDefaultZoomBarDomain());
    const a = s(r[0]), o = s(r[1]);
    if (o - a < i + 1)
      return;
    const l = s.range(), c = o - a, u = Math.min((l[1] - l[0]) / 2 * (t / 2), c / 2);
    let d = a + u, h = o - u;
    d >= h && (d = a + c / 2 - i / 2, h = o - c / 2 + i / 2);
    const f = [s.invert(d), s.invert(h)];
    (r[0].valueOf() !== f[0].valueOf() || r[1].valueOf() !== f[1].valueOf()) && this.handleDomainChange(f);
  }
  zoomOut(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain");
    if (!this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const r = this.services.cartesianScales.getMainXScale().copy();
    r.domain(this.getDefaultZoomBarDomain());
    const i = r(n[0]), s = r(n[1]), a = r.range(), o = (a[1] - a[0]) / 2 * (t / 2), l = Math.max(i - o, a[0]), c = Math.min(s + o, a[1]), u = [r.invert(l), r.invert(c)];
    (n[0].valueOf() !== u[0].valueOf() || n[1].valueOf() !== u[1].valueOf()) && this.handleDomainChange(u);
  }
  resetZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    (t[0].valueOf() !== n[0].valueOf() || t[1].valueOf() !== n[1].valueOf()) && this.handleDomainChange(n);
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    if (!t || !n)
      return !1;
    const r = t[1].valueOf() - t[0].valueOf(), i = n[1].valueOf() - n[0].valueOf(), s = x(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return r / i < s;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    return !!(t && n && t[0].valueOf() === n[0].valueOf() && t[1].valueOf() === n[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(t) {
    return x(this.model.getOptions(), "zoomBar", t, "loading");
  }
  isZoomBarLocked(t) {
    return x(this.model.getOptions(), "zoomBar", t, "locked");
  }
};
function ZB(e, t, n) {
  var r = e.length;
  return n = n === void 0 ? r : n, !t && n >= r ? e : U0(e, t, n);
}
var KB = "\\ud800-\\udfff", QB = "\\u0300-\\u036f", JB = "\\ufe20-\\ufe2f", tH = "\\u20d0-\\u20ff", eH = QB + JB + tH, nH = "\\ufe0e\\ufe0f", rH = "\\u200d", iH = RegExp("[" + rH + KB + eH + nH + "]");
function F0(e) {
  return iH.test(e);
}
function sH(e) {
  return e.split("");
}
var z0 = "\\ud800-\\udfff", aH = "\\u0300-\\u036f", oH = "\\ufe20-\\ufe2f", lH = "\\u20d0-\\u20ff", cH = aH + oH + lH, uH = "\\ufe0e\\ufe0f", hH = "[" + z0 + "]", su = "[" + cH + "]", au = "\\ud83c[\\udffb-\\udfff]", dH = "(?:" + su + "|" + au + ")", G0 = "[^" + z0 + "]", j0 = "(?:\\ud83c[\\udde6-\\uddff]){2}", W0 = "[\\ud800-\\udbff][\\udc00-\\udfff]", fH = "\\u200d", q0 = dH + "?", Y0 = "[" + uH + "]?", pH = "(?:" + fH + "(?:" + [G0, j0, W0].join("|") + ")" + Y0 + q0 + ")*", mH = Y0 + q0 + pH, gH = "(?:" + [G0 + su + "?", su, j0, W0, hH].join("|") + ")", vH = RegExp(au + "(?=" + au + ")|" + gH + mH, "g");
function yH(e) {
  return e.match(vH) || [];
}
function xH(e) {
  return F0(e) ? yH(e) : sH(e);
}
function bH(e) {
  return function(t) {
    t = Hs(t);
    var n = F0(t) ? xH(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? ZB(n, 1).join("") : t.slice(1);
    return r[e]() + i;
  };
}
var EH = bH("toUpperCase");
function _H(e) {
  return EH(Hs(e).toLowerCase());
}
var wH = h0(function(e, t, n) {
  return t = t.toLowerCase(), e + (n ? _H(t) : t);
});
class en {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(t, n) {
    this.components = [], this.services = {
      canvasZoom: CB,
      domUtils: N,
      events: AB,
      files: $B,
      gradientUtils: Nc,
      transitions: LB
    }, this.model = new pn(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(t, n) {
    this.model.set({ holder: t }, { skipUpdate: !0 }), Object.keys(this.services).forEach((r) => {
      const i = this.services[r];
      this.services[r] = new i(this.model, this.services);
    }), this.services.events.addEventListener(O.Model.UPDATE, (r) => {
      const i = !!x(r, "detail", "animate");
      this.update(i);
    }), this.model.setData(n.data), this.services.events.addEventListener(O.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(t = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((i) => {
      this.services[i].update();
    }), this.components.forEach((i) => i.render(t));
    const n = this.services.transitions.getPendingTransitions(), r = Object.keys(n).map((i) => n[i].end().catch((s) => s));
    Promise.all(r).then(
      () => this.services.events.dispatchEvent(O.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((t) => t.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = x(r, "toolbar", "enabled"), s = {
      id: "legend",
      components: [new lh(this.model, this.services)],
      growth: ut.PREFERRED
    }, a = x(r, "canvasZoom", "enabled");
    a && a === !0 && t.push(new rN(this.model, this.services));
    const o = !!this.model.getOptions().title, l = {
      id: "title",
      components: [new zs(this.model, this.services)],
      growth: ut.STRETCH
    }, c = {
      id: "toolbar",
      components: [new Zo(this.model, this.services)],
      growth: ut.PREFERRED
    }, u = {
      id: "header",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            l,
            ...i ? [c] : []
          ],
          {
            direction: Ht.ROW,
            alignItems: mi.CENTER
          }
        )
      ],
      growth: ut.PREFERRED
    }, d = {
      id: "graph-frame",
      components: t,
      growth: ut.STRETCH,
      renderType: x(n, "graphFrameRenderType") || rt.SVG
    }, h = x(n, "excludeLegend") !== !0 && r.legend.enabled !== !1;
    let f = Ht.COLUMN;
    if (h) {
      const y = x(r, "legend", "position");
      y === "left" ? (f = Ht.ROW, r.legend.orientation || (r.legend.orientation = ps.VERTICAL)) : y === "right" ? (f = Ht.ROW_REVERSE, r.legend.orientation || (r.legend.orientation = ps.VERTICAL)) : y === "bottom" && (f = Ht.COLUMN_REVERSE);
    }
    const p = {
      id: "spacer",
      components: [new Nn(this.model, this.services)],
      growth: ut.PREFERRED
    }, v = {
      id: "full-frame",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            ...h ? [s] : [],
            ...h ? [p] : [],
            d
          ],
          {
            direction: f
          }
        )
      ],
      growth: ut.STRETCH
    }, m = [];
    if (o || i) {
      m.push(u);
      const y = {
        id: "spacer",
        components: [
          new Nn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ut.PREFERRED
      };
      m.push(y);
    }
    return m.push(v), [
      new ch(this.model, this.services),
      new Ko(this.model, this.services),
      new Ce(this.model, this.services, m, {
        direction: Ht.COLUMN
      })
    ];
  }
}
class _e extends en {
  constructor(t, n) {
    super(t, n), this.services = Object.assign(this.services, {
      cartesianScales: jB,
      curves: YB,
      zoom: XB
    }), this.model = new $r(this.services);
  }
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = x(r, "zoomBar", F.TOP, "enabled"), s = x(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const a = this.services.cartesianScales.getMainXAxisPosition(), o = x(r, "axes", a, "scaleType"), l = i && a === F.BOTTOM && o === et.TIME, c = this.services.zoom.isZoomBarLocked(F.TOP), u = !!this.model.getOptions().title, d = {
      id: "title",
      components: [new zs(this.model, this.services)],
      growth: ut.STRETCH
    }, h = {
      id: "toolbar",
      components: [new Zo(this.model, this.services)],
      growth: ut.PREFERRED
    }, f = {
      id: "header",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            d,
            ...s ? [h] : []
          ],
          {
            direction: Ht.ROW,
            alignItems: mi.CENTER
          }
        )
      ],
      growth: ut.PREFERRED
    }, p = {
      id: "legend",
      components: [new lh(this.model, this.services)],
      growth: ut.PREFERRED
    };
    l && !c && t.push(
      new T0(this.model, this.services),
      new iN(this.model, this.services)
    ), t.push(new aN(this.model, this.services)), t.push(new oN(this.model, this.services));
    const v = {
      id: "graph-frame",
      components: t,
      growth: ut.STRETCH,
      renderType: rt.SVG
    }, m = x(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let y = Ht.COLUMN;
    if (m) {
      const S = x(this.model.getOptions(), "legend", "position");
      S === ss.LEFT ? (y = Ht.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = ps.VERTICAL)) : S === ss.RIGHT ? (y = Ht.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = ps.VERTICAL)) : S === ss.BOTTOM && (y = Ht.COLUMN_REVERSE);
    }
    const g = {
      id: "spacer",
      components: [new Nn(this.model, this.services)],
      growth: ut.PREFERRED
    }, b = {
      id: "full-frame",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            ...m ? [p] : [],
            ...m ? [g] : [],
            v
          ],
          {
            direction: y
          }
        )
      ],
      growth: ut.STRETCH
    }, w = {
      id: "zoom-bar",
      components: [new sN(this.model, this.services)],
      growth: ut.PREFERRED,
      renderType: rt.SVG
    }, _ = [];
    if (u || s) {
      _.push(f);
      const S = {
        id: "spacer",
        components: [
          new Nn(this.model, this.services, s ? { size: 15 } : void 0)
        ],
        growth: ut.PREFERRED
      };
      _.push(S);
    }
    return l && _.push(w), _.push(b), [
      new C0(this.model, this.services),
      new Ko(this.model, this.services),
      new Ce(this.model, this.services, _, {
        direction: Ht.COLUMN
      })
    ];
  }
}
class SH extends en {
  constructor(t, n) {
    super(t, n), this.model = new xL(this.services), this.model.setOptions(Wt(Nt.alluvialChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new lN(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class OH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(
      Wt(In(Nt.areaChart), n.options)
    ), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new Qn(this.model, this.services),
      new ei(this.model, this.services),
      new A0(this.model, this.services),
      new hn(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class TH extends _e {
  constructor(t, n) {
    super(t, n), this.model = new bL(this.services), this.model.setOptions(Wt(Nt.boxplotChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new hN(this.model, this.services),
      new yi(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t, {
      legend: {
        enabled: !1
      }
    });
  }
}
class MH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.bubbleChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new Qn(this.model, this.services),
      new dN(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class CH extends _e {
  constructor(t, n) {
    super(t, n), this.model = new EL(this.services), this.model.setOptions(Wt(Nt.bulletChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new fN(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class AH extends en {
  constructor(t, n) {
    super(t, n), this.model = new _L(this.services), this.model.setOptions(
      Wt(Nt.choroplethChart, n.options)
    ), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = x(r, "toolbar", "enabled"), s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new zs(this.model, this.services)],
      growth: ut.STRETCH
    }, o = {
      id: "toolbar",
      components: [new Zo(this.model, this.services)],
      growth: ut.PREFERRED
    }, l = {
      id: "header",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: Ht.ROW,
            alignItems: mi.CENTER
          }
        )
      ],
      growth: ut.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new L0(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: ut.PREFERRED,
      renderType: rt.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: ut.STRETCH,
      renderType: rt.SVG
    }, d = x(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = Ht.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new Nn(this.model, this.services, { size: 15 })],
      growth: ut.PREFERRED
    }, p = {
      id: "full-frame",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            ...d ? [c] : [],
            ...d ? [f] : [],
            u
          ],
          {
            direction: h
          }
        )
      ],
      growth: ut.STRETCH
    }, v = [];
    if (s || i) {
      v.push(l);
      const m = {
        id: "spacer",
        components: [
          new Nn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ut.PREFERRED
      };
      v.push(m);
    }
    return v.push(p), [
      new ch(this.model, this.services),
      new Ko(this.model, this.services),
      new Ce(this.model, this.services, v, {
        direction: Ht.COLUMN
      })
    ];
  }
  getComponents() {
    const t = [new xB(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class $H extends en {
  constructor(t, n) {
    super(t, n), this.model = new wL(this.services), this.model.setOptions(Wt(Nt.circlePackChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new LN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
const wp = {
  [Ie.LINE]: [ei, hn],
  [Ie.SCATTER]: [hn],
  [Ie.AREA]: [A0, ei, hn],
  [Ie.STACKED_AREA]: [I0, ei, P0, wo],
  [Ie.SIMPLE_BAR]: [D0],
  [Ie.GROUPED_BAR]: [k0, yi],
  [Ie.STACKED_BAR]: [N0, wo]
};
class LH extends _e {
  constructor(t, n) {
    super(t, n);
    const r = Wt(Nt.comboChart, n.options);
    n.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), r.comboChartTypes = [{ type: Ie.LINE, correspondingDatasets: [] }]), this.model.setOptions(r), this.init(t, n);
  }
  getGraphComponents() {
    const { comboChartTypes: t } = this.model.getOptions();
    let n = 0;
    const r = t.map((i) => {
      const s = i.type;
      let a;
      if (typeof i.type == "string") {
        if (!Object.keys(wp).includes(i.type))
          return console.error(
            `Invalid chart type "${i.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let o = !1;
        const l = `${wH(i.type)}Chart`;
        return a = ct({}, Nt[l], this.model.getOptions(), i.options), i.type === Ie.STACKED_AREA && (o = !0), wp[i.type].map(
          (c) => new c(this.model, this.services, {
            groups: i.correspondingDatasets,
            id: n++,
            options: a,
            stacked: o
          })
        );
      } else
        return a = ct({}, this.model.getOptions(), i.options), new s(this.model, this.services, {
          groups: i.correspondingDatasets,
          id: n++,
          options: a
        });
    }).filter((i) => i !== null);
    return dh(r);
  }
  getComponents() {
    const { comboChartTypes: t } = this.model.getOptions(), n = t.some(
      (i) => i.type === Ie.STACKED_BAR || i.type === Ie.STACKED_AREA
    ), r = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      }),
      ...n ? [] : [new Qn(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(r);
  }
}
class X0 extends en {
  // TODO - Optimize the use of "extending"
  constructor(t, n, r = !1) {
    super(t, n), this.model = new SL(this.services), !r && (this.model.setOptions(Wt(Nt.pieChart, n.options)), this.init(t, n));
  }
  getComponents() {
    const t = [
      new R0(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
class RH extends X0 {
  constructor(t, n) {
    super(t, n, !0), this.model.setOptions(Wt(Nt.donutChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new kN(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.DONUT
      })
    ];
    return this.getChartComponents(t);
  }
}
class kH extends en {
  constructor(t, n) {
    super(t, n), this.model = new OL(this.services), this.model.setOptions(Wt(Nt.gaugeChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new DN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class DH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.groupedBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new k0(this.model, this.services),
      new yi(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class IH extends _e {
  constructor(t, n) {
    super(t, n), this.model = new TL(this.services), this.model.setOptions(
      Wt(Nt.heatmapChart, n.options)
    ), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = x(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new zs(this.model, this.services)],
      growth: ut.STRETCH
    }, o = {
      id: "toolbar",
      components: [new Zo(this.model, this.services)],
      growth: ut.PREFERRED
    }, l = {
      id: "header",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: Ht.ROW,
            alignItems: mi.CENTER
          }
        )
      ],
      growth: ut.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new L0(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: ut.PREFERRED,
      renderType: rt.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: ut.STRETCH,
      renderType: rt.SVG
    }, d = x(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1 && this.model.getData().length > 0, h = Ht.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new Nn(this.model, this.services, { size: 15 })],
      growth: ut.PREFERRED
    }, p = {
      id: "full-frame",
      components: [
        new Ce(
          this.model,
          this.services,
          [
            ...d ? [c] : [],
            ...d ? [f] : [],
            u
          ],
          {
            direction: h
          }
        )
      ],
      growth: ut.STRETCH
    }, v = [];
    if (s || i) {
      v.push(l);
      const m = {
        id: "spacer",
        components: [
          new Nn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: ut.PREFERRED
      };
      v.push(m);
    }
    return v.push(p), [
      new C0(this.model, this.services),
      new Ko(this.model, this.services),
      new Ce(this.model, this.services, v, {
        direction: Ht.COLUMN
      })
    ];
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new IN(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class NH extends _e {
  constructor(t, n) {
    super(t, n), this.model = new ML(this.services), this.model.setOptions(Wt(Nt.histogramChart, n.options)), this.init(t, n), this.update();
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new _N(this.model, this.services),
      new NN(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class PH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.lineChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new Qn(this.model, this.services),
      new ei(this.model, this.services),
      new hn(this.model, this.services, { handleThresholds: !0 }),
      new HN(this.model, this.services),
      new yi(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class UH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.lollipopChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new Qn(this.model, this.services),
      new PN(this.model, this.services),
      new hn(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class BH extends en {
  constructor(t, n) {
    var r;
    super(t, n), this.model = new CL(this.services);
    const i = (r = n.options.meter) != null && r.proportional ? ct(In(Nt.proportionalMeterChart), n.options) : ct(In(Nt.meterChart), n.options);
    this.model.setOptions(i), this.init(t, n);
  }
  getComponents() {
    const t = [
      ...x(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new $N(this.model, this.services)],
          growth: ut.STRETCH,
          renderType: rt.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new Nn(this.model, this.services, {
              size: 8
            })
          ],
          growth: ut.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new UN(this.model, this.services)],
        growth: ut.STRETCH,
        renderType: rt.SVG
      }
    ], n = [
      new Ce(this.model, this.services, t, {
        direction: Ht.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: rt.HTML
    });
  }
}
class HH extends en {
  constructor(t, n) {
    super(t, n), this.model = new AL(this.services), this.model.setOptions(Wt(Nt.radarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new BN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class VH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.scatterChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new Qn(this.model, this.services),
      new hn(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class FH extends en {
  constructor(t, n) {
    super(t, n), this.model = new $L(this.services), this.model.setOptions(Wt(Nt.treeChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new VN(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class zH extends en {
  constructor(t, n) {
    super(t, n), this.model = new LL(this.services), this.model.setOptions(Wt(Nt.treemapChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new gB(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class GH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.simpleBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new D0(this.model, this.services),
      new yi(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class jH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.stackedAreaChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new wo(this.model, this.services),
      new I0(this.model, this.services),
      new ei(this.model, this.services, { stacked: !0 }),
      new P0(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new pe(this.model, this.services, {
        skeleton: Jt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class WH extends _e {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Wt(Nt.stackedBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new Ee(this.model, this.services),
      new Re(this.model, this.services),
      new wo(this.model, this.services),
      new N0(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.VERT_OR_HORIZ
      }),
      new yi(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class qH extends en {
  constructor(t, n) {
    super(t, n), this.model = new RL(this.services), this.model.setOptions(Wt(Nt.wordCloudChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new vB(this.model, this.services),
      new pe(this.model, this.services, {
        skeleton: Jt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
var ou = { exports: {} }, zi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Sp;
function YH() {
  if (Sp)
    return zi;
  Sp = 1;
  var e = Da, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, l, c) {
    var u, d = {}, h = null, f = null;
    c !== void 0 && (h = "" + c), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (u in l)
      r.call(l, u) && !s.hasOwnProperty(u) && (d[u] = l[u]);
    if (o && o.defaultProps)
      for (u in l = o.defaultProps, l)
        d[u] === void 0 && (d[u] = l[u]);
    return { $$typeof: t, type: o, key: h, ref: f, props: d, _owner: i.current };
  }
  return zi.Fragment = n, zi.jsx = a, zi.jsxs = a, zi;
}
var Gi = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Op;
function XH() {
  return Op || (Op = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Da, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = Symbol.iterator, v = "@@iterator";
    function m(C) {
      if (C === null || typeof C != "object")
        return null;
      var z = p && C[p] || C[v];
      return typeof z == "function" ? z : null;
    }
    var y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(C) {
      {
        for (var z = arguments.length, X = new Array(z > 1 ? z - 1 : 0), lt = 1; lt < z; lt++)
          X[lt - 1] = arguments[lt];
        b("error", C, X);
      }
    }
    function b(C, z, X) {
      {
        var lt = y.ReactDebugCurrentFrame, Et = lt.getStackAddendum();
        Et !== "" && (z += "%s", X = X.concat([Et]));
        var Mt = X.map(function(xt) {
          return String(xt);
        });
        Mt.unshift("Warning: " + z), Function.prototype.apply.call(console[C], console, Mt);
      }
    }
    var w = !1, _ = !1, S = !1, L = !1, D = !1, k;
    k = Symbol.for("react.module.reference");
    function R(C) {
      return !!(typeof C == "string" || typeof C == "function" || C === r || C === s || D || C === i || C === c || C === u || L || C === f || w || _ || S || typeof C == "object" && C !== null && (C.$$typeof === h || C.$$typeof === d || C.$$typeof === a || C.$$typeof === o || C.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      C.$$typeof === k || C.getModuleId !== void 0));
    }
    function M(C, z, X) {
      var lt = C.displayName;
      if (lt)
        return lt;
      var Et = z.displayName || z.name || "";
      return Et !== "" ? X + "(" + Et + ")" : X;
    }
    function V(C) {
      return C.displayName || "Context";
    }
    function P(C) {
      if (C == null)
        return null;
      if (typeof C.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
        return C.displayName || C.name || null;
      if (typeof C == "string")
        return C;
      switch (C) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case o:
            var z = C;
            return V(z) + ".Consumer";
          case a:
            var X = C;
            return V(X._context) + ".Provider";
          case l:
            return M(C, C.render, "ForwardRef");
          case d:
            var lt = C.displayName || null;
            return lt !== null ? lt : P(C.type) || "Memo";
          case h: {
            var Et = C, Mt = Et._payload, xt = Et._init;
            try {
              return P(xt(Mt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, E = 0, A, $, U, B, W, K, Q;
    function dt() {
    }
    dt.__reactDisabledLog = !0;
    function it() {
      {
        if (E === 0) {
          A = console.log, $ = console.info, U = console.warn, B = console.error, W = console.group, K = console.groupCollapsed, Q = console.groupEnd;
          var C = {
            configurable: !0,
            enumerable: !0,
            value: dt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: C,
            log: C,
            warn: C,
            error: C,
            group: C,
            groupCollapsed: C,
            groupEnd: C
          });
        }
        E++;
      }
    }
    function pt() {
      {
        if (E--, E === 0) {
          var C = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, C, {
              value: A
            }),
            info: H({}, C, {
              value: $
            }),
            warn: H({}, C, {
              value: U
            }),
            error: H({}, C, {
              value: B
            }),
            group: H({}, C, {
              value: W
            }),
            groupCollapsed: H({}, C, {
              value: K
            }),
            groupEnd: H({}, C, {
              value: Q
            })
          });
        }
        E < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Z = y.ReactCurrentDispatcher, tt;
    function ft(C, z, X) {
      {
        if (tt === void 0)
          try {
            throw Error();
          } catch (Et) {
            var lt = Et.stack.trim().match(/\n( *(at )?)/);
            tt = lt && lt[1] || "";
          }
        return `
` + tt + C;
      }
    }
    var q = !1, J;
    {
      var ot = typeof WeakMap == "function" ? WeakMap : Map;
      J = new ot();
    }
    function G(C, z) {
      if (!C || q)
        return "";
      {
        var X = J.get(C);
        if (X !== void 0)
          return X;
      }
      var lt;
      q = !0;
      var Et = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Mt;
      Mt = Z.current, Z.current = null, it();
      try {
        if (z) {
          var xt = function() {
            throw Error();
          };
          if (Object.defineProperty(xt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(xt, []);
            } catch (Kt) {
              lt = Kt;
            }
            Reflect.construct(C, [], xt);
          } else {
            try {
              xt.call();
            } catch (Kt) {
              lt = Kt;
            }
            C.call(xt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Kt) {
            lt = Kt;
          }
          C();
        }
      } catch (Kt) {
        if (Kt && lt && typeof Kt.stack == "string") {
          for (var T = Kt.stack.split(`
`), Y = lt.stack.split(`
`), j = T.length - 1, at = Y.length - 1; j >= 1 && at >= 0 && T[j] !== Y[at]; )
            at--;
          for (; j >= 1 && at >= 0; j--, at--)
            if (T[j] !== Y[at]) {
              if (j !== 1 || at !== 1)
                do
                  if (j--, at--, at < 0 || T[j] !== Y[at]) {
                    var Ct = `
` + T[j].replace(" at new ", " at ");
                    return C.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", C.displayName)), typeof C == "function" && J.set(C, Ct), Ct;
                  }
                while (j >= 1 && at >= 0);
              break;
            }
        }
      } finally {
        q = !1, Z.current = Mt, pt(), Error.prepareStackTrace = Et;
      }
      var Pt = C ? C.displayName || C.name : "", ke = Pt ? ft(Pt) : "";
      return typeof C == "function" && J.set(C, ke), ke;
    }
    function wt(C, z, X) {
      return G(C, !1);
    }
    function bt(C) {
      var z = C.prototype;
      return !!(z && z.isReactComponent);
    }
    function Gt(C, z, X) {
      if (C == null)
        return "";
      if (typeof C == "function")
        return G(C, bt(C));
      if (typeof C == "string")
        return ft(C);
      switch (C) {
        case c:
          return ft("Suspense");
        case u:
          return ft("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case l:
            return wt(C.render);
          case d:
            return Gt(C.type, z, X);
          case h: {
            var lt = C, Et = lt._payload, Mt = lt._init;
            try {
              return Gt(Mt(Et), z, X);
            } catch {
            }
          }
        }
      return "";
    }
    var It = Object.prototype.hasOwnProperty, nt = {}, Tt = y.ReactDebugCurrentFrame;
    function we(C) {
      if (C) {
        var z = C._owner, X = Gt(C.type, C._source, z ? z.type : null);
        Tt.setExtraStackFrame(X);
      } else
        Tt.setExtraStackFrame(null);
    }
    function Se(C, z, X, lt, Et) {
      {
        var Mt = Function.call.bind(It);
        for (var xt in C)
          if (Mt(C, xt)) {
            var T = void 0;
            try {
              if (typeof C[xt] != "function") {
                var Y = Error((lt || "React class") + ": " + X + " type `" + xt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[xt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Y.name = "Invariant Violation", Y;
              }
              T = C[xt](z, xt, lt, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (j) {
              T = j;
            }
            T && !(T instanceof Error) && (we(Et), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", lt || "React class", X, xt, typeof T), we(null)), T instanceof Error && !(T.message in nt) && (nt[T.message] = !0, we(Et), g("Failed %s type: %s", X, T.message), we(null));
          }
      }
    }
    var Jo = Array.isArray;
    function er(C) {
      return Jo(C);
    }
    function nr(C) {
      {
        var z = typeof Symbol == "function" && Symbol.toStringTag, X = z && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return X;
      }
    }
    function Hn(C) {
      try {
        return mn(C), !1;
      } catch {
        return !0;
      }
    }
    function mn(C) {
      return "" + C;
    }
    function bi(C) {
      if (Hn(C))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", nr(C)), mn(C);
    }
    var Vn = y.ReactCurrentOwner, Gs = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Lr, Ei, Fn;
    Fn = {};
    function Rr(C) {
      if (It.call(C, "ref")) {
        var z = Object.getOwnPropertyDescriptor(C, "ref").get;
        if (z && z.isReactWarning)
          return !1;
      }
      return C.ref !== void 0;
    }
    function Fe(C) {
      if (It.call(C, "key")) {
        var z = Object.getOwnPropertyDescriptor(C, "key").get;
        if (z && z.isReactWarning)
          return !1;
      }
      return C.key !== void 0;
    }
    function zn(C, z) {
      if (typeof C.ref == "string" && Vn.current && z && Vn.current.stateNode !== z) {
        var X = P(Vn.current.type);
        Fn[X] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', P(Vn.current.type), C.ref), Fn[X] = !0);
      }
    }
    function _i(C, z) {
      {
        var X = function() {
          Lr || (Lr = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        X.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: X,
          configurable: !0
        });
      }
    }
    function wi(C, z) {
      {
        var X = function() {
          Ei || (Ei = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", z));
        };
        X.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: X,
          configurable: !0
        });
      }
    }
    var tl = function(C, z, X, lt, Et, Mt, xt) {
      var T = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: C,
        key: z,
        ref: X,
        props: xt,
        // Record the component responsible for creating this element.
        _owner: Mt
      };
      return T._store = {}, Object.defineProperty(T._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(T, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lt
      }), Object.defineProperty(T, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Et
      }), Object.freeze && (Object.freeze(T.props), Object.freeze(T)), T;
    };
    function rr(C, z, X, lt, Et) {
      {
        var Mt, xt = {}, T = null, Y = null;
        X !== void 0 && (bi(X), T = "" + X), Fe(z) && (bi(z.key), T = "" + z.key), Rr(z) && (Y = z.ref, zn(z, Et));
        for (Mt in z)
          It.call(z, Mt) && !Gs.hasOwnProperty(Mt) && (xt[Mt] = z[Mt]);
        if (C && C.defaultProps) {
          var j = C.defaultProps;
          for (Mt in j)
            xt[Mt] === void 0 && (xt[Mt] = j[Mt]);
        }
        if (T || Y) {
          var at = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          T && _i(xt, at), Y && wi(xt, at);
        }
        return tl(C, T, Y, Et, lt, Vn.current, xt);
      }
    }
    var Si = y.ReactCurrentOwner, js = y.ReactDebugCurrentFrame;
    function Vt(C) {
      if (C) {
        var z = C._owner, X = Gt(C.type, C._source, z ? z.type : null);
        js.setExtraStackFrame(X);
      } else
        js.setExtraStackFrame(null);
    }
    var nn;
    nn = !1;
    function Oi(C) {
      return typeof C == "object" && C !== null && C.$$typeof === t;
    }
    function Ti() {
      {
        if (Si.current) {
          var C = P(Si.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
    }
    function Mi(C) {
      {
        if (C !== void 0) {
          var z = C.fileName.replace(/^.*[\\\/]/, ""), X = C.lineNumber;
          return `

Check your code at ` + z + ":" + X + ".";
        }
        return "";
      }
    }
    var Ci = {};
    function Ws(C) {
      {
        var z = Ti();
        if (!z) {
          var X = typeof C == "string" ? C : C.displayName || C.name;
          X && (z = `

Check the top-level render call using <` + X + ">.");
        }
        return z;
      }
    }
    function qs(C, z) {
      {
        if (!C._store || C._store.validated || C.key != null)
          return;
        C._store.validated = !0;
        var X = Ws(z);
        if (Ci[X])
          return;
        Ci[X] = !0;
        var lt = "";
        C && C._owner && C._owner !== Si.current && (lt = " It was passed a child from " + P(C._owner.type) + "."), Vt(C), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, lt), Vt(null);
      }
    }
    function Ai(C, z) {
      {
        if (typeof C != "object")
          return;
        if (er(C))
          for (var X = 0; X < C.length; X++) {
            var lt = C[X];
            Oi(lt) && qs(lt, z);
          }
        else if (Oi(C))
          C._store && (C._store.validated = !0);
        else if (C) {
          var Et = m(C);
          if (typeof Et == "function" && Et !== C.entries)
            for (var Mt = Et.call(C), xt; !(xt = Mt.next()).done; )
              Oi(xt.value) && qs(xt.value, z);
        }
      }
    }
    function Ys(C) {
      {
        var z = C.type;
        if (z == null || typeof z == "string")
          return;
        var X;
        if (typeof z == "function")
          X = z.propTypes;
        else if (typeof z == "object" && (z.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        z.$$typeof === d))
          X = z.propTypes;
        else
          return;
        if (X) {
          var lt = P(z);
          Se(X, C.props, "prop", lt, C);
        } else if (z.PropTypes !== void 0 && !nn) {
          nn = !0;
          var Et = P(z);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Et || "Unknown");
        }
        typeof z.getDefaultProps == "function" && !z.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function el(C) {
      {
        for (var z = Object.keys(C.props), X = 0; X < z.length; X++) {
          var lt = z[X];
          if (lt !== "children" && lt !== "key") {
            Vt(C), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", lt), Vt(null);
            break;
          }
        }
        C.ref !== null && (Vt(C), g("Invalid attribute `ref` supplied to `React.Fragment`."), Vt(null));
      }
    }
    function gn(C, z, X, lt, Et, Mt) {
      {
        var xt = R(C);
        if (!xt) {
          var T = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (T += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Y = Mi(Et);
          Y ? T += Y : T += Ti();
          var j;
          C === null ? j = "null" : er(C) ? j = "array" : C !== void 0 && C.$$typeof === t ? (j = "<" + (P(C.type) || "Unknown") + " />", T = " Did you accidentally export a JSX literal instead of a component?") : j = typeof C, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", j, T);
        }
        var at = rr(C, z, X, Et, Mt);
        if (at == null)
          return at;
        if (xt) {
          var Ct = z.children;
          if (Ct !== void 0)
            if (lt)
              if (er(Ct)) {
                for (var Pt = 0; Pt < Ct.length; Pt++)
                  Ai(Ct[Pt], C);
                Object.freeze && Object.freeze(Ct);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ai(Ct, C);
        }
        return C === r ? el(at) : Ys(at), at;
      }
    }
    function $i(C, z, X) {
      return gn(C, z, X, !0);
    }
    function Xs(C, z, X) {
      return gn(C, z, X, !1);
    }
    var Zs = Xs, nl = $i;
    Gi.Fragment = r, Gi.jsx = Zs, Gi.jsxs = nl;
  }()), Gi;
}
process.env.NODE_ENV === "production" ? ou.exports = YH() : ou.exports = XH();
var jt = ou.exports;
class zt extends Da.PureComponent {
  constructor() {
    super(...arguments);
    rl(this, "chart");
    rl(this, "chartRef", Da.createRef());
  }
  // TODO: add abstract keyword once React 16 support no longer needed then remove the next 3 comments
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createChart(n, r, i) {
    throw new Error("Method not implemented.");
  }
  componentDidMount() {
    this.chartRef.current && !this.chart && (this.chart = this.createChart(this.chartRef.current, this.props.data, this.props.options));
  }
  componentDidUpdate(n) {
    var r, i;
    this.props.data !== n.data && ((r = this.chart) == null || r.model.setData(this.props.data)), this.props.options !== n.options && ((i = this.chart) == null || i.model.setOptions(this.props.options));
  }
  render() {
    return /* @__PURE__ */ jt.jsx("div", { ref: this.chartRef, className: "chart-holder" });
  }
}
class x3 extends zt {
  createChart(t, n, r) {
    return new SH(t, { data: n, options: r });
  }
}
class b3 extends zt {
  createChart(t, n, r) {
    return new OH(t, { data: n, options: r });
  }
}
class E3 extends zt {
  createChart(t, n, r) {
    return new TH(t, { data: n, options: r });
  }
}
class _3 extends zt {
  createChart(t, n, r) {
    return new MH(t, { data: n, options: r });
  }
}
class w3 extends zt {
  createChart(t, n, r) {
    return new CH(t, { data: n, options: r });
  }
}
class S3 extends zt {
  createChart(t, n, r) {
    return new AH(t, { data: n, options: r });
  }
}
class O3 extends zt {
  createChart(t, n, r) {
    return new $H(t, { data: n, options: r });
  }
}
class T3 extends zt {
  createChart(t, n, r) {
    return new LH(t, { data: n, options: r });
  }
}
class M3 extends zt {
  createChart(t, n, r) {
    return new RH(t, { data: n, options: r });
  }
}
class C3 extends zt {
  createChart(t, n, r) {
    return new kH(t, { data: n, options: r });
  }
}
class A3 extends zt {
  createChart(t, n, r) {
    return new DH(t, { data: n, options: r });
  }
}
class $3 extends zt {
  createChart(t, n, r) {
    return new IH(t, { data: n, options: r });
  }
}
class L3 extends zt {
  createChart(t, n, r) {
    return new NH(t, { data: n, options: r });
  }
}
class R3 extends zt {
  createChart(t, n, r) {
    return new PH(t, { data: n, options: r });
  }
}
class k3 extends zt {
  createChart(t, n, r) {
    return new UH(t, { data: n, options: r });
  }
}
class D3 extends zt {
  createChart(t, n, r) {
    return new BH(t, { data: n, options: r });
  }
}
class I3 extends zt {
  createChart(t, n, r) {
    return new X0(t, { data: n, options: r });
  }
}
class N3 extends zt {
  createChart(t, n, r) {
    return new HH(t, { data: n, options: r });
  }
}
class P3 extends zt {
  createChart(t, n, r) {
    return new VH(t, { data: n, options: r });
  }
}
class U3 extends zt {
  createChart(t, n, r) {
    return new GH(t, { data: n, options: r });
  }
}
class B3 extends zt {
  createChart(t, n, r) {
    return new jH(t, { data: n, options: r });
  }
}
class H3 extends zt {
  createChart(t, n, r) {
    return new WH(t, { data: n, options: r });
  }
}
class V3 extends zt {
  createChart(t, n, r) {
    return new FH(t, { data: n, options: r });
  }
}
class F3 extends zt {
  createChart(t, n, r) {
    return new zH(t, { data: n, options: r });
  }
}
class z3 extends zt {
  createChart(t, n, r) {
    return new qH(t, { data: n, options: r });
  }
}
var Z0 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var s = "", a = 0; a < arguments.length; a++) {
        var o = arguments[a];
        o && (s = i(s, r(o)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return n.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var a = "";
      for (var o in s)
        t.call(s, o) && s[o] && (a = i(a, o));
      return a;
    }
    function i(s, a) {
      return a ? s ? s + " " + a : s + a : s;
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(Z0);
var ZH = Z0.exports;
const Jn = /* @__PURE__ */ Xv(ZH), tr = "cds", G3 = ({ tag: e = "div", className: t, children: n, color: r, href: i, position: s = "static", stacked: a, ...o }) => {
  const l = i ? "a" : o.onClick ? "button" : e, c = `${tr}--cc--card-node`, u = Jn(c, {
    [`${c}--stacked`]: a,
    [`${c}--${l}`]: l,
    [t]: t
  });
  return /* @__PURE__ */ jt.jsx(
    l,
    {
      className: u,
      style: { borderColor: r, position: s },
      tabIndex: 0,
      ...o,
      children: n
    }
  );
}, j3 = ({
  children: e,
  farsideColumn: t = !1,
  ...n
}) => {
  const r = `${tr}--cc--card-node`, i = Jn(`${r}__column`, {
    [`${r}__column--farside`]: t,
    ...n.className ? { [n.className]: !0 } : {}
  });
  return /* @__PURE__ */ jt.jsx("div", { className: i, ...n, children: e });
}, W3 = ({
  children: e,
  ...t
}) => {
  const n = `${tr}--cc--card-node`, r = Jn(`${n}__label`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ jt.jsx("label", { className: r, ...t, children: e });
}, q3 = ({
  children: e,
  ...t
}) => {
  const n = `${tr}--cc--card-node`, r = Jn(`${n}__subtitle`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ jt.jsx("div", { className: r, ...t, children: e });
}, Y3 = ({
  children: e,
  ...t
}) => {
  const n = `${tr}--cc--card-node`, r = Jn(`${n}__title`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ jt.jsx("div", { className: r, ...t, children: e });
}, X3 = ({
  color: e,
  markerEnd: t,
  markerStart: n,
  path: r,
  source: i,
  target: s,
  variant: a = null,
  ...o
}) => {
  const l = `${tr}--cc--edge`, c = Jn(l, {
    [`${l}--${a}`]: a,
    ...o.className ? { [o.className]: !0 } : {}
  });
  let u = r;
  if (!u && i && s && (u = wN(i, s)), !u)
    throw Error("Missing parameters for Edge component: path or source and target.");
  return /* @__PURE__ */ jt.jsxs("g", { className: c, ...o, children: [
    /* @__PURE__ */ jt.jsx("path", { d: u, className: `${l}__container` }),
    /* @__PURE__ */ jt.jsx("path", { d: u, className: `${l}__outer` }),
    /* @__PURE__ */ jt.jsx(
      "path",
      {
        d: u,
        className: `${l}__inner`,
        markerEnd: `url(#${t})`,
        markerStart: `url(#${n})`,
        style: { stroke: e }
      }
    )
  ] });
}, xi = ({
  color: e,
  d: t,
  id: n,
  orient: r = "auto",
  height: i,
  width: s,
  position: a = "end",
  className: o,
  refX: l,
  refY: c,
  ...u
}) => {
  const d = `${tr}--cc--marker`, h = Jn(d, o), f = a === "end" ? (s || 0) / 2 + 0.5 : 0.5, p = (i || 0) / 2;
  return /* @__PURE__ */ jt.jsx(
    "marker",
    {
      className: h,
      markerHeight: i,
      markerWidth: s,
      orient: r,
      id: n,
      refX: l || f,
      refY: c || p,
      markerUnits: "userSpaceOnUse",
      ...u,
      children: /* @__PURE__ */ jt.jsx("path", { d: t, style: { fill: e } })
    }
  );
}, Z3 = (e) => /* @__PURE__ */ jt.jsx(xi, { d: SN.d, ...e }), K3 = (e) => /* @__PURE__ */ jt.jsx(xi, { d: ON.d, ...e }), Q3 = (e) => /* @__PURE__ */ jt.jsx(xi, { d: TN.d, ...e }), J3 = (e) => /* @__PURE__ */ jt.jsx(xi, { d: MN.d, ...e }), tV = (e) => /* @__PURE__ */ jt.jsx(xi, { d: CN.d, ...e }), eV = (e) => /* @__PURE__ */ jt.jsx(xi, { d: AN.d, ...e }), nV = ({
  shape: e = "circle",
  tag: t = "div",
  title: n = "Title",
  className: r,
  subtitle: i,
  description: s,
  renderIcon: a,
  href: o,
  size: l = 48,
  stacked: c,
  position: u = "fixed",
  bodyPosition: d = "absolute",
  ...h
}) => {
  const f = o ? "a" : h.onClick ? "button" : t, p = `${tr}--cc--shape-node`, v = Jn(p, {
    [`${p}--stacked`]: c,
    [`${p}--${e}`]: e,
    [`${p}--${f}`]: f,
    [r]: r
  }), m = n ? /* @__PURE__ */ jt.jsx("div", { className: `${p}__title`, children: n }) : null, y = i ? /* @__PURE__ */ jt.jsx("div", { className: `${p}__subtitle`, children: i }) : null, g = s ? /* @__PURE__ */ jt.jsx("div", { className: `${p}__description`, children: s }) : null;
  return /* @__PURE__ */ jt.jsxs(
    f,
    {
      className: v,
      style: { height: l, width: l, position: u },
      tabIndex: 0,
      ...h,
      children: [
        /* @__PURE__ */ jt.jsx("div", { className: `${p}__icon`, children: a }),
        /* @__PURE__ */ jt.jsxs("div", { className: `${p}__body`, style: { position: d }, children: [
          m,
          y,
          g
        ] })
      ]
    }
  );
};
export {
  ee as Alignments,
  x3 as AlluvialChart,
  b3 as AreaChart,
  Z3 as ArrowLeftMarker,
  K3 as ArrowRightMarker,
  E3 as BoxplotChart,
  _3 as BubbleChart,
  w3 as BulletChart,
  G3 as CardNode,
  j3 as CardNodeColumn,
  W3 as CardNodeLabel,
  q3 as CardNodeSubtitle,
  Y3 as CardNodeTitle,
  Kp as ChartTheme,
  Q3 as CircleMarker,
  O3 as CirclePackChart,
  T3 as ComboChart,
  J3 as DiamondMarker,
  M3 as DonutChart,
  X3 as Edge,
  S3 as ExperimentalChoroplethChart,
  C3 as GaugeChart,
  A3 as GroupedBarChart,
  $3 as HeatmapChart,
  L3 as HistogramChart,
  R3 as LineChart,
  k3 as LollipopChart,
  xi as Marker,
  D3 as MeterChart,
  I3 as PieChart,
  N3 as RadarChart,
  et as ScaleTypes,
  P3 as ScatterChart,
  nV as ShapeNode,
  U3 as SimpleBarChart,
  tV as SquareMarker,
  B3 as StackedAreaChart,
  H3 as StackedBarChart,
  eV as TeeMarker,
  V3 as TreeChart,
  F3 as TreemapChart,
  z3 as WordCloudChart
};
//# sourceMappingURL=index.mjs.map
